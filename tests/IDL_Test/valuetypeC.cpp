// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v4.0.2
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       https://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     https://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_codegen.cpp:372


#include "valuetypeC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/AnyTypeCode/Recursive_Type_TypeCode.h"
#include "tao/CDR.h"
#include "tao/Messaging/Asynch_Invocation_Adapter.h"
#include "tao/Messaging/ExceptionHolder_i.h"
#include "tao/Object_T.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "cstring"
#include "memory"

#if !defined (__ACE_INLINE__)
#include "valuetypeC.inl"
#endif /* !defined INLINE */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_MyValueType[] =
  {
    { "my_string_value", &CORBA::_tc_string, ::CORBA::PUBLIC_MEMBER }
    
  };
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_MyValueType (
    ::CORBA::tk_value,
    "IDL:MyValueType:1.0",
    "MyValueType",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_MyValueType,
    1);
  
::CORBA::TypeCode_ptr const _tc_MyValueType =
  &_tao_tc_MyValueType;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<MyValueType>::add_ref (MyValueType * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<MyValueType>::remove_ref (MyValueType * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<MyValueType>::release (MyValueType * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



MyValueType *
MyValueType::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::MyValueType *> (v);
}

const char *
MyValueType::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
MyValueType::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
MyValueType::_tao_any_destructor (void *_tao_void_pointer)
{
  MyValueType *_tao_tmp_pointer =
    static_cast<MyValueType *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr MyValueType::_tao_type () const
{
  return ::_tc_MyValueType;
}

MyValueType::~MyValueType ()
{}

::CORBA::Boolean
MyValueType::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__MyValueType (strm, ci);
}

::CORBA::Boolean
MyValueType::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__MyValueType (strm,ci);
}

::CORBA::Boolean
MyValueType::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (MyValueType::_downcast);
}

::CORBA::Boolean
MyValueType::_tao_unmarshal (
    TAO_InputCDR &strm,
    MyValueType *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        MyValueType::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = MyValueType::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



MyValueType_init::MyValueType_init ()
{
}

MyValueType_init::~MyValueType_init ()
{
}

MyValueType_init *
MyValueType_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::MyValueType_init *> (v);
}

const char*
MyValueType_init::tao_repository_id ()
{
  return ::MyValueType::_tao_obv_static_repository_id ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/enum_typecode.cpp:27

static char const * const _tao_enumerators_ValueSort2[] =
  {
    "SYMBOL_TYPE2"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_ValueSort2 (
    "IDL:ValueSort2:1.0",
    "ValueSort2",
    _tao_enumerators_ValueSort2,
    1);
  
::CORBA::TypeCode_ptr const _tc_ValueSort2 =
  &_tao_tc_ValueSort2;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/union_cs.cpp:75



MyValueTypeUnion::MyValueTypeUnion ()
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = (ValueSort2) -1;
}

MyValueTypeUnion::MyValueTypeUnion (const ::MyValueTypeUnion &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case ::SYMBOL_TYPE2:
    {
      if (!u.u_.symbol_val_)
        {
          this->u_.symbol_val_ = nullptr;
        }
      else
        {
          typedef MyValueType_var OBJECT_FIELD;
          ::CORBA::add_ref (u.u_.symbol_val_->ptr ());
          ACE_NEW (
              this->u_.symbol_val_,
              OBJECT_FIELD (u.u_.symbol_val_->in ())
            );
        }
    }
    break;
    default:
    break;
  }
}

MyValueTypeUnion::~MyValueTypeUnion ()
{
  // Finalize.
  this->_reset ();
}

void MyValueTypeUnion::_tao_any_destructor (void *_tao_void_pointer)
{
  MyValueTypeUnion *tmp =
    static_cast<MyValueTypeUnion *> (_tao_void_pointer);
  delete tmp;
}

MyValueTypeUnion &
MyValueTypeUnion::operator= (const ::MyValueTypeUnion &u)
{
  if (std::addressof(u) == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case ::SYMBOL_TYPE2:
    {
      if (!u.u_.symbol_val_)
        {
          this->u_.symbol_val_ = nullptr;
        }
      else
        {
          typedef MyValueType_var OBJECT_FIELD;
          ::CORBA::add_ref (u.u_.symbol_val_->ptr ());
          ACE_NEW_RETURN (
              this->u_.symbol_val_,
              OBJECT_FIELD (u.u_.symbol_val_->in ()),
              *this);
        }
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void MyValueTypeUnion::_reset ()
{
  switch (this->disc_)
  {
    
    case ::SYMBOL_TYPE2:
      delete this->u_.symbol_val_;
      this->u_.symbol_val_ = nullptr;
      
    break;
    
    default:
    break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/union_typecode.cpp:63

static TAO::TypeCode::Case_T<ValueSort2, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_MyValueTypeUnion__0 (::SYMBOL_TYPE2, "symbol_val", &_tc_MyValueType);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_MyValueTypeUnion[] =
  {
    &_tao_cases_MyValueTypeUnion__0
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_MyValueTypeUnion (
    "IDL:MyValueTypeUnion:1.0",
    "MyValueTypeUnion",
    &_tc_ValueSort2,
    _tao_cases_MyValueTypeUnion,
    sizeof (_tao_cases_MyValueTypeUnion)/sizeof (_tao_cases_MyValueTypeUnion[0]),
    -1);
  
::CORBA::TypeCode_ptr const _tc_MyValueTypeUnion =
  &_tao_tc_MyValueTypeUnion;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:457


#ifndef _TAO_TYPECODE_RecValueType__tao_seq_RecValueType__GUARD
#define _TAO_TYPECODE_RecValueType__tao_seq_RecValueType__GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        RecValueType__tao_seq_RecValueType__0 (
          ::CORBA::tk_sequence,
          &_tc_RecValueType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_RecValueType__tao_seq_RecValueType__0 =
        &RecValueType__tao_seq_RecValueType__0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_RecValueType__tao_seq_RecValueType__GUARD */


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:457


#ifndef _TAO_TYPECODE_RecValueType__tao_seq_RecValueType__2_GUARD
#define _TAO_TYPECODE_RecValueType__tao_seq_RecValueType__2_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        RecValueType__tao_seq_RecValueType__2_2 (
          ::CORBA::tk_sequence,
          &_tc_RecValueType,
          2U);
        
      ::CORBA::TypeCode_ptr const tc_RecValueType__tao_seq_RecValueType__2_2 =
        &RecValueType__tao_seq_RecValueType__2_2;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_RecValueType__tao_seq_RecValueType__2_GUARD */

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_RecValueType[] =
  {
    { "rec_value_types", &TAO::TypeCode::tc_RecValueType__tao_seq_RecValueType__0, ::CORBA::PRIVATE_MEMBER },
    { "rec_value_types2", &TAO::TypeCode::tc_RecValueType__tao_seq_RecValueType__2_2, ::CORBA::PRIVATE_MEMBER }
    
  };
static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Value<char const *,
                       ::CORBA::TypeCode_ptr const *,
                       TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                       TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * >

  _tao_tc_RecValueType (
    ::CORBA::tk_value,
    "IDL:RecValueType:1.0",
    "RecValueType",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_RecValueType,
    2);
  
::CORBA::TypeCode_ptr const _tc_RecValueType =
  &_tao_tc_RecValueType;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<RecValueType>::add_ref (RecValueType * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<RecValueType>::remove_ref (RecValueType * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<RecValueType>::release (RecValueType * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



RecValueType *
RecValueType::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::RecValueType *> (v);
}

const char *
RecValueType::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
RecValueType::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
RecValueType::_tao_any_destructor (void *_tao_void_pointer)
{
  RecValueType *_tao_tmp_pointer =
    static_cast<RecValueType *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RecValueType::_tao_type () const
{
  return ::_tc_RecValueType;
}

RecValueType::~RecValueType ()
{}

::CORBA::Boolean
RecValueType::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__RecValueType (strm, ci);
}

::CORBA::Boolean
RecValueType::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__RecValueType (strm,ci);
}

::CORBA::Boolean
RecValueType::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (RecValueType::_downcast);
}

::CORBA::Boolean
RecValueType::_tao_unmarshal (
    TAO_InputCDR &strm,
    RecValueType *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        RecValueType::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = RecValueType::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



RecValueType_init::RecValueType_init ()
{
}

RecValueType_init::~RecValueType_init ()
{
}

RecValueType_init *
RecValueType_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::RecValueType_init *> (v);
}

const char*
RecValueType_init::tao_repository_id ()
{
  return ::RecValueType::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
RecValueType_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_RecValueType,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_GetsDeprecatedMember[] =
  {
    { "StringMember", &CORBA::_tc_string, ::CORBA::PUBLIC_MEMBER }
    
  };
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_GetsDeprecatedMember (
    ::CORBA::tk_value,
    "IDL:GetsDeprecatedMember:1.0",
    "GetsDeprecatedMember",
    ::CORBA::VM_NONE,
    &_tc_IncludedBase,
    _tao_fields_GetsDeprecatedMember,
    1);
  
::CORBA::TypeCode_ptr const _tc_GetsDeprecatedMember =
  &_tao_tc_GetsDeprecatedMember;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<GetsDeprecatedMember>::add_ref (GetsDeprecatedMember * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<GetsDeprecatedMember>::remove_ref (GetsDeprecatedMember * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<GetsDeprecatedMember>::release (GetsDeprecatedMember * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



GetsDeprecatedMember *
GetsDeprecatedMember::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::GetsDeprecatedMember *> (v);
}

const char *
GetsDeprecatedMember::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
GetsDeprecatedMember::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
GetsDeprecatedMember::_tao_any_destructor (void *_tao_void_pointer)
{
  GetsDeprecatedMember *_tao_tmp_pointer =
    static_cast<GetsDeprecatedMember *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr GetsDeprecatedMember::_tao_type () const
{
  return ::_tc_GetsDeprecatedMember;
}

GetsDeprecatedMember::~GetsDeprecatedMember ()
{}

::CORBA::Boolean
GetsDeprecatedMember::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__GetsDeprecatedMember (strm, ci);
}

::CORBA::Boolean
GetsDeprecatedMember::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__GetsDeprecatedMember (strm,ci);
}

::CORBA::Boolean
GetsDeprecatedMember::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (GetsDeprecatedMember::_downcast);
}

::CORBA::Boolean
GetsDeprecatedMember::_tao_unmarshal (
    TAO_InputCDR &strm,
    GetsDeprecatedMember *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        GetsDeprecatedMember::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = GetsDeprecatedMember::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



GetsDeprecatedMember_init::GetsDeprecatedMember_init ()
{
}

GetsDeprecatedMember_init::~GetsDeprecatedMember_init ()
{
}

GetsDeprecatedMember_init *
GetsDeprecatedMember_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::GetsDeprecatedMember_init *> (v);
}

const char*
GetsDeprecatedMember_init::tao_repository_id ()
{
  return ::GetsDeprecatedMember::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
GetsDeprecatedMember_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_GetsDeprecatedMember,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_X_AXXX = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_X_AXXX (
    ::CORBA::tk_value,
    "IDL:X/AXXX:1.0",
    "AXXX",
    ::CORBA::VM_ABSTRACT,
    &::CORBA::_tc_null,
    _tao_fields_X_AXXX,
    0);
  

namespace X
{
  ::CORBA::TypeCode_ptr const _tc_AXXX =
    &_tao_tc_X_AXXX;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<X::AXXX>::add_ref (X::AXXX * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<X::AXXX>::remove_ref (X::AXXX * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<X::AXXX>::release (X::AXXX * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



X::AXXX *
X::AXXX::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::X::AXXX *> (v);
}

const char *
X::AXXX::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
X::AXXX::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
X::AXXX::_tao_any_destructor (void *_tao_void_pointer)
{
  AXXX *_tao_tmp_pointer =
    static_cast<AXXX *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr X::AXXX::_tao_type () const
{
  return ::X::_tc_AXXX;
}

X::AXXX::~AXXX ()
{}

::CORBA::Boolean
X::AXXX::_tao_unmarshal (
    TAO_InputCDR &strm,
    AXXX *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AXXX::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AXXX::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_X_BXXX = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_X_BXXX (
    ::CORBA::tk_value,
    "IDL:X/BXXX:1.0",
    "BXXX",
    ::CORBA::VM_ABSTRACT,
    &::CORBA::_tc_null,
    _tao_fields_X_BXXX,
    0);
  

namespace X
{
  ::CORBA::TypeCode_ptr const _tc_BXXX =
    &_tao_tc_X_BXXX;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<X::BXXX>::add_ref (X::BXXX * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<X::BXXX>::remove_ref (X::BXXX * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<X::BXXX>::release (X::BXXX * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



X::BXXX *
X::BXXX::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::X::BXXX *> (v);
}

const char *
X::BXXX::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
X::BXXX::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
X::BXXX::_tao_any_destructor (void *_tao_void_pointer)
{
  BXXX *_tao_tmp_pointer =
    static_cast<BXXX *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr X::BXXX::_tao_type () const
{
  return ::X::_tc_BXXX;
}

X::BXXX::~BXXX ()
{}

::CORBA::Boolean
X::BXXX::_tao_unmarshal (
    TAO_InputCDR &strm,
    BXXX *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        BXXX::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = BXXX::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/sequence_cs.cpp:104



#if !defined (_X_BSEQ_CS_)
#define _X_BSEQ_CS_

X::BSeq::BSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_valuetype_sequence<
        BXXX,
        BXXX_var
      > (max)
{}

X::BSeq::BSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    X::BXXX * * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_valuetype_sequence<
        BXXX,
        BXXX_var
      >
    (max, length, buffer, release)
{}

void X::BSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  BSeq * _tao_tmp_pointer =
    static_cast<BSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:457


#ifndef _TAO_TYPECODE_X_BSeq_GUARD
#define _TAO_TYPECODE_X_BSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        X_BSeq_0 (
          ::CORBA::tk_sequence,
          &X::_tc_BXXX,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_X_BSeq_0 =
        &X_BSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_X_BSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_X_BSeq (
    ::CORBA::tk_alias,
    "IDL:X/BSeq:1.0",
    "BSeq",
    &TAO::TypeCode::tc_X_BSeq_0);
  

namespace X
{
  ::CORBA::TypeCode_ptr const _tc_BSeq =
    &_tao_tc_X_BSeq;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_ModSelection_SelectionDefns_Criterion = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_ModSelection_SelectionDefns_Criterion (
    ::CORBA::tk_value,
    "IDL:ModSelection/SelectionDefns/Criterion:1.0",
    "Criterion",
    ::CORBA::VM_ABSTRACT,
    &::CORBA::_tc_null,
    _tao_fields_ModSelection_SelectionDefns_Criterion,
    0);
  

namespace ModSelection
{
  
  namespace SelectionDefns
  {
    ::CORBA::TypeCode_ptr const _tc_Criterion =
      &_tao_tc_ModSelection_SelectionDefns_Criterion;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<ModSelection::SelectionDefns::Criterion>::add_ref (ModSelection::SelectionDefns::Criterion * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<ModSelection::SelectionDefns::Criterion>::remove_ref (ModSelection::SelectionDefns::Criterion * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<ModSelection::SelectionDefns::Criterion>::release (ModSelection::SelectionDefns::Criterion * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



ModSelection::SelectionDefns::Criterion *
ModSelection::SelectionDefns::Criterion::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::ModSelection::SelectionDefns::Criterion *> (v);
}

const char *
ModSelection::SelectionDefns::Criterion::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
ModSelection::SelectionDefns::Criterion::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
ModSelection::SelectionDefns::Criterion::_tao_any_destructor (void *_tao_void_pointer)
{
  Criterion *_tao_tmp_pointer =
    static_cast<Criterion *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr ModSelection::SelectionDefns::Criterion::_tao_type () const
{
  return ::ModSelection::SelectionDefns::_tc_Criterion;
}

ModSelection::SelectionDefns::Criterion::~Criterion ()
{}

::CORBA::Boolean
ModSelection::SelectionDefns::Criterion::_tao_unmarshal (
    TAO_InputCDR &strm,
    Criterion *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        Criterion::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = Criterion::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_ModSelection_SelectionDefns_CriterionExpr[] =
  {
    { "theLeftCriterion", &ModSelection::SelectionDefns::_tc_Criterion, ::CORBA::PUBLIC_MEMBER },
    { "theRightCriterionExpr", &ModSelection::SelectionDefns::CriterionExpr::_tc_RightCriterionExpr, ::CORBA::PUBLIC_MEMBER }
    
  };
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_ModSelection_SelectionDefns_CriterionExpr (
    ::CORBA::tk_value,
    "IDL:ModSelection/SelectionDefns/CriterionExpr:1.0",
    "CriterionExpr",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_ModSelection_SelectionDefns_CriterionExpr,
    2);
  

namespace ModSelection
{
  
  namespace SelectionDefns
  {
    ::CORBA::TypeCode_ptr const _tc_CriterionExpr =
      &_tao_tc_ModSelection_SelectionDefns_CriterionExpr;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<ModSelection::SelectionDefns::CriterionExpr>::add_ref (ModSelection::SelectionDefns::CriterionExpr * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<ModSelection::SelectionDefns::CriterionExpr>::remove_ref (ModSelection::SelectionDefns::CriterionExpr * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<ModSelection::SelectionDefns::CriterionExpr>::release (ModSelection::SelectionDefns::CriterionExpr * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



ModSelection::SelectionDefns::CriterionExpr *
ModSelection::SelectionDefns::CriterionExpr::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::ModSelection::SelectionDefns::CriterionExpr *> (v);
}

const char *
ModSelection::SelectionDefns::CriterionExpr::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
ModSelection::SelectionDefns::CriterionExpr::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
ModSelection::SelectionDefns::CriterionExpr::_tao_any_destructor (void *_tao_void_pointer)
{
  CriterionExpr *_tao_tmp_pointer =
    static_cast<CriterionExpr *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr ModSelection::SelectionDefns::CriterionExpr::_tao_type () const
{
  return ::ModSelection::SelectionDefns::_tc_CriterionExpr;
}

ModSelection::SelectionDefns::CriterionExpr::~CriterionExpr ()
{}

::CORBA::Boolean
ModSelection::SelectionDefns::CriterionExpr::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__ModSelection_SelectionDefns_CriterionExpr (strm, ci);
}

::CORBA::Boolean
ModSelection::SelectionDefns::CriterionExpr::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__ModSelection_SelectionDefns_CriterionExpr (strm,ci);
}

::CORBA::Boolean
ModSelection::SelectionDefns::CriterionExpr::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (ModSelection::SelectionDefns::CriterionExpr::_downcast);
}

::CORBA::Boolean
ModSelection::SelectionDefns::CriterionExpr::_tao_unmarshal (
    TAO_InputCDR &strm,
    CriterionExpr *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        CriterionExpr::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = CriterionExpr::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_ModSelection_SelectionDefns_CriterionExpr_RightCriterionInfos[] =
      {
        { "theCriterionId", &CORBA::_tc_long },
        { "theRightExpr", &ModSelection::SelectionDefns::_tc_CriterionExpr }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_ModSelection_SelectionDefns_CriterionExpr_RightCriterionInfos (
  ::CORBA::tk_struct,
  "IDL:ModSelection/SelectionDefns/CriterionExpr/RightCriterionInfos:1.0",
  "RightCriterionInfos",
  _tao_fields_ModSelection_SelectionDefns_CriterionExpr_RightCriterionInfos,
  2);

::CORBA::TypeCode_ptr const ModSelection::SelectionDefns::CriterionExpr::_tc_RightCriterionInfos =
  &_tao_tc_ModSelection_SelectionDefns_CriterionExpr_RightCriterionInfos;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
ModSelection::SelectionDefns::CriterionExpr::RightCriterionInfos::_tao_any_destructor (
    void *_tao_void_pointer)
{
  RightCriterionInfos *_tao_tmp_pointer =
    static_cast<RightCriterionInfos *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/union_cs.cpp:75



ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr::RightCriterionExpr ()
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = false;
}

ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr::RightCriterionExpr (const ::ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr &u)
{
  this->disc_ = u.disc_;
  
  if (this->disc_)
    {
      this->u_.theRightCriterionInfos_ = ::CORBA::string_dup (u.u_.theRightCriterionInfos_);
    }
  
}

ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr::~RightCriterionExpr ()
{
  // Finalize.
  this->_reset ();
}

void ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr::_tao_any_destructor (void *_tao_void_pointer)
{
  RightCriterionExpr *tmp =
    static_cast<RightCriterionExpr *> (_tao_void_pointer);
  delete tmp;
}

ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr &
ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr::operator= (const ::ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr &u)
{
  if (std::addressof(u) == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  
  if (this->disc_)
    {
      this->u_.theRightCriterionInfos_ = ::CORBA::string_dup (u.u_.theRightCriterionInfos_);
    }
  
  return *this;
}

/// Reset method to reset old values of a union.
void ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr::_reset ()
{
  
  if (this->disc_)
    {
      ::CORBA::string_free (this->u_.theRightCriterionInfos_);
      this->u_.theRightCriterionInfos_ = nullptr;
      
    }
  
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/union_typecode.cpp:63

static TAO::TypeCode::Case_T<CORBA::Boolean, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_ModSelection_SelectionDefns_CriterionExpr_RightCriterionExpr__0 (true, "theRightCriterionInfos", &CORBA::_tc_string);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_ModSelection_SelectionDefns_CriterionExpr_RightCriterionExpr[] =
  {
    &_tao_cases_ModSelection_SelectionDefns_CriterionExpr_RightCriterionExpr__0
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_ModSelection_SelectionDefns_CriterionExpr_RightCriterionExpr (
    "IDL:ModSelection/SelectionDefns/CriterionExpr/RightCriterionExpr:1.0",
    "RightCriterionExpr",
    &CORBA::_tc_boolean,
    _tao_cases_ModSelection_SelectionDefns_CriterionExpr_RightCriterionExpr,
    sizeof (_tao_cases_ModSelection_SelectionDefns_CriterionExpr_RightCriterionExpr)/sizeof (_tao_cases_ModSelection_SelectionDefns_CriterionExpr_RightCriterionExpr[0]),
    -1);
  
::CORBA::TypeCode_ptr const ModSelection::SelectionDefns::CriterionExpr::_tc_RightCriterionExpr =
  &_tao_tc_ModSelection_SelectionDefns_CriterionExpr_RightCriterionExpr;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



ModSelection::SelectionDefns::CriterionExpr_init::CriterionExpr_init ()
{
}

ModSelection::SelectionDefns::CriterionExpr_init::~CriterionExpr_init ()
{
}

ModSelection::SelectionDefns::CriterionExpr_init *
ModSelection::SelectionDefns::CriterionExpr_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::ModSelection::SelectionDefns::CriterionExpr_init *> (v);
}

const char*
ModSelection::SelectionDefns::CriterionExpr_init::tao_repository_id ()
{
  return ::ModSelection::SelectionDefns::CriterionExpr::_tao_obv_static_repository_id ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_MyValueType::OBV_MyValueType (
    const char * _tao_init_my_string_value)
{
  my_string_value (_tao_init_my_string_value);
}

OBV_MyValueType::~OBV_MyValueType ()
{}

::CORBA::Boolean
OBV_MyValueType::_tao_marshal__MyValueType (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_MyValueType::_tao_unmarshal__MyValueType (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:825

/// Accessor to set the member.
void
OBV_MyValueType::my_string_value (char *val)
{
  this->_pd_my_string_value = (val);
}

/// Accessor to set the member.
void
OBV_MyValueType::my_string_value (const char *val)
{
  // Set the value.
  this->_pd_my_string_value = ::CORBA::string_dup (val);
}

/// Accessor to set the member.
void
OBV_MyValueType::my_string_value (const ::CORBA::String_var &val)
{
  ::CORBA::String_var my_string_value_var = val;
  this->_pd_my_string_value = my_string_value_var._retn ();
}

const char *
OBV_MyValueType::my_string_value () const // get method
{
  return this->_pd_my_string_value;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_RecValueType::OBV_RecValueType (
    const ::RecValueType::_tao_seq_RecValueType_ & _tao_init_rec_value_types,
    const ::RecValueType::_tao_seq_RecValueType__2 & _tao_init_rec_value_types2)
{
  rec_value_types (_tao_init_rec_value_types);
  rec_value_types2 (_tao_init_rec_value_types2);
}

OBV_RecValueType::~OBV_RecValueType ()
{}

::CORBA::ValueBase *
OBV_RecValueType::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_RecValueType (
      rec_value_types (),
      rec_value_types2 ()
    ),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_RecValueType::_tao_marshal__RecValueType (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_RecValueType::_tao_unmarshal__RecValueType (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/sequence_cs.cpp:104



#if !defined (_RECVALUETYPE__TAO_SEQ_RECVALUETYPE__CS_)
#define _RECVALUETYPE__TAO_SEQ_RECVALUETYPE__CS_

RecValueType::_tao_seq_RecValueType_::_tao_seq_RecValueType_ (
    ::CORBA::ULong max)
  : ::TAO::unbounded_valuetype_sequence<
        RecValueType,
        RecValueType_var
      > (max)
{}

RecValueType::_tao_seq_RecValueType_::_tao_seq_RecValueType_ (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    RecValueType * * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_valuetype_sequence<
        RecValueType,
        RecValueType_var
      >
    (max, length, buffer, release)
{}

#endif /* end #if !defined */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:754

/// Accessor to set the member.
void
OBV_RecValueType::rec_value_types (const RecValueType::_tao_seq_RecValueType_ &val)
{
  this->_pd_rec_value_types = val;
}

/// Readonly get method.
const RecValueType::_tao_seq_RecValueType_ &
OBV_RecValueType::rec_value_types () const
{
  return this->_pd_rec_value_types;
}

/// Read/write get method.
RecValueType::_tao_seq_RecValueType_ &
OBV_RecValueType::rec_value_types ()
{
  return this->_pd_rec_value_types;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/sequence_cs.cpp:104



#if !defined (_RECVALUETYPE__TAO_SEQ_RECVALUETYPE__2_CS_)
#define _RECVALUETYPE__TAO_SEQ_RECVALUETYPE__2_CS_

RecValueType::_tao_seq_RecValueType__2::_tao_seq_RecValueType__2 (
    ::CORBA::ULong length,
    RecValueType * * buffer,
    ::CORBA::Boolean release)
  : ::TAO::bounded_valuetype_sequence<
        RecValueType,
        RecValueType_var,
        2
      >
    (length, buffer, release)
{}

#endif /* end #if !defined */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:754

/// Accessor to set the member.
void
OBV_RecValueType::rec_value_types2 (const RecValueType::_tao_seq_RecValueType__2 &val)
{
  this->_pd_rec_value_types2 = val;
}

/// Readonly get method.
const RecValueType::_tao_seq_RecValueType__2 &
OBV_RecValueType::rec_value_types2 () const
{
  return this->_pd_rec_value_types2;
}

/// Read/write get method.
RecValueType::_tao_seq_RecValueType__2 &
OBV_RecValueType::rec_value_types2 ()
{
  return this->_pd_rec_value_types2;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_GetsDeprecatedMember::OBV_GetsDeprecatedMember (
    const ::IncludedBase::_tao_seq_CORBA_Long_ & _tao_init_DeprecatedMember,
    const char * _tao_init_StringMember)
{
  DeprecatedMember (_tao_init_DeprecatedMember);
  StringMember (_tao_init_StringMember);
}

OBV_GetsDeprecatedMember::~OBV_GetsDeprecatedMember ()
{}

::CORBA::Boolean
OBV_GetsDeprecatedMember::_tao_marshal__GetsDeprecatedMember (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_GetsDeprecatedMember::_tao_unmarshal__GetsDeprecatedMember (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:825

/// Accessor to set the member.
void
OBV_GetsDeprecatedMember::StringMember (char *val)
{
  this->_pd_StringMember = (val);
}

/// Accessor to set the member.
void
OBV_GetsDeprecatedMember::StringMember (const char *val)
{
  // Set the value.
  this->_pd_StringMember = ::CORBA::string_dup (val);
}

/// Accessor to set the member.
void
OBV_GetsDeprecatedMember::StringMember (const ::CORBA::String_var &val)
{
  ::CORBA::String_var StringMember_var = val;
  this->_pd_StringMember = StringMember_var._retn ();
}

const char *
OBV_GetsDeprecatedMember::StringMember () const // get method
{
  return this->_pd_StringMember;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_ModSelection::SelectionDefns::CriterionExpr::CriterionExpr (
    ::ModSelection::SelectionDefns::Criterion * _tao_init_theLeftCriterion,
    const ::ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr & _tao_init_theRightCriterionExpr)
{
  theLeftCriterion (_tao_init_theLeftCriterion);
  theRightCriterionExpr (_tao_init_theRightCriterionExpr);
}

OBV_ModSelection::SelectionDefns::CriterionExpr::~CriterionExpr ()
{}

::CORBA::Boolean
OBV_ModSelection::SelectionDefns::CriterionExpr::_tao_marshal__ModSelection_SelectionDefns_CriterionExpr (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_ModSelection::SelectionDefns::CriterionExpr::_tao_unmarshal__ModSelection_SelectionDefns_CriterionExpr (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:425

/// Accessor to set the member.
void
OBV_ModSelection::SelectionDefns::CriterionExpr::theLeftCriterion (ModSelection::SelectionDefns::Criterion* val)
{
  ::CORBA::add_ref (val);
  this->_pd_theLeftCriterion = val;
}

/// Retrieve the member
ModSelection::SelectionDefns::Criterion *
OBV_ModSelection::SelectionDefns::CriterionExpr::theLeftCriterion () const
{
  return this->_pd_theLeftCriterion.in ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:1109

/// Accessor to set the member
void
OBV_ModSelection::SelectionDefns::CriterionExpr::theRightCriterionExpr (const ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr &val)
{
  this->_pd_theRightCriterionExpr = val;
}
/// Readonly get method.
const ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr &
OBV_ModSelection::SelectionDefns::CriterionExpr::theRightCriterionExpr () const
{
  return this->_pd_theRightCriterionExpr;
}
/// Read/write get method.
ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr &
OBV_ModSelection::SelectionDefns::CriterionExpr::theRightCriterionExpr ()
{
  return this->_pd_theRightCriterionExpr;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<MyValueType>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  MyValueType *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    MyValueType *_tao_copy =
      _tao_elem ?
        MyValueType::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  MyValueType **_tao_elem)
{
  TAO::Any_Impl_T<MyValueType>::insert (
    _tao_any,
    MyValueType::_tao_any_destructor,
    _tc_MyValueType,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    MyValueType *&_tao_elem)
{
  return
    TAO::Any_Impl_T<MyValueType>::extract (
        _tao_any,
        MyValueType::_tao_any_destructor,
        _tc_MyValueType,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_enum/any_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

void operator<<= (
    ::CORBA::Any &_tao_any,
    ValueSort2 _tao_elem)
{
  TAO::Any_Basic_Impl_T<ValueSort2>::insert (
      _tao_any,
      _tc_ValueSort2,
      _tao_elem);
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ValueSort2 &_tao_elem)
{
  return
    TAO::Any_Basic_Impl_T<ValueSort2>::extract (
        _tao_any,
        _tc_ValueSort2,
        _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/any_op_cs.cpp:35


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const MyValueTypeUnion &_tao_elem)
{
  TAO::Any_Dual_Impl_T<MyValueTypeUnion>::insert_copy (
    _tao_any,
    MyValueTypeUnion::_tao_any_destructor,
    _tc_MyValueTypeUnion,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  MyValueTypeUnion *_tao_elem)
{
  TAO::Any_Dual_Impl_T<MyValueTypeUnion>::insert (
    _tao_any,
    MyValueTypeUnion::_tao_any_destructor,
    _tc_MyValueTypeUnion,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const MyValueTypeUnion *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<MyValueTypeUnion>::extract (
    _tao_any,
    MyValueTypeUnion::_tao_any_destructor,
    _tc_MyValueTypeUnion,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<RecValueType>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  RecValueType *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    RecValueType *_tao_copy =
      _tao_elem ?
        RecValueType::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  RecValueType **_tao_elem)
{
  TAO::Any_Impl_T<RecValueType>::insert (
    _tao_any,
    RecValueType::_tao_any_destructor,
    _tc_RecValueType,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    RecValueType *&_tao_elem)
{
  return
    TAO::Any_Impl_T<RecValueType>::extract (
        _tao_any,
        RecValueType::_tao_any_destructor,
        _tc_RecValueType,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<GetsDeprecatedMember>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  GetsDeprecatedMember *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    GetsDeprecatedMember *_tao_copy =
      _tao_elem ?
        GetsDeprecatedMember::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  GetsDeprecatedMember **_tao_elem)
{
  TAO::Any_Impl_T<GetsDeprecatedMember>::insert (
    _tao_any,
    GetsDeprecatedMember::_tao_any_destructor,
    _tc_GetsDeprecatedMember,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    GetsDeprecatedMember *&_tao_elem)
{
  return
    TAO::Any_Impl_T<GetsDeprecatedMember>::extract (
        _tao_any,
        GetsDeprecatedMember::_tao_any_destructor,
        _tc_GetsDeprecatedMember,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<X::AXXX>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::AXXX *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    X::AXXX *_tao_copy =
      _tao_elem ?
        X::AXXX::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::AXXX **_tao_elem)
{
  TAO::Any_Impl_T<X::AXXX>::insert (
    _tao_any,
    X::AXXX::_tao_any_destructor,
    X::_tc_AXXX,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    X::AXXX *&_tao_elem)
{
  return
    TAO::Any_Impl_T<X::AXXX>::extract (
        _tao_any,
        X::AXXX::_tao_any_destructor,
        X::_tc_AXXX,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<X::BXXX>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::BXXX *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    X::BXXX *_tao_copy =
      _tao_elem ?
        X::BXXX::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::BXXX **_tao_elem)
{
  TAO::Any_Impl_T<X::BXXX>::insert (
    _tao_any,
    X::BXXX::_tao_any_destructor,
    X::_tc_BXXX,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    X::BXXX *&_tao_elem)
{
  return
    TAO::Any_Impl_T<X::BXXX>::extract (
        _tao_any,
        X::BXXX::_tao_any_destructor,
        X::_tc_BXXX,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/any_op_cs.cpp:43


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {


/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::X::BSeq &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::X::BSeq>::insert_copy (
    _tao_any,
    ::X::BSeq::_tao_any_destructor,
    ::X::_tc_BSeq,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::X::BSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::X::BSeq>::insert (
    _tao_any,
    ::X::BSeq::_tao_any_destructor,
    ::X::_tc_BSeq,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::X::BSeq *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::X::BSeq>::extract (
    _tao_any,
    ::X::BSeq::_tao_any_destructor,
    ::X::_tc_BSeq,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<ModSelection::SelectionDefns::Criterion>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ModSelection::SelectionDefns::Criterion *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    ModSelection::SelectionDefns::Criterion *_tao_copy =
      _tao_elem ?
        ModSelection::SelectionDefns::Criterion::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ModSelection::SelectionDefns::Criterion **_tao_elem)
{
  TAO::Any_Impl_T<ModSelection::SelectionDefns::Criterion>::insert (
    _tao_any,
    ModSelection::SelectionDefns::Criterion::_tao_any_destructor,
    ModSelection::SelectionDefns::_tc_Criterion,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    ModSelection::SelectionDefns::Criterion *&_tao_elem)
{
  return
    TAO::Any_Impl_T<ModSelection::SelectionDefns::Criterion>::extract (
        _tao_any,
        ModSelection::SelectionDefns::Criterion::_tao_any_destructor,
        ModSelection::SelectionDefns::_tc_Criterion,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<ModSelection::SelectionDefns::CriterionExpr>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ModSelection::SelectionDefns::CriterionExpr *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    ModSelection::SelectionDefns::CriterionExpr *_tao_copy =
      _tao_elem ?
        ModSelection::SelectionDefns::CriterionExpr::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ModSelection::SelectionDefns::CriterionExpr **_tao_elem)
{
  TAO::Any_Impl_T<ModSelection::SelectionDefns::CriterionExpr>::insert (
    _tao_any,
    ModSelection::SelectionDefns::CriterionExpr::_tao_any_destructor,
    ModSelection::SelectionDefns::_tc_CriterionExpr,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    ModSelection::SelectionDefns::CriterionExpr *&_tao_elem)
{
  return
    TAO::Any_Impl_T<ModSelection::SelectionDefns::CriterionExpr>::extract (
        _tao_any,
        ModSelection::SelectionDefns::CriterionExpr::_tao_any_destructor,
        ModSelection::SelectionDefns::_tc_CriterionExpr,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (MyValueType * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (MyValueType * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const MyValueType *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&MyValueType::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    MyValueType *&_tao_valuetype)
{
  return MyValueType::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_MyValueType::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo &ci) const
{
  if (! ci.start_chunk (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm << _pd_my_string_value.in ());
  if ( ! ret) 
    return false; 
  
  if (! ci.end_chunk (strm))
    return false;
  
  return true;
}

::CORBA::Boolean
OBV_MyValueType::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo &ci)
{
  if (!ci.handle_chunking (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm >> _pd_my_string_value.out ());
  if (!ret) 
    return false; 
  
  if (this->require_truncation_)
    return ci.skip_chunks (strm);
  
  else
    return ci.handle_chunking (strm);
  
  
}

void
OBV_MyValueType::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_enum/cdr_op_cs.cpp:29


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, ValueSort2 _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, ValueSort2 & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<ValueSort2> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/cdr_op_cs.cpp:119


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const MyValueTypeUnion &_tao_union)
{
  if (!(strm << _tao_union._d ()))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case ::SYMBOL_TYPE2:
      {
        result = strm << _tao_union.symbol_val ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    MyValueTypeUnion &_tao_union)
{
  ValueSort2 _tao_discriminant;
  if (!(strm >> _tao_discriminant))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case ::SYMBOL_TYPE2:
      {
        MyValueType_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.inout ();
        if (result)
          {
            _tao_union.symbol_val (_tao_union_tmp.in ());
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (RecValueType * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (RecValueType * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/cdr_op_cs.cpp:92

#if !defined _TAO_CDR_OP_RecValueType__tao_seq_RecValueType__CPP_
#define _TAO_CDR_OP_RecValueType__tao_seq_RecValueType__CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RecValueType::_tao_seq_RecValueType_ &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RecValueType::_tao_seq_RecValueType_ &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_RecValueType__tao_seq_RecValueType__CPP_ */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/cdr_op_cs.cpp:92

#if !defined _TAO_CDR_OP_RecValueType__tao_seq_RecValueType__2_CPP_
#define _TAO_CDR_OP_RecValueType__tao_seq_RecValueType__2_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RecValueType::_tao_seq_RecValueType__2 &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RecValueType::_tao_seq_RecValueType__2 &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_RecValueType__tao_seq_RecValueType__2_CPP_ */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const RecValueType *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&RecValueType::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    RecValueType *&_tao_valuetype)
{
  return RecValueType::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_RecValueType::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo &ci) const
{
  if (! ci.start_chunk (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm << _pd_rec_value_types) &&
      (strm << _pd_rec_value_types2);
  if ( ! ret) 
    return false; 
  
  if (! ci.end_chunk (strm))
    return false;
  
  return true;
}

::CORBA::Boolean
OBV_RecValueType::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo &ci)
{
  if (!ci.handle_chunking (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm >> _pd_rec_value_types) &&
      (strm >> _pd_rec_value_types2);
  if (!ret) 
    return false; 
  
  if (this->require_truncation_)
    return ci.skip_chunks (strm);
  
  else
    return ci.handle_chunking (strm);
  
  
}

void
OBV_RecValueType::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (GetsDeprecatedMember * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (GetsDeprecatedMember * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const GetsDeprecatedMember *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&GetsDeprecatedMember::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    GetsDeprecatedMember *&_tao_valuetype)
{
  return GetsDeprecatedMember::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_GetsDeprecatedMember::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo &ci) const
{
  if (! ci.start_chunk (strm))
    return false;
  
  if (! this->_tao_marshal__IncludedBase (strm, ci))
    {
      return false;
    }
  
  if (! ci.start_chunk (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm << _pd_StringMember.in ());
  if ( ! ret) 
    return false; 
  
  if (! ci.end_chunk (strm))
    return false;
  
  if (! ci.end_chunk (strm))
    return false;
  
  return true;
}

::CORBA::Boolean
OBV_GetsDeprecatedMember::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo &ci)
{
  if (!ci.handle_chunking (strm))
    return false;
  
  if (!this->_tao_unmarshal__IncludedBase (strm, ci))
    {
      return false;
    }
  
  if (!ci.handle_chunking (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm >> _pd_StringMember.out ());
  if (!ret) 
    return false; 
  
  if (this->require_truncation_)
    return ci.skip_chunks (strm);
  
  else
    return ci.handle_chunking (strm);
  
  
}

void
OBV_GetsDeprecatedMember::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (X::AXXX * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (X::AXXX * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const X::AXXX *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&X::AXXX::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    X::AXXX *&_tao_valuetype)
{
  return X::AXXX::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (X::BXXX * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (X::BXXX * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const X::BXXX *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&X::BXXX::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    X::BXXX *&_tao_valuetype)
{
  return X::BXXX::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/cdr_op_cs.cpp:92

#if !defined _TAO_CDR_OP_X_BSeq_CPP_
#define _TAO_CDR_OP_X_BSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const X::BSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    X::BSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_X_BSeq_CPP_ */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (ModSelection::SelectionDefns::Criterion * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (ModSelection::SelectionDefns::Criterion * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const ModSelection::SelectionDefns::Criterion *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&ModSelection::SelectionDefns::Criterion::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    ModSelection::SelectionDefns::Criterion *&_tao_valuetype)
{
  return ModSelection::SelectionDefns::Criterion::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (ModSelection::SelectionDefns::CriterionExpr * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (ModSelection::SelectionDefns::CriterionExpr * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ModSelection::SelectionDefns::CriterionExpr::RightCriterionInfos &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.theCriterionId) &&
    (strm << _tao_aggregate.theRightExpr.in ()) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ModSelection::SelectionDefns::CriterionExpr::RightCriterionInfos &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.theCriterionId) &&
    (strm >> _tao_aggregate.theRightExpr.out ()) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/cdr_op_cs.cpp:119


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr &_tao_union)
{
  ::ACE_OutputCDR::from_boolean tmp (_tao_union._d ());
  if (!(strm << tmp))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  if (_tao_union._d ())
    {
      result = strm << _tao_union.theRightCriterionInfos ();
    }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ModSelection::SelectionDefns::CriterionExpr::RightCriterionExpr &_tao_union)
{
  CORBA::Boolean _tao_discriminant;
  ::ACE_InputCDR::to_boolean tmp (_tao_discriminant);
  if (!(strm >> tmp))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  _tao_union._default ();
  _tao_union._d (_tao_discriminant);
  if (_tao_discriminant)
    {
      ::CORBA::String_var _tao_union_tmp;
      result = strm >> _tao_union_tmp.out ();
      if (result)
        {
          _tao_union.theRightCriterionInfos (_tao_union_tmp);
          _tao_union._d (_tao_discriminant);
        }
    }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const ModSelection::SelectionDefns::CriterionExpr *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&ModSelection::SelectionDefns::CriterionExpr::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    ModSelection::SelectionDefns::CriterionExpr *&_tao_valuetype)
{
  return ModSelection::SelectionDefns::CriterionExpr::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_ModSelection::SelectionDefns::CriterionExpr::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo &ci) const
{
  if (! ci.start_chunk (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm << _pd_theLeftCriterion.in ()) &&
      (strm << _pd_theRightCriterionExpr);
  if ( ! ret) 
    return false; 
  
  if (! ci.end_chunk (strm))
    return false;
  
  return true;
}

::CORBA::Boolean
OBV_ModSelection::SelectionDefns::CriterionExpr::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo &ci)
{
  if (!ci.handle_chunking (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm >> _pd_theLeftCriterion.out ()) &&
      (strm >> _pd_theRightCriterionExpr);
  if (!ret) 
    return false; 
  
  if (this->require_truncation_)
    return ci.skip_chunks (strm);
  
  else
    return ci.handle_chunking (strm);
  
  
}

void
OBV_ModSelection::SelectionDefns::CriterionExpr::truncation_hook ()
{
  this->require_truncation_ = true;
}



