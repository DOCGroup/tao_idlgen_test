// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v4.0.2
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       https://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     https://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_codegen.cpp:372


#include "TestVersionedNamespace2C.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "cstring"
#include "memory"

#if !defined (__ACE_INLINE__)
#include "TestVersionedNamespace2C.inl"
#endif /* !defined INLINE */

BEGIN_USER_VERSIONED_NAMESPACE


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_M1_S1[] =
      {
        { "o", &CORBA::_tc_octet }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_M1_S1 (
  ::CORBA::tk_struct,
  "IDL:M1/S1:1.0",
  "S1",
  _tao_fields_M1_S1,
  1);


namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_S1 =
    &_tao_tc_M1_S1;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
M1::S1::_tao_any_destructor (
    void *_tao_void_pointer)
{
  S1 *_tao_tmp_pointer =
    static_cast<S1 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M1::LI.

M1::LI_ptr
TAO::Objref_Traits<M1::LI>::duplicate (M1::LI_ptr p)
{
  return M1::LI::_duplicate (p);
}

void
TAO::Objref_Traits<M1::LI>::release (M1::LI_ptr p)
{
  ::CORBA::release (p);
}

M1::LI_ptr
TAO::Objref_Traits<M1::LI>::nil ()
{
  return M1::LI::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M1::LI>::marshal (const M1::LI_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
M1::LI::op (
  const ::M1::S1 & s)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::M1::S1>::in_arg_val _tao_s (s);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_s)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

M1::LI::LI ()
{
}
void
M1::LI::_tao_any_destructor (void *_tao_void_pointer)
{
  LI *_tao_tmp_pointer =
    static_cast<LI *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M1::LI_ptr
M1::LI::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<LI>::narrow (_tao_objref, "IDL:M1/LI:1.0");
}

M1::LI_ptr
M1::LI::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<LI>::unchecked_narrow (_tao_objref);
}

M1::LI_ptr
M1::LI::_nil ()
{
  return nullptr;
}

M1::LI_ptr
M1::LI::_duplicate (LI_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M1::LI::_tao_release (LI_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M1::LI::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M1/LI:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* M1::LI::_interface_repository_id () const
{
  return "IDL:M1/LI:1.0";
}

::CORBA::Boolean
M1::LI::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M1_LI (
    ::CORBA::tk_objref,
    "IDL:M1/LI:1.0",
    "LI");
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_LI =
    &_tao_tc_M1_LI;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_M1_AMH_LIExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_M1_AMH_LIExceptionHolder (
    ::CORBA::tk_value,
    "IDL:M1/AMH_LIExceptionHolder:1.0",
    "AMH_LIExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_M1_AMH_LIExceptionHolder,
    0);
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_AMH_LIExceptionHolder =
    &_tao_tc_M1_AMH_LIExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<M1::AMH_LIExceptionHolder>::add_ref (M1::AMH_LIExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<M1::AMH_LIExceptionHolder>::remove_ref (M1::AMH_LIExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<M1::AMH_LIExceptionHolder>::release (M1::AMH_LIExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M1::AMH_LIExceptionHolder *
M1::AMH_LIExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::M1::AMH_LIExceptionHolder *> (v);
}

const char *
M1::AMH_LIExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
M1::AMH_LIExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
M1::AMH_LIExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_LIExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_LIExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr M1::AMH_LIExceptionHolder::_tao_type () const
{
  return ::M1::_tc_AMH_LIExceptionHolder;
}

M1::AMH_LIExceptionHolder::~AMH_LIExceptionHolder ()
{}

::CORBA::ValueBase *
M1::AMH_LIExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_LIExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
M1::AMH_LIExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
M1::AMH_LIExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
M1::AMH_LIExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
M1::AMH_LIExceptionHolder::_tao_marshal__M1_AMH_LIExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
M1::AMH_LIExceptionHolder::_tao_unmarshal__M1_AMH_LIExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
M1::AMH_LIExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_LIExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_LIExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_LIExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
M1::AMH_LIExceptionHolder::raise_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M1::AMH_LIResponseHandler.

M1::AMH_LIResponseHandler_ptr
TAO::Objref_Traits<M1::AMH_LIResponseHandler>::duplicate (M1::AMH_LIResponseHandler_ptr p)
{
  return M1::AMH_LIResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<M1::AMH_LIResponseHandler>::release (M1::AMH_LIResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

M1::AMH_LIResponseHandler_ptr
TAO::Objref_Traits<M1::AMH_LIResponseHandler>::nil ()
{
  return M1::AMH_LIResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M1::AMH_LIResponseHandler>::marshal (const M1::AMH_LIResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M1::AMH_LIResponseHandler::AMH_LIResponseHandler ()
{}void
M1::AMH_LIResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_LIResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_LIResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M1::AMH_LIResponseHandler_ptr
M1::AMH_LIResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_LIResponseHandler::_duplicate (
      dynamic_cast<AMH_LIResponseHandler_ptr> (_tao_objref));
}

M1::AMH_LIResponseHandler_ptr
M1::AMH_LIResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_LIResponseHandler::_duplicate (
      dynamic_cast<AMH_LIResponseHandler_ptr> (_tao_objref));
}

M1::AMH_LIResponseHandler_ptr
M1::AMH_LIResponseHandler::_nil ()
{
  return nullptr;
}

M1::AMH_LIResponseHandler_ptr
M1::AMH_LIResponseHandler::_duplicate (AMH_LIResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M1::AMH_LIResponseHandler::_tao_release (AMH_LIResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M1::AMH_LIResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M1/AMH_LIResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* M1::AMH_LIResponseHandler::_interface_repository_id () const
{
  return "IDL:M1/AMH_LIResponseHandler:1.0";
}

::CORBA::Boolean
M1::AMH_LIResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M1_AMH_LIResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:M1/AMH_LIResponseHandler:1.0",
    "AMH_LIResponseHandler");
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_AMH_LIResponseHandler =
    &_tao_tc_M1_AMH_LIResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M1::L2.

M1::L2_ptr
TAO::Objref_Traits<M1::L2>::duplicate (M1::L2_ptr p)
{
  return M1::L2::_duplicate (p);
}

void
TAO::Objref_Traits<M1::L2>::release (M1::L2_ptr p)
{
  ::CORBA::release (p);
}

M1::L2_ptr
TAO::Objref_Traits<M1::L2>::nil ()
{
  return M1::L2::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M1::L2>::marshal (const M1::L2_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
M1::L2::op (
  const ::M1::S1 & s)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::M1::S1>::in_arg_val _tao_s (s);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_s)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

M1::L2::L2 ()
{
}
void
M1::L2::_tao_any_destructor (void *_tao_void_pointer)
{
  L2 *_tao_tmp_pointer =
    static_cast<L2 *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M1::L2_ptr
M1::L2::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<L2>::narrow (_tao_objref, "IDL:M1/L2:1.0");
}

M1::L2_ptr
M1::L2::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<L2>::unchecked_narrow (_tao_objref);
}

M1::L2_ptr
M1::L2::_nil ()
{
  return nullptr;
}

M1::L2_ptr
M1::L2::_duplicate (L2_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M1::L2::_tao_release (L2_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M1::L2::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M1/L2:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* M1::L2::_interface_repository_id () const
{
  return "IDL:M1/L2:1.0";
}

::CORBA::Boolean
M1::L2::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M1_L2 (
    ::CORBA::tk_objref,
    "IDL:M1/L2:1.0",
    "L2");
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_L2 =
    &_tao_tc_M1_L2;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_M1_AMH_L2ExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_M1_AMH_L2ExceptionHolder (
    ::CORBA::tk_value,
    "IDL:M1/AMH_L2ExceptionHolder:1.0",
    "AMH_L2ExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_M1_AMH_L2ExceptionHolder,
    0);
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_AMH_L2ExceptionHolder =
    &_tao_tc_M1_AMH_L2ExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<M1::AMH_L2ExceptionHolder>::add_ref (M1::AMH_L2ExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<M1::AMH_L2ExceptionHolder>::remove_ref (M1::AMH_L2ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<M1::AMH_L2ExceptionHolder>::release (M1::AMH_L2ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M1::AMH_L2ExceptionHolder *
M1::AMH_L2ExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::M1::AMH_L2ExceptionHolder *> (v);
}

const char *
M1::AMH_L2ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
M1::AMH_L2ExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
M1::AMH_L2ExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_L2ExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_L2ExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr M1::AMH_L2ExceptionHolder::_tao_type () const
{
  return ::M1::_tc_AMH_L2ExceptionHolder;
}

M1::AMH_L2ExceptionHolder::~AMH_L2ExceptionHolder ()
{}

::CORBA::ValueBase *
M1::AMH_L2ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_L2ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
M1::AMH_L2ExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
M1::AMH_L2ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
M1::AMH_L2ExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
M1::AMH_L2ExceptionHolder::_tao_marshal__M1_AMH_L2ExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
M1::AMH_L2ExceptionHolder::_tao_unmarshal__M1_AMH_L2ExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
M1::AMH_L2ExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_L2ExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_L2ExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_L2ExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
M1::AMH_L2ExceptionHolder::raise_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M1::AMH_L2ResponseHandler.

M1::AMH_L2ResponseHandler_ptr
TAO::Objref_Traits<M1::AMH_L2ResponseHandler>::duplicate (M1::AMH_L2ResponseHandler_ptr p)
{
  return M1::AMH_L2ResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<M1::AMH_L2ResponseHandler>::release (M1::AMH_L2ResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

M1::AMH_L2ResponseHandler_ptr
TAO::Objref_Traits<M1::AMH_L2ResponseHandler>::nil ()
{
  return M1::AMH_L2ResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M1::AMH_L2ResponseHandler>::marshal (const M1::AMH_L2ResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M1::AMH_L2ResponseHandler::AMH_L2ResponseHandler ()
{}void
M1::AMH_L2ResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_L2ResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_L2ResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M1::AMH_L2ResponseHandler_ptr
M1::AMH_L2ResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_L2ResponseHandler::_duplicate (
      dynamic_cast<AMH_L2ResponseHandler_ptr> (_tao_objref));
}

M1::AMH_L2ResponseHandler_ptr
M1::AMH_L2ResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_L2ResponseHandler::_duplicate (
      dynamic_cast<AMH_L2ResponseHandler_ptr> (_tao_objref));
}

M1::AMH_L2ResponseHandler_ptr
M1::AMH_L2ResponseHandler::_nil ()
{
  return nullptr;
}

M1::AMH_L2ResponseHandler_ptr
M1::AMH_L2ResponseHandler::_duplicate (AMH_L2ResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M1::AMH_L2ResponseHandler::_tao_release (AMH_L2ResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M1::AMH_L2ResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M1/AMH_L2ResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* M1::AMH_L2ResponseHandler::_interface_repository_id () const
{
  return "IDL:M1/AMH_L2ResponseHandler:1.0";
}

::CORBA::Boolean
M1::AMH_L2ResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M1_AMH_L2ResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:M1/AMH_L2ResponseHandler:1.0",
    "AMH_L2ResponseHandler");
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_AMH_L2ResponseHandler =
    &_tao_tc_M1_AMH_L2ResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_M1_X[] =
      {
        { "valString", &CORBA::_tc_string },
        { "valStruct", &M1::_tc_S1 },
        { "valLocalIface", &M1::_tc_L2 }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_M1_X (
  ::CORBA::tk_struct,
  "IDL:M1/X:1.0",
  "X",
  _tao_fields_M1_X,
  3);


namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_X =
    &_tao_tc_M1_X;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
M1::X::_tao_any_destructor (
    void *_tao_void_pointer)
{
  X *_tao_tmp_pointer =
    static_cast<X *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/union_cs.cpp:75



M1::BooleanUnion1::BooleanUnion1 ()
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = false;
}

M1::BooleanUnion1::BooleanUnion1 (const ::M1::BooleanUnion1 &u)
{
  this->disc_ = u.disc_;
  
  if (this->disc_)
    {
      if (!u.u_.valLocalIface_)
        {
          this->u_.valLocalIface_ = nullptr;
        }
      else
        {
          typedef M1::L2_var OBJECT_FIELD;
          ACE_NEW (
              this->u_.valLocalIface_,
              OBJECT_FIELD (
                  M1::L2::_duplicate (
                      u.u_.valLocalIface_->in ()
                    )
                )
            );
        }
    }
  
}

M1::BooleanUnion1::~BooleanUnion1 ()
{
  // Finalize.
  this->_reset ();
}

void M1::BooleanUnion1::_tao_any_destructor (void *_tao_void_pointer)
{
  BooleanUnion1 *tmp =
    static_cast<BooleanUnion1 *> (_tao_void_pointer);
  delete tmp;
}

M1::BooleanUnion1 &
M1::BooleanUnion1::operator= (const ::M1::BooleanUnion1 &u)
{
  if (std::addressof(u) == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  
  if (this->disc_)
    {
      if (!u.u_.valLocalIface_)
        {
          this->u_.valLocalIface_ = nullptr;
        }
      else
        {
          typedef M1::L2_var OBJECT_FIELD;
          ACE_NEW_RETURN (
              this->u_.valLocalIface_,
              OBJECT_FIELD (
                  M1::L2::_duplicate (
                      u.u_.valLocalIface_->in ()
                    )
                ),
              *this);
        }
    }
  
  return *this;
}

/// Reset method to reset old values of a union.
void M1::BooleanUnion1::_reset ()
{
  
  if (this->disc_)
    {
      delete this->u_.valLocalIface_;
      this->u_.valLocalIface_ = nullptr;
      
    }
  
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/union_typecode.cpp:63

static TAO::TypeCode::Case_T<CORBA::Boolean, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_M1_BooleanUnion1__0 (true, "valLocalIface", &M1::_tc_L2);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_M1_BooleanUnion1[] =
  {
    &_tao_cases_M1_BooleanUnion1__0
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_M1_BooleanUnion1 (
    "IDL:M1/BooleanUnion1:1.0",
    "BooleanUnion1",
    &CORBA::_tc_boolean,
    _tao_cases_M1_BooleanUnion1,
    sizeof (_tao_cases_M1_BooleanUnion1)/sizeof (_tao_cases_M1_BooleanUnion1[0]),
    -1);
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_BooleanUnion1 =
    &_tao_tc_M1_BooleanUnion1;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/union_cs.cpp:75



M1::BooleanUnion2::BooleanUnion2 ()
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = false;
}

M1::BooleanUnion2::BooleanUnion2 (const ::M1::BooleanUnion2 &u)
{
  this->disc_ = u.disc_;
  
  if (this->disc_)
    {
      this->u_.valLocalIface_ = ::CORBA::string_dup (u.u_.valLocalIface_);
    }
  
}

M1::BooleanUnion2::~BooleanUnion2 ()
{
  // Finalize.
  this->_reset ();
}

void M1::BooleanUnion2::_tao_any_destructor (void *_tao_void_pointer)
{
  BooleanUnion2 *tmp =
    static_cast<BooleanUnion2 *> (_tao_void_pointer);
  delete tmp;
}

M1::BooleanUnion2 &
M1::BooleanUnion2::operator= (const ::M1::BooleanUnion2 &u)
{
  if (std::addressof(u) == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  
  if (this->disc_)
    {
      this->u_.valLocalIface_ = ::CORBA::string_dup (u.u_.valLocalIface_);
    }
  
  return *this;
}

/// Reset method to reset old values of a union.
void M1::BooleanUnion2::_reset ()
{
  
  if (this->disc_)
    {
      ::CORBA::string_free (this->u_.valLocalIface_);
      this->u_.valLocalIface_ = nullptr;
      
    }
  
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/union_typecode.cpp:63

static TAO::TypeCode::Case_T<CORBA::Boolean, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_M1_BooleanUnion2__0 (true, "valLocalIface", &CORBA::_tc_string);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_M1_BooleanUnion2[] =
  {
    &_tao_cases_M1_BooleanUnion2__0
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_M1_BooleanUnion2 (
    "IDL:M1/BooleanUnion2:1.0",
    "BooleanUnion2",
    &CORBA::_tc_boolean,
    _tao_cases_M1_BooleanUnion2,
    sizeof (_tao_cases_M1_BooleanUnion2)/sizeof (_tao_cases_M1_BooleanUnion2[0]),
    -1);
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_BooleanUnion2 =
    &_tao_tc_M1_BooleanUnion2;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_M1_V[] =
  {
    { "valString", &CORBA::_tc_string, ::CORBA::PUBLIC_MEMBER },
    { "valStruct", &M1::_tc_S1, ::CORBA::PUBLIC_MEMBER },
    { "valLocalIface", &M1::_tc_LI, ::CORBA::PUBLIC_MEMBER },
    { "valBoolUnion1", &M1::_tc_BooleanUnion1, ::CORBA::PUBLIC_MEMBER },
    { "valBoolUnion2", &M1::_tc_BooleanUnion2, ::CORBA::PUBLIC_MEMBER },
    { "valX", &M1::_tc_X, ::CORBA::PUBLIC_MEMBER }
    
  };
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_M1_V (
    ::CORBA::tk_value,
    "IDL:M1/V:1.0",
    "V",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_M1_V,
    6);
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_V =
    &_tao_tc_M1_V;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<M1::V>::add_ref (M1::V * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<M1::V>::remove_ref (M1::V * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<M1::V>::release (M1::V * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M1::V *
M1::V::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::M1::V *> (v);
}

const char *
M1::V::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
M1::V::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
M1::V::_tao_any_destructor (void *_tao_void_pointer)
{
  V *_tao_tmp_pointer =
    static_cast<V *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr M1::V::_tao_type () const
{
  return ::M1::_tc_V;
}

M1::V::~V ()
{}

::CORBA::Boolean
M1::V::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__M1_V (strm, ci);
}

::CORBA::Boolean
M1::V::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__M1_V (strm,ci);
}

::CORBA::Boolean
M1::V::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (M1::V::_downcast);
}

::CORBA::Boolean
M1::V::_tao_unmarshal (
    TAO_InputCDR &strm,
    V *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        V::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = V::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



M1::V_init::V_init ()
{
}

M1::V_init::~V_init ()
{
}

M1::V_init *
M1::V_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::M1::V_init *> (v);
}

const char*
M1::V_init::tao_repository_id ()
{
  return ::M1::V::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
M1::V_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_M1::V,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_M2_M3_S2[] =
      {
        { "o", &CORBA::_tc_octet }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_M2_M3_S2 (
  ::CORBA::tk_struct,
  "IDL:M2/M3/S2:1.0",
  "S2",
  _tao_fields_M2_M3_S2,
  1);


namespace M2
{
  
  namespace M3
  {
    ::CORBA::TypeCode_ptr const _tc_S2 =
      &_tao_tc_M2_M3_S2;
  }
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
M2::M3::S2::_tao_any_destructor (
    void *_tao_void_pointer)
{
  S2 *_tao_tmp_pointer =
    static_cast<S2 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M2::M3::L3.

M2::M3::L3_ptr
TAO::Objref_Traits<M2::M3::L3>::duplicate (M2::M3::L3_ptr p)
{
  return M2::M3::L3::_duplicate (p);
}

void
TAO::Objref_Traits<M2::M3::L3>::release (M2::M3::L3_ptr p)
{
  ::CORBA::release (p);
}

M2::M3::L3_ptr
TAO::Objref_Traits<M2::M3::L3>::nil ()
{
  return M2::M3::L3::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M2::M3::L3>::marshal (const M2::M3::L3_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
M2::M3::L3::op (
  const ::M2::M3::S2 & s)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::M2::M3::S2>::in_arg_val _tao_s (s);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_s)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

M2::M3::L3::L3 ()
{
}
void
M2::M3::L3::_tao_any_destructor (void *_tao_void_pointer)
{
  L3 *_tao_tmp_pointer =
    static_cast<L3 *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M2::M3::L3_ptr
M2::M3::L3::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<L3>::narrow (_tao_objref, "IDL:M2/M3/L3:1.0");
}

M2::M3::L3_ptr
M2::M3::L3::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<L3>::unchecked_narrow (_tao_objref);
}

M2::M3::L3_ptr
M2::M3::L3::_nil ()
{
  return nullptr;
}

M2::M3::L3_ptr
M2::M3::L3::_duplicate (L3_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M2::M3::L3::_tao_release (L3_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M2::M3::L3::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M2/M3/L3:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* M2::M3::L3::_interface_repository_id () const
{
  return "IDL:M2/M3/L3:1.0";
}

::CORBA::Boolean
M2::M3::L3::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M2_M3_L3 (
    ::CORBA::tk_objref,
    "IDL:M2/M3/L3:1.0",
    "L3");
  

namespace M2
{
  
  namespace M3
  {
    ::CORBA::TypeCode_ptr const _tc_L3 =
      &_tao_tc_M2_M3_L3;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_M2_M3_AMH_L3ExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_M2_M3_AMH_L3ExceptionHolder (
    ::CORBA::tk_value,
    "IDL:M2/M3/AMH_L3ExceptionHolder:1.0",
    "AMH_L3ExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_M2_M3_AMH_L3ExceptionHolder,
    0);
  

namespace M2
{
  
  namespace M3
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_L3ExceptionHolder =
      &_tao_tc_M2_M3_AMH_L3ExceptionHolder;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<M2::M3::AMH_L3ExceptionHolder>::add_ref (M2::M3::AMH_L3ExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<M2::M3::AMH_L3ExceptionHolder>::remove_ref (M2::M3::AMH_L3ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<M2::M3::AMH_L3ExceptionHolder>::release (M2::M3::AMH_L3ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M2::M3::AMH_L3ExceptionHolder *
M2::M3::AMH_L3ExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::M2::M3::AMH_L3ExceptionHolder *> (v);
}

const char *
M2::M3::AMH_L3ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
M2::M3::AMH_L3ExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
M2::M3::AMH_L3ExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_L3ExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_L3ExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr M2::M3::AMH_L3ExceptionHolder::_tao_type () const
{
  return ::M2::M3::_tc_AMH_L3ExceptionHolder;
}

M2::M3::AMH_L3ExceptionHolder::~AMH_L3ExceptionHolder ()
{}

::CORBA::ValueBase *
M2::M3::AMH_L3ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_L3ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
M2::M3::AMH_L3ExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
M2::M3::AMH_L3ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
M2::M3::AMH_L3ExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
M2::M3::AMH_L3ExceptionHolder::_tao_marshal__M2_M3_AMH_L3ExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
M2::M3::AMH_L3ExceptionHolder::_tao_unmarshal__M2_M3_AMH_L3ExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
M2::M3::AMH_L3ExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_L3ExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_L3ExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_L3ExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
M2::M3::AMH_L3ExceptionHolder::raise_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M2::M3::AMH_L3ResponseHandler.

M2::M3::AMH_L3ResponseHandler_ptr
TAO::Objref_Traits<M2::M3::AMH_L3ResponseHandler>::duplicate (M2::M3::AMH_L3ResponseHandler_ptr p)
{
  return M2::M3::AMH_L3ResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<M2::M3::AMH_L3ResponseHandler>::release (M2::M3::AMH_L3ResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

M2::M3::AMH_L3ResponseHandler_ptr
TAO::Objref_Traits<M2::M3::AMH_L3ResponseHandler>::nil ()
{
  return M2::M3::AMH_L3ResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M2::M3::AMH_L3ResponseHandler>::marshal (const M2::M3::AMH_L3ResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M2::M3::AMH_L3ResponseHandler::AMH_L3ResponseHandler ()
{}void
M2::M3::AMH_L3ResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_L3ResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_L3ResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M2::M3::AMH_L3ResponseHandler_ptr
M2::M3::AMH_L3ResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_L3ResponseHandler::_duplicate (
      dynamic_cast<AMH_L3ResponseHandler_ptr> (_tao_objref));
}

M2::M3::AMH_L3ResponseHandler_ptr
M2::M3::AMH_L3ResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_L3ResponseHandler::_duplicate (
      dynamic_cast<AMH_L3ResponseHandler_ptr> (_tao_objref));
}

M2::M3::AMH_L3ResponseHandler_ptr
M2::M3::AMH_L3ResponseHandler::_nil ()
{
  return nullptr;
}

M2::M3::AMH_L3ResponseHandler_ptr
M2::M3::AMH_L3ResponseHandler::_duplicate (AMH_L3ResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M2::M3::AMH_L3ResponseHandler::_tao_release (AMH_L3ResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M2::M3::AMH_L3ResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M2/M3/AMH_L3ResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* M2::M3::AMH_L3ResponseHandler::_interface_repository_id () const
{
  return "IDL:M2/M3/AMH_L3ResponseHandler:1.0";
}

::CORBA::Boolean
M2::M3::AMH_L3ResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M2_M3_AMH_L3ResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:M2/M3/AMH_L3ResponseHandler:1.0",
    "AMH_L3ResponseHandler");
  

namespace M2
{
  
  namespace M3
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_L3ResponseHandler =
      &_tao_tc_M2_M3_AMH_L3ResponseHandler;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



M2::M3::E1::E1 (
    const M2::M3::L3_ptr _tao_val2,
    const M1::BooleanUnion1 & _tao_bool1,
    const M1::BooleanUnion2 & _tao_bool2)
  : ::CORBA::UserException (
        "IDL:M2/M3/E1:1.0",
        "E1")
{
  this->val2 = TAO::Objref_Traits<M2::M3::L3>::duplicate (_tao_val2);
  this->bool1 = _tao_bool1;
  this->bool2 = _tao_bool2;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

M2::M3::E1::E1 ()
  : ::CORBA::UserException (
        "IDL:M2/M3/E1:1.0",
        "E1")
{
}

M2::M3::E1::E1 (const ::M2::M3::E1 &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->val2 = TAO::Objref_Traits<M2::M3::L3>::duplicate (_tao_excp.val2.in ());
  this->bool1 = _tao_excp.bool1;
  this->bool2 = _tao_excp.bool2;
}

M2::M3::E1&
M2::M3::E1::operator= (const ::M2::M3::E1 &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->val2 = TAO::Objref_Traits<M2::M3::L3>::duplicate (_tao_excp.val2.in ());
  this->bool1 = _tao_excp.bool1;
  this->bool2 = _tao_excp.bool2;
  return *this;
}

void M2::M3::E1::_tao_any_destructor (void *_tao_void_pointer)
{
  E1 *_tao_tmp_pointer =
    static_cast<E1 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

M2::M3::E1 *
M2::M3::E1::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<E1 *> (_tao_excp);
}

const M2::M3::E1 *
M2::M3::E1::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const E1 *> (_tao_excp);
}

::CORBA::Exception *M2::M3::E1::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::M2::M3::E1, nullptr);
  return retval;
}

::CORBA::Exception *
M2::M3::E1::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::M2::M3::E1 (*this), nullptr);
  return result;
}

void M2::M3::E1::_raise () const
{
  throw *this;
}

void M2::M3::E1::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void M2::M3::E1::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr M2::M3::E1::_tao_type () const
{
  return ::M2::M3::_tc_E1;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_M2_M3_E1[] =
      {
        { "val2", &M2::M3::_tc_L3 },
        { "bool1", &M1::_tc_BooleanUnion1 },
        { "bool2", &M1::_tc_BooleanUnion2 }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_M2_M3_E1 (
  ::CORBA::tk_except,
  "IDL:M2/M3/E1:1.0",
  "E1",
  _tao_fields_M2_M3_E1,
  3);


namespace M2
{
  
  namespace M3
  {
    ::CORBA::TypeCode_ptr const _tc_E1 =
      &_tao_tc_M2_M3_E1;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M2::M3::L4.

M2::M3::L4_ptr
TAO::Objref_Traits<M2::M3::L4>::duplicate (M2::M3::L4_ptr p)
{
  return M2::M3::L4::_duplicate (p);
}

void
TAO::Objref_Traits<M2::M3::L4>::release (M2::M3::L4_ptr p)
{
  ::CORBA::release (p);
}

M2::M3::L4_ptr
TAO::Objref_Traits<M2::M3::L4>::nil ()
{
  return M2::M3::L4::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M2::M3::L4>::marshal (const M2::M3::L4_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
M2::M3::L4::op (
  const ::M2::M3::S2 & s)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::M2::M3::S2>::in_arg_val _tao_s (s);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_s)
    };

  static TAO::Exception_Data
  _tao_M2_M3_L4_op_exceptiondata [] = 
    {
      {
        "IDL:M2/M3/E1:1.0",
        M2::M3::E1::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , M2::M3::_tc_E1
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (
      _tao_M2_M3_L4_op_exceptiondata,
      1
    );
}

M2::M3::L4::L4 ()
{
}
void
M2::M3::L4::_tao_any_destructor (void *_tao_void_pointer)
{
  L4 *_tao_tmp_pointer =
    static_cast<L4 *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M2::M3::L4_ptr
M2::M3::L4::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<L4>::narrow (_tao_objref, "IDL:M2/M3/L4:1.0");
}

M2::M3::L4_ptr
M2::M3::L4::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<L4>::unchecked_narrow (_tao_objref);
}

M2::M3::L4_ptr
M2::M3::L4::_nil ()
{
  return nullptr;
}

M2::M3::L4_ptr
M2::M3::L4::_duplicate (L4_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M2::M3::L4::_tao_release (L4_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M2::M3::L4::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M2/M3/L4:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* M2::M3::L4::_interface_repository_id () const
{
  return "IDL:M2/M3/L4:1.0";
}

::CORBA::Boolean
M2::M3::L4::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M2_M3_L4 (
    ::CORBA::tk_objref,
    "IDL:M2/M3/L4:1.0",
    "L4");
  

namespace M2
{
  
  namespace M3
  {
    ::CORBA::TypeCode_ptr const _tc_L4 =
      &_tao_tc_M2_M3_L4;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_M2_M3_AMH_L4ExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_M2_M3_AMH_L4ExceptionHolder (
    ::CORBA::tk_value,
    "IDL:M2/M3/AMH_L4ExceptionHolder:1.0",
    "AMH_L4ExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_M2_M3_AMH_L4ExceptionHolder,
    0);
  

namespace M2
{
  
  namespace M3
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_L4ExceptionHolder =
      &_tao_tc_M2_M3_AMH_L4ExceptionHolder;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<M2::M3::AMH_L4ExceptionHolder>::add_ref (M2::M3::AMH_L4ExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<M2::M3::AMH_L4ExceptionHolder>::remove_ref (M2::M3::AMH_L4ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<M2::M3::AMH_L4ExceptionHolder>::release (M2::M3::AMH_L4ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M2::M3::AMH_L4ExceptionHolder *
M2::M3::AMH_L4ExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::M2::M3::AMH_L4ExceptionHolder *> (v);
}

const char *
M2::M3::AMH_L4ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
M2::M3::AMH_L4ExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
M2::M3::AMH_L4ExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_L4ExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_L4ExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr M2::M3::AMH_L4ExceptionHolder::_tao_type () const
{
  return ::M2::M3::_tc_AMH_L4ExceptionHolder;
}

M2::M3::AMH_L4ExceptionHolder::~AMH_L4ExceptionHolder ()
{}

::CORBA::ValueBase *
M2::M3::AMH_L4ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_L4ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
M2::M3::AMH_L4ExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
M2::M3::AMH_L4ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
M2::M3::AMH_L4ExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
M2::M3::AMH_L4ExceptionHolder::_tao_marshal__M2_M3_AMH_L4ExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
M2::M3::AMH_L4ExceptionHolder::_tao_unmarshal__M2_M3_AMH_L4ExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
M2::M3::AMH_L4ExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_L4ExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_L4ExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_L4ExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
M2::M3::AMH_L4ExceptionHolder::raise_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M2::M3::AMH_L4ResponseHandler.

M2::M3::AMH_L4ResponseHandler_ptr
TAO::Objref_Traits<M2::M3::AMH_L4ResponseHandler>::duplicate (M2::M3::AMH_L4ResponseHandler_ptr p)
{
  return M2::M3::AMH_L4ResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<M2::M3::AMH_L4ResponseHandler>::release (M2::M3::AMH_L4ResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

M2::M3::AMH_L4ResponseHandler_ptr
TAO::Objref_Traits<M2::M3::AMH_L4ResponseHandler>::nil ()
{
  return M2::M3::AMH_L4ResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M2::M3::AMH_L4ResponseHandler>::marshal (const M2::M3::AMH_L4ResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M2::M3::AMH_L4ResponseHandler::AMH_L4ResponseHandler ()
{}void
M2::M3::AMH_L4ResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_L4ResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_L4ResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M2::M3::AMH_L4ResponseHandler_ptr
M2::M3::AMH_L4ResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_L4ResponseHandler::_duplicate (
      dynamic_cast<AMH_L4ResponseHandler_ptr> (_tao_objref));
}

M2::M3::AMH_L4ResponseHandler_ptr
M2::M3::AMH_L4ResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_L4ResponseHandler::_duplicate (
      dynamic_cast<AMH_L4ResponseHandler_ptr> (_tao_objref));
}

M2::M3::AMH_L4ResponseHandler_ptr
M2::M3::AMH_L4ResponseHandler::_nil ()
{
  return nullptr;
}

M2::M3::AMH_L4ResponseHandler_ptr
M2::M3::AMH_L4ResponseHandler::_duplicate (AMH_L4ResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M2::M3::AMH_L4ResponseHandler::_tao_release (AMH_L4ResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M2::M3::AMH_L4ResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M2/M3/AMH_L4ResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* M2::M3::AMH_L4ResponseHandler::_interface_repository_id () const
{
  return "IDL:M2/M3/AMH_L4ResponseHandler:1.0";
}

::CORBA::Boolean
M2::M3::AMH_L4ResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M2_M3_AMH_L4ResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:M2/M3/AMH_L4ResponseHandler:1.0",
    "AMH_L4ResponseHandler");
  

namespace M2
{
  
  namespace M3
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_L4ResponseHandler =
      &_tao_tc_M2_M3_AMH_L4ResponseHandler;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_M2_M3_V2[] =
  {
    { "valString", &CORBA::_tc_string, ::CORBA::PUBLIC_MEMBER },
    { "valStruct", &M2::M3::_tc_S2, ::CORBA::PUBLIC_MEMBER },
    { "valLocalIface", &M2::M3::_tc_L3, ::CORBA::PUBLIC_MEMBER },
    { "valLocalIface3", &M2::M3::_tc_L4, ::CORBA::PUBLIC_MEMBER }
    
  };
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_M2_M3_V2 (
    ::CORBA::tk_value,
    "IDL:M2/M3/V2:1.0",
    "V2",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_M2_M3_V2,
    4);
  

namespace M2
{
  
  namespace M3
  {
    ::CORBA::TypeCode_ptr const _tc_V2 =
      &_tao_tc_M2_M3_V2;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<M2::M3::V2>::add_ref (M2::M3::V2 * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<M2::M3::V2>::remove_ref (M2::M3::V2 * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<M2::M3::V2>::release (M2::M3::V2 * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M2::M3::V2 *
M2::M3::V2::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::M2::M3::V2 *> (v);
}

const char *
M2::M3::V2::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
M2::M3::V2::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
M2::M3::V2::_tao_any_destructor (void *_tao_void_pointer)
{
  V2 *_tao_tmp_pointer =
    static_cast<V2 *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr M2::M3::V2::_tao_type () const
{
  return ::M2::M3::_tc_V2;
}

M2::M3::V2::~V2 ()
{}

::CORBA::Boolean
M2::M3::V2::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__M2_M3_V2 (strm, ci);
}

::CORBA::Boolean
M2::M3::V2::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__M2_M3_V2 (strm,ci);
}

::CORBA::Boolean
M2::M3::V2::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (M2::M3::V2::_downcast);
}

::CORBA::Boolean
M2::M3::V2::_tao_unmarshal (
    TAO_InputCDR &strm,
    V2 *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        V2::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = V2::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



M2::M3::V2_init::V2_init ()
{
}

M2::M3::V2_init::~V2_init ()
{
}

M2::M3::V2_init *
M2::M3::V2_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::M2::M3::V2_init *> (v);
}

const char*
M2::M3::V2_init::tao_repository_id ()
{
  return ::M2::M3::V2::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
M2::M3::V2_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_M2::M3::V2,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_M2_M3_V3[] =
  {
    { "valString", &CORBA::_tc_string, ::CORBA::PUBLIC_MEMBER },
    { "valStruct", &M1::_tc_S1, ::CORBA::PUBLIC_MEMBER },
    { "valLocalIface", &M1::_tc_L2, ::CORBA::PUBLIC_MEMBER }
    
  };
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_M2_M3_V3 (
    ::CORBA::tk_value,
    "IDL:M2/M3/V3:1.0",
    "V3",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_M2_M3_V3,
    3);
  

namespace M2
{
  
  namespace M3
  {
    ::CORBA::TypeCode_ptr const _tc_V3 =
      &_tao_tc_M2_M3_V3;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<M2::M3::V3>::add_ref (M2::M3::V3 * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<M2::M3::V3>::remove_ref (M2::M3::V3 * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<M2::M3::V3>::release (M2::M3::V3 * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M2::M3::V3 *
M2::M3::V3::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::M2::M3::V3 *> (v);
}

const char *
M2::M3::V3::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
M2::M3::V3::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
M2::M3::V3::_tao_any_destructor (void *_tao_void_pointer)
{
  V3 *_tao_tmp_pointer =
    static_cast<V3 *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr M2::M3::V3::_tao_type () const
{
  return ::M2::M3::_tc_V3;
}

M2::M3::V3::~V3 ()
{}

::CORBA::Boolean
M2::M3::V3::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__M2_M3_V3 (strm, ci);
}

::CORBA::Boolean
M2::M3::V3::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__M2_M3_V3 (strm,ci);
}

::CORBA::Boolean
M2::M3::V3::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (M2::M3::V3::_downcast);
}

::CORBA::Boolean
M2::M3::V3::_tao_unmarshal (
    TAO_InputCDR &strm,
    V3 *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        V3::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = V3::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



M2::M3::V3_init::V3_init ()
{
}

M2::M3::V3_init::~V3_init ()
{
}

M2::M3::V3_init *
M2::M3::V3_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::M2::M3::V3_init *> (v);
}

const char*
M2::M3::V3_init::tao_repository_id ()
{
  return ::M2::M3::V3::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
M2::M3::V3_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_M2::M3::V3,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_M1::AMH_LIExceptionHolder::~AMH_LIExceptionHolder ()
{}

::CORBA::Boolean
OBV_M1::AMH_LIExceptionHolder::_tao_marshal__M1_AMH_LIExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_M1::AMH_LIExceptionHolder::_tao_unmarshal__M1_AMH_LIExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_M1::AMH_L2ExceptionHolder::~AMH_L2ExceptionHolder ()
{}

::CORBA::Boolean
OBV_M1::AMH_L2ExceptionHolder::_tao_marshal__M1_AMH_L2ExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_M1::AMH_L2ExceptionHolder::_tao_unmarshal__M1_AMH_L2ExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_M1::V::V (
    const char * _tao_init_valString,
    const ::M1::S1 & _tao_init_valStruct,
    ::M1::LI_ptr _tao_init_valLocalIface,
    const ::M1::BooleanUnion1 & _tao_init_valBoolUnion1,
    const ::M1::BooleanUnion2 & _tao_init_valBoolUnion2,
    const ::M1::X & _tao_init_valX)
{
  valString (_tao_init_valString);
  valStruct (_tao_init_valStruct);
  valLocalIface (_tao_init_valLocalIface);
  valBoolUnion1 (_tao_init_valBoolUnion1);
  valBoolUnion2 (_tao_init_valBoolUnion2);
  valX (_tao_init_valX);
}

OBV_M1::V::~V ()
{}

::CORBA::ValueBase *
OBV_M1::V::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    V (
      valString (),
      valStruct (),
      valLocalIface (),
      valBoolUnion1 (),
      valBoolUnion2 (),
      valX ()
    ),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_M1::V::_tao_marshal__M1_V (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_M1::V::_tao_unmarshal__M1_V (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:825

/// Accessor to set the member.
void
OBV_M1::V::valString (char *val)
{
  this->_pd_valString = (val);
}

/// Accessor to set the member.
void
OBV_M1::V::valString (const char *val)
{
  // Set the value.
  this->_pd_valString = ::CORBA::string_dup (val);
}

/// Accessor to set the member.
void
OBV_M1::V::valString (const ::CORBA::String_var &val)
{
  ::CORBA::String_var valString_var = val;
  this->_pd_valString = valString_var._retn ();
}

const char *
OBV_M1::V::valString () const // get method
{
  return this->_pd_valString;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:993

/// Accessor to set the member.
void
OBV_M1::V::valStruct (const M1::S1 &val)
{
  this->_pd_valStruct = val;
}
/// Readonly get method.
const M1::S1 &
OBV_M1::V::valStruct () const
{
  return this->_pd_valStruct;
}
/// Read/write get method.
M1::S1 &
OBV_M1::V::valStruct ()
{
  return this->_pd_valStruct;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:284

/// Accessor to set the member.
void
OBV_M1::V::valLocalIface (M1::LI_ptr val)
{
  this->_pd_valLocalIface =
    TAO::Objref_Traits< ::M1::LI>::duplicate (val);
}

/// Retrieve the member.
M1::LI_ptr
OBV_M1::V::valLocalIface () const
{
  return this->_pd_valLocalIface.in ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:1109

/// Accessor to set the member
void
OBV_M1::V::valBoolUnion1 (const M1::BooleanUnion1 &val)
{
  this->_pd_valBoolUnion1 = val;
}
/// Readonly get method.
const M1::BooleanUnion1 &
OBV_M1::V::valBoolUnion1 () const
{
  return this->_pd_valBoolUnion1;
}
/// Read/write get method.
M1::BooleanUnion1 &
OBV_M1::V::valBoolUnion1 ()
{
  return this->_pd_valBoolUnion1;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:1109

/// Accessor to set the member
void
OBV_M1::V::valBoolUnion2 (const M1::BooleanUnion2 &val)
{
  this->_pd_valBoolUnion2 = val;
}
/// Readonly get method.
const M1::BooleanUnion2 &
OBV_M1::V::valBoolUnion2 () const
{
  return this->_pd_valBoolUnion2;
}
/// Read/write get method.
M1::BooleanUnion2 &
OBV_M1::V::valBoolUnion2 ()
{
  return this->_pd_valBoolUnion2;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:993

/// Accessor to set the member.
void
OBV_M1::V::valX (const M1::X &val)
{
  this->_pd_valX = val;
}
/// Readonly get method.
const M1::X &
OBV_M1::V::valX () const
{
  return this->_pd_valX;
}
/// Read/write get method.
M1::X &
OBV_M1::V::valX ()
{
  return this->_pd_valX;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_M2::M3::AMH_L3ExceptionHolder::~AMH_L3ExceptionHolder ()
{}

::CORBA::Boolean
OBV_M2::M3::AMH_L3ExceptionHolder::_tao_marshal__M2_M3_AMH_L3ExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_M2::M3::AMH_L3ExceptionHolder::_tao_unmarshal__M2_M3_AMH_L3ExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_M2::M3::AMH_L4ExceptionHolder::~AMH_L4ExceptionHolder ()
{}

::CORBA::Boolean
OBV_M2::M3::AMH_L4ExceptionHolder::_tao_marshal__M2_M3_AMH_L4ExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_M2::M3::AMH_L4ExceptionHolder::_tao_unmarshal__M2_M3_AMH_L4ExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_M2::M3::V2::V2 (
    const char * _tao_init_valString,
    const ::M2::M3::S2 & _tao_init_valStruct,
    ::M2::M3::L3_ptr _tao_init_valLocalIface,
    ::M2::M3::L4_ptr _tao_init_valLocalIface3)
{
  valString (_tao_init_valString);
  valStruct (_tao_init_valStruct);
  valLocalIface (_tao_init_valLocalIface);
  valLocalIface3 (_tao_init_valLocalIface3);
}

OBV_M2::M3::V2::~V2 ()
{}

::CORBA::ValueBase *
OBV_M2::M3::V2::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    V2 (
      valString (),
      valStruct (),
      valLocalIface (),
      valLocalIface3 ()
    ),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_M2::M3::V2::_tao_marshal__M2_M3_V2 (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_M2::M3::V2::_tao_unmarshal__M2_M3_V2 (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:825

/// Accessor to set the member.
void
OBV_M2::M3::V2::valString (char *val)
{
  this->_pd_valString = (val);
}

/// Accessor to set the member.
void
OBV_M2::M3::V2::valString (const char *val)
{
  // Set the value.
  this->_pd_valString = ::CORBA::string_dup (val);
}

/// Accessor to set the member.
void
OBV_M2::M3::V2::valString (const ::CORBA::String_var &val)
{
  ::CORBA::String_var valString_var = val;
  this->_pd_valString = valString_var._retn ();
}

const char *
OBV_M2::M3::V2::valString () const // get method
{
  return this->_pd_valString;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:993

/// Accessor to set the member.
void
OBV_M2::M3::V2::valStruct (const M2::M3::S2 &val)
{
  this->_pd_valStruct = val;
}
/// Readonly get method.
const M2::M3::S2 &
OBV_M2::M3::V2::valStruct () const
{
  return this->_pd_valStruct;
}
/// Read/write get method.
M2::M3::S2 &
OBV_M2::M3::V2::valStruct ()
{
  return this->_pd_valStruct;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:284

/// Accessor to set the member.
void
OBV_M2::M3::V2::valLocalIface (M2::M3::L3_ptr val)
{
  this->_pd_valLocalIface =
    TAO::Objref_Traits< ::M2::M3::L3>::duplicate (val);
}

/// Retrieve the member.
M2::M3::L3_ptr
OBV_M2::M3::V2::valLocalIface () const
{
  return this->_pd_valLocalIface.in ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:284

/// Accessor to set the member.
void
OBV_M2::M3::V2::valLocalIface3 (M2::M3::L4_ptr val)
{
  this->_pd_valLocalIface3 =
    TAO::Objref_Traits< ::M2::M3::L4>::duplicate (val);
}

/// Retrieve the member.
M2::M3::L4_ptr
OBV_M2::M3::V2::valLocalIface3 () const
{
  return this->_pd_valLocalIface3.in ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_M2::M3::V3::V3 (
    const char * _tao_init_valString,
    const ::M1::S1 & _tao_init_valStruct,
    ::M1::L2_ptr _tao_init_valLocalIface)
{
  valString (_tao_init_valString);
  valStruct (_tao_init_valStruct);
  valLocalIface (_tao_init_valLocalIface);
}

OBV_M2::M3::V3::~V3 ()
{}

::CORBA::ValueBase *
OBV_M2::M3::V3::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    V3 (
      valString (),
      valStruct (),
      valLocalIface ()
    ),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_M2::M3::V3::_tao_marshal__M2_M3_V3 (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_M2::M3::V3::_tao_unmarshal__M2_M3_V3 (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:825

/// Accessor to set the member.
void
OBV_M2::M3::V3::valString (char *val)
{
  this->_pd_valString = (val);
}

/// Accessor to set the member.
void
OBV_M2::M3::V3::valString (const char *val)
{
  // Set the value.
  this->_pd_valString = ::CORBA::string_dup (val);
}

/// Accessor to set the member.
void
OBV_M2::M3::V3::valString (const ::CORBA::String_var &val)
{
  ::CORBA::String_var valString_var = val;
  this->_pd_valString = valString_var._retn ();
}

const char *
OBV_M2::M3::V3::valString () const // get method
{
  return this->_pd_valString;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:993

/// Accessor to set the member.
void
OBV_M2::M3::V3::valStruct (const M1::S1 &val)
{
  this->_pd_valStruct = val;
}
/// Readonly get method.
const M1::S1 &
OBV_M2::M3::V3::valStruct () const
{
  return this->_pd_valStruct;
}
/// Read/write get method.
M1::S1 &
OBV_M2::M3::V3::valStruct ()
{
  return this->_pd_valStruct;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:284

/// Accessor to set the member.
void
OBV_M2::M3::V3::valLocalIface (M1::L2_ptr val)
{
  this->_pd_valLocalIface =
    TAO::Objref_Traits< ::M1::L2>::duplicate (val);
}

/// Retrieve the member.
M1::L2_ptr
OBV_M2::M3::V3::valLocalIface () const
{
  return this->_pd_valLocalIface.in ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::M1::S1 &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::M1::S1>::insert_copy (
    _tao_any,
    ::M1::S1::_tao_any_destructor,
    M1::_tc_S1,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::M1::S1 *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::M1::S1>::insert (
    _tao_any,
    ::M1::S1::_tao_any_destructor,
    M1::_tc_S1,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::M1::S1 *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::M1::S1>::extract (
    _tao_any,
    ::M1::S1::_tao_any_destructor,
    M1::_tc_S1,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::LI>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::LI_ptr _tao_elem)
{
  M1::LI_ptr _tao_objptr =
    M1::LI::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::LI_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M1::LI>::insert (
    _tao_any,
    M1::LI::_tao_any_destructor,
    M1::_tc_LI,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M1::LI_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M1::LI>::extract (
        _tao_any,
        M1::LI::_tao_any_destructor,
        M1::_tc_LI,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::AMH_LIExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::AMH_LIExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    M1::AMH_LIExceptionHolder *_tao_copy =
      _tao_elem ?
        M1::AMH_LIExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::AMH_LIExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<M1::AMH_LIExceptionHolder>::insert (
    _tao_any,
    M1::AMH_LIExceptionHolder::_tao_any_destructor,
    M1::_tc_AMH_LIExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M1::AMH_LIExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<M1::AMH_LIExceptionHolder>::extract (
        _tao_any,
        M1::AMH_LIExceptionHolder::_tao_any_destructor,
        M1::_tc_AMH_LIExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::AMH_LIResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::AMH_LIResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::AMH_LIResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::AMH_LIResponseHandler_ptr _tao_elem)
{
  M1::AMH_LIResponseHandler_ptr _tao_objptr =
    M1::AMH_LIResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::AMH_LIResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M1::AMH_LIResponseHandler>::insert (
    _tao_any,
    M1::AMH_LIResponseHandler::_tao_any_destructor,
    M1::_tc_AMH_LIResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M1::AMH_LIResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M1::AMH_LIResponseHandler>::extract (
        _tao_any,
        M1::AMH_LIResponseHandler::_tao_any_destructor,
        M1::_tc_AMH_LIResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::L2>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::L2_ptr _tao_elem)
{
  M1::L2_ptr _tao_objptr =
    M1::L2::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::L2_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M1::L2>::insert (
    _tao_any,
    M1::L2::_tao_any_destructor,
    M1::_tc_L2,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M1::L2_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M1::L2>::extract (
        _tao_any,
        M1::L2::_tao_any_destructor,
        M1::_tc_L2,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::AMH_L2ExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::AMH_L2ExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    M1::AMH_L2ExceptionHolder *_tao_copy =
      _tao_elem ?
        M1::AMH_L2ExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::AMH_L2ExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<M1::AMH_L2ExceptionHolder>::insert (
    _tao_any,
    M1::AMH_L2ExceptionHolder::_tao_any_destructor,
    M1::_tc_AMH_L2ExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M1::AMH_L2ExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<M1::AMH_L2ExceptionHolder>::extract (
        _tao_any,
        M1::AMH_L2ExceptionHolder::_tao_any_destructor,
        M1::_tc_AMH_L2ExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::AMH_L2ResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::AMH_L2ResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::AMH_L2ResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::AMH_L2ResponseHandler_ptr _tao_elem)
{
  M1::AMH_L2ResponseHandler_ptr _tao_objptr =
    M1::AMH_L2ResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::AMH_L2ResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M1::AMH_L2ResponseHandler>::insert (
    _tao_any,
    M1::AMH_L2ResponseHandler::_tao_any_destructor,
    M1::_tc_AMH_L2ResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M1::AMH_L2ResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M1::AMH_L2ResponseHandler>::extract (
        _tao_any,
        M1::AMH_L2ResponseHandler::_tao_any_destructor,
        M1::_tc_AMH_L2ResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::M1::X &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::M1::X>::insert_copy (
    _tao_any,
    ::M1::X::_tao_any_destructor,
    M1::_tc_X,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::M1::X *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::M1::X>::insert (
    _tao_any,
    ::M1::X::_tao_any_destructor,
    M1::_tc_X,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::M1::X *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::M1::X>::extract (
    _tao_any,
    ::M1::X::_tao_any_destructor,
    M1::_tc_X,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/any_op_cs.cpp:35



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const M1::BooleanUnion1 &_tao_elem)
{
  TAO::Any_Dual_Impl_T<M1::BooleanUnion1>::insert_copy (
    _tao_any,
    M1::BooleanUnion1::_tao_any_destructor,
    M1::_tc_BooleanUnion1,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  M1::BooleanUnion1 *_tao_elem)
{
  TAO::Any_Dual_Impl_T<M1::BooleanUnion1>::insert (
    _tao_any,
    M1::BooleanUnion1::_tao_any_destructor,
    M1::_tc_BooleanUnion1,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const M1::BooleanUnion1 *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<M1::BooleanUnion1>::extract (
    _tao_any,
    M1::BooleanUnion1::_tao_any_destructor,
    M1::_tc_BooleanUnion1,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/any_op_cs.cpp:35



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const M1::BooleanUnion2 &_tao_elem)
{
  TAO::Any_Dual_Impl_T<M1::BooleanUnion2>::insert_copy (
    _tao_any,
    M1::BooleanUnion2::_tao_any_destructor,
    M1::_tc_BooleanUnion2,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  M1::BooleanUnion2 *_tao_elem)
{
  TAO::Any_Dual_Impl_T<M1::BooleanUnion2>::insert (
    _tao_any,
    M1::BooleanUnion2::_tao_any_destructor,
    M1::_tc_BooleanUnion2,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const M1::BooleanUnion2 *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<M1::BooleanUnion2>::extract (
    _tao_any,
    M1::BooleanUnion2::_tao_any_destructor,
    M1::_tc_BooleanUnion2,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M1::V>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::V *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    M1::V *_tao_copy =
      _tao_elem ?
        M1::V::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M1::V **_tao_elem)
{
  TAO::Any_Impl_T<M1::V>::insert (
    _tao_any,
    M1::V::_tao_any_destructor,
    M1::_tc_V,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M1::V *&_tao_elem)
{
  return
    TAO::Any_Impl_T<M1::V>::extract (
        _tao_any,
        M1::V::_tao_any_destructor,
        M1::_tc_V,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::M2::M3::S2 &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::M2::M3::S2>::insert_copy (
    _tao_any,
    ::M2::M3::S2::_tao_any_destructor,
    M2::M3::_tc_S2,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::M2::M3::S2 *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::M2::M3::S2>::insert (
    _tao_any,
    ::M2::M3::S2::_tao_any_destructor,
    M2::M3::_tc_S2,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::M2::M3::S2 *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::M2::M3::S2>::extract (
    _tao_any,
    ::M2::M3::S2::_tao_any_destructor,
    M2::M3::_tc_S2,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::L3>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::L3_ptr _tao_elem)
{
  M2::M3::L3_ptr _tao_objptr =
    M2::M3::L3::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::L3_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M2::M3::L3>::insert (
    _tao_any,
    M2::M3::L3::_tao_any_destructor,
    M2::M3::_tc_L3,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M2::M3::L3_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M2::M3::L3>::extract (
        _tao_any,
        M2::M3::L3::_tao_any_destructor,
        M2::M3::_tc_L3,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::AMH_L3ExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::AMH_L3ExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    M2::M3::AMH_L3ExceptionHolder *_tao_copy =
      _tao_elem ?
        M2::M3::AMH_L3ExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::AMH_L3ExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<M2::M3::AMH_L3ExceptionHolder>::insert (
    _tao_any,
    M2::M3::AMH_L3ExceptionHolder::_tao_any_destructor,
    M2::M3::_tc_AMH_L3ExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M2::M3::AMH_L3ExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<M2::M3::AMH_L3ExceptionHolder>::extract (
        _tao_any,
        M2::M3::AMH_L3ExceptionHolder::_tao_any_destructor,
        M2::M3::_tc_AMH_L3ExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::AMH_L3ResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::AMH_L3ResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::AMH_L3ResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::AMH_L3ResponseHandler_ptr _tao_elem)
{
  M2::M3::AMH_L3ResponseHandler_ptr _tao_objptr =
    M2::M3::AMH_L3ResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::AMH_L3ResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M2::M3::AMH_L3ResponseHandler>::insert (
    _tao_any,
    M2::M3::AMH_L3ResponseHandler::_tao_any_destructor,
    M2::M3::_tc_AMH_L3ResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M2::M3::AMH_L3ResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M2::M3::AMH_L3ResponseHandler>::extract (
        _tao_any,
        M2::M3::AMH_L3ResponseHandler::_tao_any_destructor,
        M2::M3::_tc_AMH_L3ResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<M2::M3::E1>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const M2::M3::E1 &_tao_elem)
{
  TAO::Any_Dual_Impl_T<M2::M3::E1>::insert_copy (
    _tao_any,
    M2::M3::E1::_tao_any_destructor,
    M2::M3::_tc_E1,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::E1 *_tao_elem)
{
  TAO::Any_Dual_Impl_T<M2::M3::E1>::insert (
    _tao_any,
    M2::M3::E1::_tao_any_destructor,
    M2::M3::_tc_E1,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const M2::M3::E1 *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<M2::M3::E1>::extract (
    _tao_any,
    M2::M3::E1::_tao_any_destructor,
    M2::M3::_tc_E1,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::L4>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::L4_ptr _tao_elem)
{
  M2::M3::L4_ptr _tao_objptr =
    M2::M3::L4::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::L4_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M2::M3::L4>::insert (
    _tao_any,
    M2::M3::L4::_tao_any_destructor,
    M2::M3::_tc_L4,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M2::M3::L4_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M2::M3::L4>::extract (
        _tao_any,
        M2::M3::L4::_tao_any_destructor,
        M2::M3::_tc_L4,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::AMH_L4ExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::AMH_L4ExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    M2::M3::AMH_L4ExceptionHolder *_tao_copy =
      _tao_elem ?
        M2::M3::AMH_L4ExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::AMH_L4ExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<M2::M3::AMH_L4ExceptionHolder>::insert (
    _tao_any,
    M2::M3::AMH_L4ExceptionHolder::_tao_any_destructor,
    M2::M3::_tc_AMH_L4ExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M2::M3::AMH_L4ExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<M2::M3::AMH_L4ExceptionHolder>::extract (
        _tao_any,
        M2::M3::AMH_L4ExceptionHolder::_tao_any_destructor,
        M2::M3::_tc_AMH_L4ExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::AMH_L4ResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::AMH_L4ResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::AMH_L4ResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::AMH_L4ResponseHandler_ptr _tao_elem)
{
  M2::M3::AMH_L4ResponseHandler_ptr _tao_objptr =
    M2::M3::AMH_L4ResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::AMH_L4ResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M2::M3::AMH_L4ResponseHandler>::insert (
    _tao_any,
    M2::M3::AMH_L4ResponseHandler::_tao_any_destructor,
    M2::M3::_tc_AMH_L4ResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M2::M3::AMH_L4ResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M2::M3::AMH_L4ResponseHandler>::extract (
        _tao_any,
        M2::M3::AMH_L4ResponseHandler::_tao_any_destructor,
        M2::M3::_tc_AMH_L4ResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::V2>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::V2 *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    M2::M3::V2 *_tao_copy =
      _tao_elem ?
        M2::M3::V2::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::V2 **_tao_elem)
{
  TAO::Any_Impl_T<M2::M3::V2>::insert (
    _tao_any,
    M2::M3::V2::_tao_any_destructor,
    M2::M3::_tc_V2,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M2::M3::V2 *&_tao_elem)
{
  return
    TAO::Any_Impl_T<M2::M3::V2>::extract (
        _tao_any,
        M2::M3::V2::_tao_any_destructor,
        M2::M3::_tc_V2,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M2::M3::V3>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::V3 *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    M2::M3::V3 *_tao_copy =
      _tao_elem ?
        M2::M3::V3::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M2::M3::V3 **_tao_elem)
{
  TAO::Any_Impl_T<M2::M3::V3>::insert (
    _tao_any,
    M2::M3::V3::_tao_any_destructor,
    M2::M3::_tc_V3,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M2::M3::V3 *&_tao_elem)
{
  return
    TAO::Any_Impl_T<M2::M3::V3>::extract (
        _tao_any,
        M2::M3::V3::_tao_any_destructor,
        M2::M3::_tc_V3,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M1::S1 &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.o)) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M1::S1 &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.o)) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M1::LI_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M1::LI_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::M1::LI>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (M1::AMH_LIExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (M1::AMH_LIExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const M1::AMH_LIExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&M1::AMH_LIExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    M1::AMH_LIExceptionHolder *&_tao_valuetype)
{
  return M1::AMH_LIExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_M1::AMH_LIExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_M1::AMH_LIExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_M1::AMH_LIExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M1::L2_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M1::L2_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::M1::L2>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (M1::AMH_L2ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (M1::AMH_L2ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const M1::AMH_L2ExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&M1::AMH_L2ExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    M1::AMH_L2ExceptionHolder *&_tao_valuetype)
{
  return M1::AMH_L2ExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_M1::AMH_L2ExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_M1::AMH_L2ExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_M1::AMH_L2ExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M1::X &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.valString.in ()) &&
    (strm << _tao_aggregate.valStruct) &&
    ::CORBA::Object::marshal (
        _tao_aggregate.valLocalIface.in (),
        strm
      ) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M1::X &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.valString.out ()) &&
    (strm >> _tao_aggregate.valStruct) &&
    (strm >> _tao_aggregate.valLocalIface.out ()) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/cdr_op_cs.cpp:119



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M1::BooleanUnion1 &_tao_union)
{
  ::ACE_OutputCDR::from_boolean tmp (_tao_union._d ());
  if (!(strm << tmp))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  if (_tao_union._d ())
    {
      result =
        TAO::Objref_Traits<M1::L2>::marshal (
            _tao_union.valLocalIface (),
            strm
          );
    }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M1::BooleanUnion1 &_tao_union)
{
  CORBA::Boolean _tao_discriminant;
  ::ACE_InputCDR::to_boolean tmp (_tao_discriminant);
  if (!(strm >> tmp))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  _tao_union._default ();
  _tao_union._d (_tao_discriminant);
  if (_tao_discriminant)
    {
      M1::L2_var _tao_union_tmp;
      result = strm >> _tao_union_tmp.inout ();
      if (result)
        {
          _tao_union.valLocalIface (_tao_union_tmp.in ());
          _tao_union._d (_tao_discriminant);
        }
    }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/cdr_op_cs.cpp:119



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M1::BooleanUnion2 &_tao_union)
{
  ::ACE_OutputCDR::from_boolean tmp (_tao_union._d ());
  if (!(strm << tmp))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  if (_tao_union._d ())
    {
      result = strm << _tao_union.valLocalIface ();
    }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M1::BooleanUnion2 &_tao_union)
{
  CORBA::Boolean _tao_discriminant;
  ::ACE_InputCDR::to_boolean tmp (_tao_discriminant);
  if (!(strm >> tmp))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  _tao_union._default ();
  _tao_union._d (_tao_discriminant);
  if (_tao_discriminant)
    {
      ::CORBA::String_var _tao_union_tmp;
      result = strm >> _tao_union_tmp.out ();
      if (result)
        {
          _tao_union.valLocalIface (_tao_union_tmp);
          _tao_union._d (_tao_discriminant);
        }
    }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (M1::V * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (M1::V * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const M1::V *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&M1::V::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    M1::V *&_tao_valuetype)
{
  return M1::V::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_M1::V::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo &ci) const
{
  if (! ci.start_chunk (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm << _pd_valString.in ()) &&
      (strm << _pd_valStruct) &&
      TAO::Objref_Traits< ::M1::LI>::marshal (
          _pd_valLocalIface.in (),
          strm
        ) &&
      (strm << _pd_valBoolUnion1) &&
      (strm << _pd_valBoolUnion2) &&
      (strm << _pd_valX);
  if ( ! ret) 
    return false; 
  
  if (! ci.end_chunk (strm))
    return false;
  
  return true;
}

::CORBA::Boolean
OBV_M1::V::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo &ci)
{
  if (!ci.handle_chunking (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm >> _pd_valString.out ()) &&
      (strm >> _pd_valStruct) &&
      (strm >> _pd_valLocalIface.out ()) &&
      (strm >> _pd_valBoolUnion1) &&
      (strm >> _pd_valBoolUnion2) &&
      (strm >> _pd_valX);
  if (!ret) 
    return false; 
  
  if (this->require_truncation_)
    return ci.skip_chunks (strm);
  
  else
    return ci.handle_chunking (strm);
  
  
}

void
OBV_M1::V::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M2::M3::S2 &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.o)) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M2::M3::S2 &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.o)) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M2::M3::L3_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M2::M3::L3_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::M2::M3::L3>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (M2::M3::AMH_L3ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (M2::M3::AMH_L3ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const M2::M3::AMH_L3ExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&M2::M3::AMH_L3ExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    M2::M3::AMH_L3ExceptionHolder *&_tao_valuetype)
{
  return M2::M3::AMH_L3ExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_M2::M3::AMH_L3ExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_M2::M3::AMH_L3ExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_M2::M3::AMH_L3ExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M2::M3::E1 &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        ::CORBA::Object::marshal (
            _tao_aggregate.val2.in (),
            strm
          ) &&
        (strm << _tao_aggregate.bool1) &&
        (strm << _tao_aggregate.bool2)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M2::M3::E1 &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.val2.out ()) &&
    (strm >> _tao_aggregate.bool1) &&
    (strm >> _tao_aggregate.bool2)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M2::M3::L4_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M2::M3::L4_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::M2::M3::L4>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (M2::M3::AMH_L4ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (M2::M3::AMH_L4ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const M2::M3::AMH_L4ExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&M2::M3::AMH_L4ExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    M2::M3::AMH_L4ExceptionHolder *&_tao_valuetype)
{
  return M2::M3::AMH_L4ExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_M2::M3::AMH_L4ExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_M2::M3::AMH_L4ExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_M2::M3::AMH_L4ExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (M2::M3::V2 * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (M2::M3::V2 * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const M2::M3::V2 *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&M2::M3::V2::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    M2::M3::V2 *&_tao_valuetype)
{
  return M2::M3::V2::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_M2::M3::V2::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo &ci) const
{
  if (! ci.start_chunk (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm << _pd_valString.in ()) &&
      (strm << _pd_valStruct) &&
      TAO::Objref_Traits< ::M2::M3::L3>::marshal (
          _pd_valLocalIface.in (),
          strm
        ) &&
      TAO::Objref_Traits< ::M2::M3::L4>::marshal (
          _pd_valLocalIface3.in (),
          strm
        );
  if ( ! ret) 
    return false; 
  
  if (! ci.end_chunk (strm))
    return false;
  
  return true;
}

::CORBA::Boolean
OBV_M2::M3::V2::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo &ci)
{
  if (!ci.handle_chunking (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm >> _pd_valString.out ()) &&
      (strm >> _pd_valStruct) &&
      (strm >> _pd_valLocalIface.out ()) &&
      (strm >> _pd_valLocalIface3.out ());
  if (!ret) 
    return false; 
  
  if (this->require_truncation_)
    return ci.skip_chunks (strm);
  
  else
    return ci.handle_chunking (strm);
  
  
}

void
OBV_M2::M3::V2::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (M2::M3::V3 * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (M2::M3::V3 * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const M2::M3::V3 *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&M2::M3::V3::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    M2::M3::V3 *&_tao_valuetype)
{
  return M2::M3::V3::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE



// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_M2::M3::V3::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo &ci) const
{
  if (! ci.start_chunk (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm << _pd_valString.in ()) &&
      (strm << _pd_valStruct) &&
      TAO::Objref_Traits< ::M1::L2>::marshal (
          _pd_valLocalIface.in (),
          strm
        );
  if ( ! ret) 
    return false; 
  
  if (! ci.end_chunk (strm))
    return false;
  
  return true;
}

::CORBA::Boolean
OBV_M2::M3::V3::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo &ci)
{
  if (!ci.handle_chunking (strm))
    return false;
  
  CORBA::Boolean const ret = 
      (strm >> _pd_valString.out ()) &&
      (strm >> _pd_valStruct) &&
      (strm >> _pd_valLocalIface.out ());
  if (!ret) 
    return false; 
  
  if (this->require_truncation_)
    return ci.skip_chunks (strm);
  
  else
    return ci.handle_chunking (strm);
  
  
}

void
OBV_M2::M3::V3::truncation_hook ()
{
  this->require_truncation_ = true;
}




END_USER_VERSIONED_NAMESPACE


