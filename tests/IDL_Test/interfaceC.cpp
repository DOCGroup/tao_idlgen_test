// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v4.0.2
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       https://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     https://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_codegen.cpp:372


#include "interfaceC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Messaging/Asynch_Invocation_Adapter.h"
#include "tao/Messaging/ExceptionHolder_i.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Array_Impl_T.h"
#include "cstring"
#include "memory"

#if !defined (__ACE_INLINE__)
#include "interfaceC.inl"
#endif /* !defined INLINE */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Base.

Base_ptr
TAO::Objref_Traits<Base>::duplicate (Base_ptr p)
{
  return Base::_duplicate (p);
}

void
TAO::Objref_Traits<Base>::release (Base_ptr p)
{
  ::CORBA::release (p);
}

Base_ptr
TAO::Objref_Traits<Base>::nil ()
{
  return Base::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Base>::marshal (const Base_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::CORBA::Long
Base::value ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_value",
      10,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
Base::value (
  ::CORBA::Long value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_value)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_value",
      10,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
Base::sendc_set_value (
  ::AMI_BaseHandler_ptr ami_handler,
  ::CORBA::Long value)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_value (value);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_value)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_value",
      10,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_BaseHandler::set_value_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
Base::sendc_get_value (
  ::AMI_BaseHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_value",
      10,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_BaseHandler::get_value_reply_stub
    );
}

Base::Base ()
{
}
void
Base::_tao_any_destructor (void *_tao_void_pointer)
{
  Base *_tao_tmp_pointer =
    static_cast<Base *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Base_ptr
Base::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Base>::narrow (_tao_objref, "IDL:Base:1.0");
}

Base_ptr
Base::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Base>::unchecked_narrow (_tao_objref);
}

Base_ptr
Base::_nil ()
{
  return nullptr;
}

Base_ptr
Base::_duplicate (Base_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Base::_tao_release (Base_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Base::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Base:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Base::_interface_repository_id () const
{
  return "IDL:Base:1.0";
}

const char* Base::_desc_repository_id ()
{
  return "IDL:Base:1.0";
}

const char* Base::_desc_interface_name ()
{
  return "Base";
}

::CORBA::Boolean
Base::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Base (
    ::CORBA::tk_objref,
    "IDL:Base:1.0",
    "Base");
  
::CORBA::TypeCode_ptr const _tc_Base =
  &_tao_tc_Base;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_BaseExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_BaseExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_BaseExceptionHolder:1.0",
    "AMH_BaseExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_BaseExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_BaseExceptionHolder =
  &_tao_tc_AMH_BaseExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_BaseExceptionHolder>::add_ref (AMH_BaseExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_BaseExceptionHolder>::remove_ref (AMH_BaseExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_BaseExceptionHolder>::release (AMH_BaseExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_BaseExceptionHolder *
AMH_BaseExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_BaseExceptionHolder *> (v);
}

const char *
AMH_BaseExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_BaseExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_BaseExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BaseExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_BaseExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_BaseExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_BaseExceptionHolder;
}

AMH_BaseExceptionHolder::~AMH_BaseExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_BaseExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_BaseExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_BaseExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_BaseExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_BaseExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_BaseExceptionHolder::_tao_marshal__AMH_BaseExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_BaseExceptionHolder::_tao_unmarshal__AMH_BaseExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_BaseExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_BaseExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_BaseExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_BaseExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_BaseExceptionHolder::raise_get_value ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_BaseExceptionHolder::raise_set_value ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_BaseExceptionHolder::raise_sendc_set_value ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_BaseExceptionHolder::raise_sendc_get_value ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_BaseResponseHandler.

AMH_BaseResponseHandler_ptr
TAO::Objref_Traits<AMH_BaseResponseHandler>::duplicate (AMH_BaseResponseHandler_ptr p)
{
  return AMH_BaseResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_BaseResponseHandler>::release (AMH_BaseResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_BaseResponseHandler_ptr
TAO::Objref_Traits<AMH_BaseResponseHandler>::nil ()
{
  return AMH_BaseResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_BaseResponseHandler>::marshal (const AMH_BaseResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_BaseResponseHandler::AMH_BaseResponseHandler ()
{}void
AMH_BaseResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BaseResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_BaseResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_BaseResponseHandler_ptr
AMH_BaseResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_BaseResponseHandler::_duplicate (
      dynamic_cast<AMH_BaseResponseHandler_ptr> (_tao_objref));
}

AMH_BaseResponseHandler_ptr
AMH_BaseResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_BaseResponseHandler::_duplicate (
      dynamic_cast<AMH_BaseResponseHandler_ptr> (_tao_objref));
}

AMH_BaseResponseHandler_ptr
AMH_BaseResponseHandler::_nil ()
{
  return nullptr;
}

AMH_BaseResponseHandler_ptr
AMH_BaseResponseHandler::_duplicate (AMH_BaseResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_BaseResponseHandler::_tao_release (AMH_BaseResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_BaseResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_BaseResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_BaseResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_BaseResponseHandler:1.0";
}

const char* AMH_BaseResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_BaseResponseHandler:1.0";
}

const char* AMH_BaseResponseHandler::_desc_interface_name ()
{
  return "AMH_BaseResponseHandler";
}

::CORBA::Boolean
AMH_BaseResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_BaseResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_BaseResponseHandler:1.0",
    "AMH_BaseResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_BaseResponseHandler =
  &_tao_tc_AMH_BaseResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_BaseHandler.

AMI_BaseHandler_ptr
TAO::Objref_Traits<AMI_BaseHandler>::duplicate (AMI_BaseHandler_ptr p)
{
  return AMI_BaseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_BaseHandler>::release (AMI_BaseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_BaseHandler_ptr
TAO::Objref_Traits<AMI_BaseHandler>::nil ()
{
  return AMI_BaseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_BaseHandler>::marshal (const AMI_BaseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_BaseHandler::get_value (
  ::CORBA::Long ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_value",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_BaseHandler::get_value_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_BaseHandler_var _tao_reply_handler_object =
    AMI_BaseHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::Long ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_value (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_value_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_BaseHandler::get_value_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_value_excep",
      15,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_BaseHandler::set_value ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_value",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_BaseHandler::set_value_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_BaseHandler_var _tao_reply_handler_object =
    AMI_BaseHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_value (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_value_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_BaseHandler::set_value_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_value_excep",
      15,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

AMI_BaseHandler::AMI_BaseHandler ()
{
}
void
AMI_BaseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_BaseHandler *_tao_tmp_pointer =
    static_cast<AMI_BaseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_BaseHandler_ptr
AMI_BaseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_BaseHandler>::narrow (_tao_objref, "IDL:AMI_BaseHandler:1.0");
}

AMI_BaseHandler_ptr
AMI_BaseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_BaseHandler>::unchecked_narrow (_tao_objref);
}

AMI_BaseHandler_ptr
AMI_BaseHandler::_nil ()
{
  return nullptr;
}

AMI_BaseHandler_ptr
AMI_BaseHandler::_duplicate (AMI_BaseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_BaseHandler::_tao_release (AMI_BaseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_BaseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_BaseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_BaseHandler::_interface_repository_id () const
{
  return "IDL:AMI_BaseHandler:1.0";
}

const char* AMI_BaseHandler::_desc_repository_id ()
{
  return "IDL:AMI_BaseHandler:1.0";
}

const char* AMI_BaseHandler::_desc_interface_name ()
{
  return "AMI_BaseHandler";
}

::CORBA::Boolean
AMI_BaseHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_BaseHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_BaseHandler:1.0",
    "AMI_BaseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_BaseHandler =
  &_tao_tc_AMI_BaseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Derived.

Derived_ptr
TAO::Objref_Traits<Derived>::duplicate (Derived_ptr p)
{
  return Derived::_duplicate (p);
}

void
TAO::Objref_Traits<Derived>::release (Derived_ptr p)
{
  ::CORBA::release (p);
}

Derived_ptr
TAO::Objref_Traits<Derived>::nil ()
{
  return Derived::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Derived>::marshal (const Derived_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Derived::Derived ()
{
}
void
Derived::_tao_any_destructor (void *_tao_void_pointer)
{
  Derived *_tao_tmp_pointer =
    static_cast<Derived *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Derived_ptr
Derived::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Derived>::narrow (_tao_objref, "IDL:Derived:1.0");
}

Derived_ptr
Derived::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Derived>::unchecked_narrow (_tao_objref);
}

Derived_ptr
Derived::_nil ()
{
  return nullptr;
}

Derived_ptr
Derived::_duplicate (Derived_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Derived::_tao_release (Derived_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Derived::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Base:1.0") == 0 ||
      std::strcmp (value, "IDL:Derived:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Derived::_interface_repository_id () const
{
  return "IDL:Derived:1.0";
}

const char* Derived::_desc_repository_id ()
{
  return "IDL:Derived:1.0";
}

const char* Derived::_desc_interface_name ()
{
  return "Derived";
}

::CORBA::Boolean
Derived::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Derived (
    ::CORBA::tk_objref,
    "IDL:Derived:1.0",
    "Derived");
  
::CORBA::TypeCode_ptr const _tc_Derived =
  &_tao_tc_Derived;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_DerivedExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_DerivedExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_DerivedExceptionHolder:1.0",
    "AMH_DerivedExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_DerivedExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_DerivedExceptionHolder =
  &_tao_tc_AMH_DerivedExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_DerivedExceptionHolder>::add_ref (AMH_DerivedExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_DerivedExceptionHolder>::remove_ref (AMH_DerivedExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_DerivedExceptionHolder>::release (AMH_DerivedExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_DerivedExceptionHolder *
AMH_DerivedExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_DerivedExceptionHolder *> (v);
}

const char *
AMH_DerivedExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_DerivedExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_DerivedExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_DerivedExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_DerivedExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_DerivedExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_DerivedExceptionHolder;
}

AMH_DerivedExceptionHolder::~AMH_DerivedExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_DerivedExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_DerivedExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_DerivedExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_DerivedExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_DerivedExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_DerivedExceptionHolder::_tao_marshal__AMH_DerivedExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_DerivedExceptionHolder::_tao_unmarshal__AMH_DerivedExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_DerivedExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_DerivedExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_DerivedExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_DerivedExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_DerivedExceptionHolder_init::AMH_DerivedExceptionHolder_init ()
{
}

AMH_DerivedExceptionHolder_init::~AMH_DerivedExceptionHolder_init ()
{
}

AMH_DerivedExceptionHolder_init *
AMH_DerivedExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_DerivedExceptionHolder_init *> (v);
}

const char*
AMH_DerivedExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_DerivedExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_DerivedExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_DerivedExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_DerivedResponseHandler.

AMH_DerivedResponseHandler_ptr
TAO::Objref_Traits<AMH_DerivedResponseHandler>::duplicate (AMH_DerivedResponseHandler_ptr p)
{
  return AMH_DerivedResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_DerivedResponseHandler>::release (AMH_DerivedResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_DerivedResponseHandler_ptr
TAO::Objref_Traits<AMH_DerivedResponseHandler>::nil ()
{
  return AMH_DerivedResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_DerivedResponseHandler>::marshal (const AMH_DerivedResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_DerivedResponseHandler::AMH_DerivedResponseHandler ()
{}void
AMH_DerivedResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_DerivedResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_DerivedResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_DerivedResponseHandler_ptr
AMH_DerivedResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_DerivedResponseHandler::_duplicate (
      dynamic_cast<AMH_DerivedResponseHandler_ptr> (_tao_objref));
}

AMH_DerivedResponseHandler_ptr
AMH_DerivedResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_DerivedResponseHandler::_duplicate (
      dynamic_cast<AMH_DerivedResponseHandler_ptr> (_tao_objref));
}

AMH_DerivedResponseHandler_ptr
AMH_DerivedResponseHandler::_nil ()
{
  return nullptr;
}

AMH_DerivedResponseHandler_ptr
AMH_DerivedResponseHandler::_duplicate (AMH_DerivedResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_DerivedResponseHandler::_tao_release (AMH_DerivedResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_DerivedResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_DerivedResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_DerivedResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_DerivedResponseHandler:1.0";
}

const char* AMH_DerivedResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_DerivedResponseHandler:1.0";
}

const char* AMH_DerivedResponseHandler::_desc_interface_name ()
{
  return "AMH_DerivedResponseHandler";
}

::CORBA::Boolean
AMH_DerivedResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_DerivedResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_DerivedResponseHandler:1.0",
    "AMH_DerivedResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_DerivedResponseHandler =
  &_tao_tc_AMH_DerivedResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_DerivedHandler.

AMI_DerivedHandler_ptr
TAO::Objref_Traits<AMI_DerivedHandler>::duplicate (AMI_DerivedHandler_ptr p)
{
  return AMI_DerivedHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_DerivedHandler>::release (AMI_DerivedHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_DerivedHandler_ptr
TAO::Objref_Traits<AMI_DerivedHandler>::nil ()
{
  return AMI_DerivedHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_DerivedHandler>::marshal (const AMI_DerivedHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_DerivedHandler::AMI_DerivedHandler ()
{
}
void
AMI_DerivedHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_DerivedHandler *_tao_tmp_pointer =
    static_cast<AMI_DerivedHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_DerivedHandler_ptr
AMI_DerivedHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_DerivedHandler>::narrow (_tao_objref, "IDL:AMI_DerivedHandler:1.0");
}

AMI_DerivedHandler_ptr
AMI_DerivedHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_DerivedHandler>::unchecked_narrow (_tao_objref);
}

AMI_DerivedHandler_ptr
AMI_DerivedHandler::_nil ()
{
  return nullptr;
}

AMI_DerivedHandler_ptr
AMI_DerivedHandler::_duplicate (AMI_DerivedHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_DerivedHandler::_tao_release (AMI_DerivedHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_DerivedHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_BaseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_DerivedHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_DerivedHandler::_interface_repository_id () const
{
  return "IDL:AMI_DerivedHandler:1.0";
}

const char* AMI_DerivedHandler::_desc_repository_id ()
{
  return "IDL:AMI_DerivedHandler:1.0";
}

const char* AMI_DerivedHandler::_desc_interface_name ()
{
  return "AMI_DerivedHandler";
}

::CORBA::Boolean
AMI_DerivedHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_DerivedHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_DerivedHandler:1.0",
    "AMI_DerivedHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_DerivedHandler =
  &_tao_tc_AMI_DerivedHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_foo_mod_date[] =
      {
        { "month", &CORBA::_tc_short }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_foo_mod_date (
  ::CORBA::tk_struct,
  "IDL:foo_mod/date:1.0",
  "date",
  _tao_fields_foo_mod_date,
  1);


namespace foo_mod
{
  ::CORBA::TypeCode_ptr const _tc_date =
    &_tao_tc_foo_mod_date;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
foo_mod::date::_tao_any_destructor (
    void *_tao_void_pointer)
{
  date *_tao_tmp_pointer =
    static_cast<date *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for foostep.

foostep_ptr
TAO::Objref_Traits<foostep>::duplicate (foostep_ptr p)
{
  return foostep::_duplicate (p);
}

void
TAO::Objref_Traits<foostep>::release (foostep_ptr p)
{
  ::CORBA::release (p);
}

foostep_ptr
TAO::Objref_Traits<foostep>::nil ()
{
  return foostep::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<foostep>::marshal (const foostep_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::foo_mod::date
foostep::getDate ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::foo_mod::date>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "getDate",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
foostep::sendc_getDate (
  ::AMI_foostepHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "getDate",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_foostepHandler::getDate_reply_stub
    );
}

foostep::foostep ()
{
}
void
foostep::_tao_any_destructor (void *_tao_void_pointer)
{
  foostep *_tao_tmp_pointer =
    static_cast<foostep *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

foostep_ptr
foostep::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<foostep>::narrow (_tao_objref, "IDL:foostep:1.0");
}

foostep_ptr
foostep::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<foostep>::unchecked_narrow (_tao_objref);
}

foostep_ptr
foostep::_nil ()
{
  return nullptr;
}

foostep_ptr
foostep::_duplicate (foostep_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
foostep::_tao_release (foostep_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
foostep::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:foostep:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* foostep::_interface_repository_id () const
{
  return "IDL:foostep:1.0";
}

const char* foostep::_desc_repository_id ()
{
  return "IDL:foostep:1.0";
}

const char* foostep::_desc_interface_name ()
{
  return "foostep";
}

::CORBA::Boolean
foostep::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_foostep (
    ::CORBA::tk_objref,
    "IDL:foostep:1.0",
    "foostep");
  
::CORBA::TypeCode_ptr const _tc_foostep =
  &_tao_tc_foostep;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_foostepExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_foostepExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_foostepExceptionHolder:1.0",
    "AMH_foostepExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_foostepExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_foostepExceptionHolder =
  &_tao_tc_AMH_foostepExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_foostepExceptionHolder>::add_ref (AMH_foostepExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_foostepExceptionHolder>::remove_ref (AMH_foostepExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_foostepExceptionHolder>::release (AMH_foostepExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_foostepExceptionHolder *
AMH_foostepExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_foostepExceptionHolder *> (v);
}

const char *
AMH_foostepExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_foostepExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_foostepExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_foostepExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_foostepExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_foostepExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_foostepExceptionHolder;
}

AMH_foostepExceptionHolder::~AMH_foostepExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_foostepExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_foostepExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_foostepExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_foostepExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_foostepExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_foostepExceptionHolder::_tao_marshal__AMH_foostepExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_foostepExceptionHolder::_tao_unmarshal__AMH_foostepExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_foostepExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_foostepExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_foostepExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_foostepExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_foostepExceptionHolder::raise_getDate ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_foostepExceptionHolder::raise_sendc_getDate ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_foostepResponseHandler.

AMH_foostepResponseHandler_ptr
TAO::Objref_Traits<AMH_foostepResponseHandler>::duplicate (AMH_foostepResponseHandler_ptr p)
{
  return AMH_foostepResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_foostepResponseHandler>::release (AMH_foostepResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_foostepResponseHandler_ptr
TAO::Objref_Traits<AMH_foostepResponseHandler>::nil ()
{
  return AMH_foostepResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_foostepResponseHandler>::marshal (const AMH_foostepResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_foostepResponseHandler::AMH_foostepResponseHandler ()
{}void
AMH_foostepResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_foostepResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_foostepResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_foostepResponseHandler_ptr
AMH_foostepResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_foostepResponseHandler::_duplicate (
      dynamic_cast<AMH_foostepResponseHandler_ptr> (_tao_objref));
}

AMH_foostepResponseHandler_ptr
AMH_foostepResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_foostepResponseHandler::_duplicate (
      dynamic_cast<AMH_foostepResponseHandler_ptr> (_tao_objref));
}

AMH_foostepResponseHandler_ptr
AMH_foostepResponseHandler::_nil ()
{
  return nullptr;
}

AMH_foostepResponseHandler_ptr
AMH_foostepResponseHandler::_duplicate (AMH_foostepResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_foostepResponseHandler::_tao_release (AMH_foostepResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_foostepResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_foostepResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_foostepResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_foostepResponseHandler:1.0";
}

const char* AMH_foostepResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_foostepResponseHandler:1.0";
}

const char* AMH_foostepResponseHandler::_desc_interface_name ()
{
  return "AMH_foostepResponseHandler";
}

::CORBA::Boolean
AMH_foostepResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_foostepResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_foostepResponseHandler:1.0",
    "AMH_foostepResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_foostepResponseHandler =
  &_tao_tc_AMH_foostepResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_foostepHandler.

AMI_foostepHandler_ptr
TAO::Objref_Traits<AMI_foostepHandler>::duplicate (AMI_foostepHandler_ptr p)
{
  return AMI_foostepHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_foostepHandler>::release (AMI_foostepHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_foostepHandler_ptr
TAO::Objref_Traits<AMI_foostepHandler>::nil ()
{
  return AMI_foostepHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_foostepHandler>::marshal (const AMI_foostepHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_foostepHandler::getDate (
  const ::foo_mod::date & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::foo_mod::date>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getDate",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_foostepHandler::getDate_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_foostepHandler_var _tao_reply_handler_object =
    AMI_foostepHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::foo_mod::date ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->getDate (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->getDate_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_foostepHandler::getDate_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getDate_excep",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

AMI_foostepHandler::AMI_foostepHandler ()
{
}
void
AMI_foostepHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_foostepHandler *_tao_tmp_pointer =
    static_cast<AMI_foostepHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_foostepHandler_ptr
AMI_foostepHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_foostepHandler>::narrow (_tao_objref, "IDL:AMI_foostepHandler:1.0");
}

AMI_foostepHandler_ptr
AMI_foostepHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_foostepHandler>::unchecked_narrow (_tao_objref);
}

AMI_foostepHandler_ptr
AMI_foostepHandler::_nil ()
{
  return nullptr;
}

AMI_foostepHandler_ptr
AMI_foostepHandler::_duplicate (AMI_foostepHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_foostepHandler::_tao_release (AMI_foostepHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_foostepHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_foostepHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_foostepHandler::_interface_repository_id () const
{
  return "IDL:AMI_foostepHandler:1.0";
}

const char* AMI_foostepHandler::_desc_repository_id ()
{
  return "IDL:AMI_foostepHandler:1.0";
}

const char* AMI_foostepHandler::_desc_interface_name ()
{
  return "AMI_foostepHandler";
}

::CORBA::Boolean
AMI_foostepHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_foostepHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_foostepHandler:1.0",
    "AMI_foostepHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_foostepHandler =
  &_tao_tc_AMI_foostepHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for mother.

mother_ptr
TAO::Objref_Traits<mother>::duplicate (mother_ptr p)
{
  return mother::_duplicate (p);
}

void
TAO::Objref_Traits<mother>::release (mother_ptr p)
{
  ::CORBA::release (p);
}

mother_ptr
TAO::Objref_Traits<mother>::nil ()
{
  return mother::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<mother>::marshal (const mother_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_mother_member[] =
      {
        { "val", &CORBA::_tc_long }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_mother_member (
  ::CORBA::tk_struct,
  "IDL:mother/member:1.0",
  "member",
  _tao_fields_mother_member,
  1);

::CORBA::TypeCode_ptr const mother::_tc_member =
  &_tao_tc_mother_member;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
mother::member::_tao_any_destructor (
    void *_tao_void_pointer)
{
  member *_tao_tmp_pointer =
    static_cast<member *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

mother::mother ()
{
}
void
mother::_tao_any_destructor (void *_tao_void_pointer)
{
  mother *_tao_tmp_pointer =
    static_cast<mother *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

mother_ptr
mother::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<mother>::narrow (_tao_objref, "IDL:mother:1.0");
}

mother_ptr
mother::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<mother>::unchecked_narrow (_tao_objref);
}

mother_ptr
mother::_nil ()
{
  return nullptr;
}

mother_ptr
mother::_duplicate (mother_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
mother::_tao_release (mother_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
mother::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:mother:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* mother::_interface_repository_id () const
{
  return "IDL:mother:1.0";
}

const char* mother::_desc_repository_id ()
{
  return "IDL:mother:1.0";
}

const char* mother::_desc_interface_name ()
{
  return "mother";
}

::CORBA::Boolean
mother::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_mother (
    ::CORBA::tk_objref,
    "IDL:mother:1.0",
    "mother");
  
::CORBA::TypeCode_ptr const _tc_mother =
  &_tao_tc_mother;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_motherExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_motherExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_motherExceptionHolder:1.0",
    "AMH_motherExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_motherExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_motherExceptionHolder =
  &_tao_tc_AMH_motherExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_motherExceptionHolder>::add_ref (AMH_motherExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_motherExceptionHolder>::remove_ref (AMH_motherExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_motherExceptionHolder>::release (AMH_motherExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_motherExceptionHolder *
AMH_motherExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_motherExceptionHolder *> (v);
}

const char *
AMH_motherExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_motherExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_motherExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_motherExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_motherExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_motherExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_motherExceptionHolder;
}

AMH_motherExceptionHolder::~AMH_motherExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_motherExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_motherExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_motherExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_motherExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_motherExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_motherExceptionHolder::_tao_marshal__AMH_motherExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_motherExceptionHolder::_tao_unmarshal__AMH_motherExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_motherExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_motherExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_motherExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_motherExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_motherExceptionHolder_init::AMH_motherExceptionHolder_init ()
{
}

AMH_motherExceptionHolder_init::~AMH_motherExceptionHolder_init ()
{
}

AMH_motherExceptionHolder_init *
AMH_motherExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_motherExceptionHolder_init *> (v);
}

const char*
AMH_motherExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_motherExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_motherExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_motherExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_motherResponseHandler.

AMH_motherResponseHandler_ptr
TAO::Objref_Traits<AMH_motherResponseHandler>::duplicate (AMH_motherResponseHandler_ptr p)
{
  return AMH_motherResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_motherResponseHandler>::release (AMH_motherResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_motherResponseHandler_ptr
TAO::Objref_Traits<AMH_motherResponseHandler>::nil ()
{
  return AMH_motherResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_motherResponseHandler>::marshal (const AMH_motherResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_motherResponseHandler::AMH_motherResponseHandler ()
{}void
AMH_motherResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_motherResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_motherResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_motherResponseHandler_ptr
AMH_motherResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_motherResponseHandler::_duplicate (
      dynamic_cast<AMH_motherResponseHandler_ptr> (_tao_objref));
}

AMH_motherResponseHandler_ptr
AMH_motherResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_motherResponseHandler::_duplicate (
      dynamic_cast<AMH_motherResponseHandler_ptr> (_tao_objref));
}

AMH_motherResponseHandler_ptr
AMH_motherResponseHandler::_nil ()
{
  return nullptr;
}

AMH_motherResponseHandler_ptr
AMH_motherResponseHandler::_duplicate (AMH_motherResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_motherResponseHandler::_tao_release (AMH_motherResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_motherResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_motherResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_motherResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_motherResponseHandler:1.0";
}

const char* AMH_motherResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_motherResponseHandler:1.0";
}

const char* AMH_motherResponseHandler::_desc_interface_name ()
{
  return "AMH_motherResponseHandler";
}

::CORBA::Boolean
AMH_motherResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_motherResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_motherResponseHandler:1.0",
    "AMH_motherResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_motherResponseHandler =
  &_tao_tc_AMH_motherResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_motherHandler.

AMI_motherHandler_ptr
TAO::Objref_Traits<AMI_motherHandler>::duplicate (AMI_motherHandler_ptr p)
{
  return AMI_motherHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_motherHandler>::release (AMI_motherHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_motherHandler_ptr
TAO::Objref_Traits<AMI_motherHandler>::nil ()
{
  return AMI_motherHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_motherHandler>::marshal (const AMI_motherHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_motherHandler::AMI_motherHandler ()
{
}
void
AMI_motherHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_motherHandler *_tao_tmp_pointer =
    static_cast<AMI_motherHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_motherHandler_ptr
AMI_motherHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_motherHandler>::narrow (_tao_objref, "IDL:AMI_motherHandler:1.0");
}

AMI_motherHandler_ptr
AMI_motherHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_motherHandler>::unchecked_narrow (_tao_objref);
}

AMI_motherHandler_ptr
AMI_motherHandler::_nil ()
{
  return nullptr;
}

AMI_motherHandler_ptr
AMI_motherHandler::_duplicate (AMI_motherHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_motherHandler::_tao_release (AMI_motherHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_motherHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_motherHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_motherHandler::_interface_repository_id () const
{
  return "IDL:AMI_motherHandler:1.0";
}

const char* AMI_motherHandler::_desc_repository_id ()
{
  return "IDL:AMI_motherHandler:1.0";
}

const char* AMI_motherHandler::_desc_interface_name ()
{
  return "AMI_motherHandler";
}

::CORBA::Boolean
AMI_motherHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_motherHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_motherHandler:1.0",
    "AMI_motherHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_motherHandler =
  &_tao_tc_AMI_motherHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for father.

father_ptr
TAO::Objref_Traits<father>::duplicate (father_ptr p)
{
  return father::_duplicate (p);
}

void
TAO::Objref_Traits<father>::release (father_ptr p)
{
  ::CORBA::release (p);
}

father_ptr
TAO::Objref_Traits<father>::nil ()
{
  return father::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<father>::marshal (const father_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_father_member[] =
      {
        { "ident", &CORBA::_tc_short }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_father_member (
  ::CORBA::tk_struct,
  "IDL:father/member:1.0",
  "member",
  _tao_fields_father_member,
  1);

::CORBA::TypeCode_ptr const father::_tc_member =
  &_tao_tc_father_member;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
father::member::_tao_any_destructor (
    void *_tao_void_pointer)
{
  member *_tao_tmp_pointer =
    static_cast<member *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

father::father ()
{
}
void
father::_tao_any_destructor (void *_tao_void_pointer)
{
  father *_tao_tmp_pointer =
    static_cast<father *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

father_ptr
father::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<father>::narrow (_tao_objref, "IDL:father:1.0");
}

father_ptr
father::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<father>::unchecked_narrow (_tao_objref);
}

father_ptr
father::_nil ()
{
  return nullptr;
}

father_ptr
father::_duplicate (father_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
father::_tao_release (father_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
father::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:father:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* father::_interface_repository_id () const
{
  return "IDL:father:1.0";
}

const char* father::_desc_repository_id ()
{
  return "IDL:father:1.0";
}

const char* father::_desc_interface_name ()
{
  return "father";
}

::CORBA::Boolean
father::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_father (
    ::CORBA::tk_objref,
    "IDL:father:1.0",
    "father");
  
::CORBA::TypeCode_ptr const _tc_father =
  &_tao_tc_father;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_fatherExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_fatherExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_fatherExceptionHolder:1.0",
    "AMH_fatherExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_fatherExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_fatherExceptionHolder =
  &_tao_tc_AMH_fatherExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_fatherExceptionHolder>::add_ref (AMH_fatherExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_fatherExceptionHolder>::remove_ref (AMH_fatherExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_fatherExceptionHolder>::release (AMH_fatherExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_fatherExceptionHolder *
AMH_fatherExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_fatherExceptionHolder *> (v);
}

const char *
AMH_fatherExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_fatherExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_fatherExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_fatherExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_fatherExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_fatherExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_fatherExceptionHolder;
}

AMH_fatherExceptionHolder::~AMH_fatherExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_fatherExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_fatherExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_fatherExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_fatherExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_fatherExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_fatherExceptionHolder::_tao_marshal__AMH_fatherExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_fatherExceptionHolder::_tao_unmarshal__AMH_fatherExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_fatherExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_fatherExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_fatherExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_fatherExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_fatherExceptionHolder_init::AMH_fatherExceptionHolder_init ()
{
}

AMH_fatherExceptionHolder_init::~AMH_fatherExceptionHolder_init ()
{
}

AMH_fatherExceptionHolder_init *
AMH_fatherExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_fatherExceptionHolder_init *> (v);
}

const char*
AMH_fatherExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_fatherExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_fatherExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_fatherExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_fatherResponseHandler.

AMH_fatherResponseHandler_ptr
TAO::Objref_Traits<AMH_fatherResponseHandler>::duplicate (AMH_fatherResponseHandler_ptr p)
{
  return AMH_fatherResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_fatherResponseHandler>::release (AMH_fatherResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_fatherResponseHandler_ptr
TAO::Objref_Traits<AMH_fatherResponseHandler>::nil ()
{
  return AMH_fatherResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_fatherResponseHandler>::marshal (const AMH_fatherResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_fatherResponseHandler::AMH_fatherResponseHandler ()
{}void
AMH_fatherResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_fatherResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_fatherResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_fatherResponseHandler_ptr
AMH_fatherResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_fatherResponseHandler::_duplicate (
      dynamic_cast<AMH_fatherResponseHandler_ptr> (_tao_objref));
}

AMH_fatherResponseHandler_ptr
AMH_fatherResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_fatherResponseHandler::_duplicate (
      dynamic_cast<AMH_fatherResponseHandler_ptr> (_tao_objref));
}

AMH_fatherResponseHandler_ptr
AMH_fatherResponseHandler::_nil ()
{
  return nullptr;
}

AMH_fatherResponseHandler_ptr
AMH_fatherResponseHandler::_duplicate (AMH_fatherResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_fatherResponseHandler::_tao_release (AMH_fatherResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_fatherResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_fatherResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_fatherResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_fatherResponseHandler:1.0";
}

const char* AMH_fatherResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_fatherResponseHandler:1.0";
}

const char* AMH_fatherResponseHandler::_desc_interface_name ()
{
  return "AMH_fatherResponseHandler";
}

::CORBA::Boolean
AMH_fatherResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_fatherResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_fatherResponseHandler:1.0",
    "AMH_fatherResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_fatherResponseHandler =
  &_tao_tc_AMH_fatherResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_fatherHandler.

AMI_fatherHandler_ptr
TAO::Objref_Traits<AMI_fatherHandler>::duplicate (AMI_fatherHandler_ptr p)
{
  return AMI_fatherHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_fatherHandler>::release (AMI_fatherHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_fatherHandler_ptr
TAO::Objref_Traits<AMI_fatherHandler>::nil ()
{
  return AMI_fatherHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_fatherHandler>::marshal (const AMI_fatherHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_fatherHandler::AMI_fatherHandler ()
{
}
void
AMI_fatherHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_fatherHandler *_tao_tmp_pointer =
    static_cast<AMI_fatherHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_fatherHandler_ptr
AMI_fatherHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_fatherHandler>::narrow (_tao_objref, "IDL:AMI_fatherHandler:1.0");
}

AMI_fatherHandler_ptr
AMI_fatherHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_fatherHandler>::unchecked_narrow (_tao_objref);
}

AMI_fatherHandler_ptr
AMI_fatherHandler::_nil ()
{
  return nullptr;
}

AMI_fatherHandler_ptr
AMI_fatherHandler::_duplicate (AMI_fatherHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_fatherHandler::_tao_release (AMI_fatherHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_fatherHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_fatherHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_fatherHandler::_interface_repository_id () const
{
  return "IDL:AMI_fatherHandler:1.0";
}

const char* AMI_fatherHandler::_desc_repository_id ()
{
  return "IDL:AMI_fatherHandler:1.0";
}

const char* AMI_fatherHandler::_desc_interface_name ()
{
  return "AMI_fatherHandler";
}

::CORBA::Boolean
AMI_fatherHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_fatherHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_fatherHandler:1.0",
    "AMI_fatherHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_fatherHandler =
  &_tao_tc_AMI_fatherHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for child.

child_ptr
TAO::Objref_Traits<child>::duplicate (child_ptr p)
{
  return child::_duplicate (p);
}

void
TAO::Objref_Traits<child>::release (child_ptr p)
{
  ::CORBA::release (p);
}

child_ptr
TAO::Objref_Traits<child>::nil ()
{
  return child::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<child>::marshal (const child_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



child::child ()
{
}
void
child::_tao_any_destructor (void *_tao_void_pointer)
{
  child *_tao_tmp_pointer =
    static_cast<child *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

child_ptr
child::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<child>::narrow (_tao_objref, "IDL:child:1.0");
}

child_ptr
child::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<child>::unchecked_narrow (_tao_objref);
}

child_ptr
child::_nil ()
{
  return nullptr;
}

child_ptr
child::_duplicate (child_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
child::_tao_release (child_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
child::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:mother:1.0") == 0 ||
      std::strcmp (value, "IDL:father:1.0") == 0 ||
      std::strcmp (value, "IDL:child:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* child::_interface_repository_id () const
{
  return "IDL:child:1.0";
}

const char* child::_desc_repository_id ()
{
  return "IDL:child:1.0";
}

const char* child::_desc_interface_name ()
{
  return "child";
}

::CORBA::Boolean
child::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_child (
    ::CORBA::tk_objref,
    "IDL:child:1.0",
    "child");
  
::CORBA::TypeCode_ptr const _tc_child =
  &_tao_tc_child;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_childExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_childExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_childExceptionHolder:1.0",
    "AMH_childExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_childExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_childExceptionHolder =
  &_tao_tc_AMH_childExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_childExceptionHolder>::add_ref (AMH_childExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_childExceptionHolder>::remove_ref (AMH_childExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_childExceptionHolder>::release (AMH_childExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_childExceptionHolder *
AMH_childExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_childExceptionHolder *> (v);
}

const char *
AMH_childExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_childExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_childExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_childExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_childExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_childExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_childExceptionHolder;
}

AMH_childExceptionHolder::~AMH_childExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_childExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_childExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_childExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_childExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_childExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_childExceptionHolder::_tao_marshal__AMH_childExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_childExceptionHolder::_tao_unmarshal__AMH_childExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_childExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_childExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_childExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_childExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_childExceptionHolder_init::AMH_childExceptionHolder_init ()
{
}

AMH_childExceptionHolder_init::~AMH_childExceptionHolder_init ()
{
}

AMH_childExceptionHolder_init *
AMH_childExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_childExceptionHolder_init *> (v);
}

const char*
AMH_childExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_childExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_childExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_childExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_childResponseHandler.

AMH_childResponseHandler_ptr
TAO::Objref_Traits<AMH_childResponseHandler>::duplicate (AMH_childResponseHandler_ptr p)
{
  return AMH_childResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_childResponseHandler>::release (AMH_childResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_childResponseHandler_ptr
TAO::Objref_Traits<AMH_childResponseHandler>::nil ()
{
  return AMH_childResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_childResponseHandler>::marshal (const AMH_childResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_childResponseHandler::AMH_childResponseHandler ()
{}void
AMH_childResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_childResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_childResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_childResponseHandler_ptr
AMH_childResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_childResponseHandler::_duplicate (
      dynamic_cast<AMH_childResponseHandler_ptr> (_tao_objref));
}

AMH_childResponseHandler_ptr
AMH_childResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_childResponseHandler::_duplicate (
      dynamic_cast<AMH_childResponseHandler_ptr> (_tao_objref));
}

AMH_childResponseHandler_ptr
AMH_childResponseHandler::_nil ()
{
  return nullptr;
}

AMH_childResponseHandler_ptr
AMH_childResponseHandler::_duplicate (AMH_childResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_childResponseHandler::_tao_release (AMH_childResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_childResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_childResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_childResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_childResponseHandler:1.0";
}

const char* AMH_childResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_childResponseHandler:1.0";
}

const char* AMH_childResponseHandler::_desc_interface_name ()
{
  return "AMH_childResponseHandler";
}

::CORBA::Boolean
AMH_childResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_childResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_childResponseHandler:1.0",
    "AMH_childResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_childResponseHandler =
  &_tao_tc_AMH_childResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_childHandler.

AMI_childHandler_ptr
TAO::Objref_Traits<AMI_childHandler>::duplicate (AMI_childHandler_ptr p)
{
  return AMI_childHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_childHandler>::release (AMI_childHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_childHandler_ptr
TAO::Objref_Traits<AMI_childHandler>::nil ()
{
  return AMI_childHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_childHandler>::marshal (const AMI_childHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_childHandler::AMI_childHandler ()
{
}
void
AMI_childHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_childHandler *_tao_tmp_pointer =
    static_cast<AMI_childHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_childHandler_ptr
AMI_childHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_childHandler>::narrow (_tao_objref, "IDL:AMI_childHandler:1.0");
}

AMI_childHandler_ptr
AMI_childHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_childHandler>::unchecked_narrow (_tao_objref);
}

AMI_childHandler_ptr
AMI_childHandler::_nil ()
{
  return nullptr;
}

AMI_childHandler_ptr
AMI_childHandler::_duplicate (AMI_childHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_childHandler::_tao_release (AMI_childHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_childHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_motherHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_fatherHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_childHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_childHandler::_interface_repository_id () const
{
  return "IDL:AMI_childHandler:1.0";
}

const char* AMI_childHandler::_desc_repository_id ()
{
  return "IDL:AMI_childHandler:1.0";
}

const char* AMI_childHandler::_desc_interface_name ()
{
  return "AMI_childHandler";
}

::CORBA::Boolean
AMI_childHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_childHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_childHandler:1.0",
    "AMI_childHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_childHandler =
  &_tao_tc_AMI_childHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for _cxx_try.

_cxx_try_ptr
TAO::Objref_Traits<_cxx_try>::duplicate (_cxx_try_ptr p)
{
  return _cxx_try::_duplicate (p);
}

void
TAO::Objref_Traits<_cxx_try>::release (_cxx_try_ptr p)
{
  ::CORBA::release (p);
}

_cxx_try_ptr
TAO::Objref_Traits<_cxx_try>::nil ()
{
  return _cxx_try::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<_cxx_try>::marshal (const _cxx_try_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



_cxx_try::_cxx_try ()
{
}
void
_cxx_try::_tao_any_destructor (void *_tao_void_pointer)
{
  _cxx_try *_tao_tmp_pointer =
    static_cast<_cxx_try *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

_cxx_try_ptr
_cxx_try::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<_cxx_try>::narrow (_tao_objref, "IDL:try:1.0");
}

_cxx_try_ptr
_cxx_try::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<_cxx_try>::unchecked_narrow (_tao_objref);
}

_cxx_try_ptr
_cxx_try::_nil ()
{
  return nullptr;
}

_cxx_try_ptr
_cxx_try::_duplicate (_cxx_try_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
_cxx_try::_tao_release (_cxx_try_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
_cxx_try::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:try:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* _cxx_try::_interface_repository_id () const
{
  return "IDL:try:1.0";
}

const char* _cxx_try::_desc_repository_id ()
{
  return "IDL:try:1.0";
}

const char* _cxx_try::_desc_interface_name ()
{
  return "_cxx_try";
}

::CORBA::Boolean
_cxx_try::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_try (
    ::CORBA::tk_objref,
    "IDL:try:1.0",
    "try");
  
::CORBA::TypeCode_ptr const _tc__cxx_try =
  &_tao_tc_try;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH__cxx_tryExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH__cxx_tryExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH__cxx_tryExceptionHolder:1.0",
    "AMH__cxx_tryExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH__cxx_tryExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH__cxx_tryExceptionHolder =
  &_tao_tc_AMH__cxx_tryExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH__cxx_tryExceptionHolder>::add_ref (AMH__cxx_tryExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH__cxx_tryExceptionHolder>::remove_ref (AMH__cxx_tryExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH__cxx_tryExceptionHolder>::release (AMH__cxx_tryExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH__cxx_tryExceptionHolder *
AMH__cxx_tryExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH__cxx_tryExceptionHolder *> (v);
}

const char *
AMH__cxx_tryExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH__cxx_tryExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH__cxx_tryExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH__cxx_tryExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH__cxx_tryExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH__cxx_tryExceptionHolder::_tao_type () const
{
  return ::_tc_AMH__cxx_tryExceptionHolder;
}

AMH__cxx_tryExceptionHolder::~AMH__cxx_tryExceptionHolder ()
{}

::CORBA::ValueBase *
AMH__cxx_tryExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH__cxx_tryExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH__cxx_tryExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH__cxx_tryExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH__cxx_tryExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH__cxx_tryExceptionHolder::_tao_marshal__AMH__cxx_tryExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH__cxx_tryExceptionHolder::_tao_unmarshal__AMH__cxx_tryExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH__cxx_tryExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH__cxx_tryExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH__cxx_tryExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH__cxx_tryExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH__cxx_tryExceptionHolder_init::AMH__cxx_tryExceptionHolder_init ()
{
}

AMH__cxx_tryExceptionHolder_init::~AMH__cxx_tryExceptionHolder_init ()
{
}

AMH__cxx_tryExceptionHolder_init *
AMH__cxx_tryExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH__cxx_tryExceptionHolder_init *> (v);
}

const char*
AMH__cxx_tryExceptionHolder_init::tao_repository_id ()
{
  return ::AMH__cxx_tryExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH__cxx_tryExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH__cxx_tryExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH__cxx_tryResponseHandler.

AMH__cxx_tryResponseHandler_ptr
TAO::Objref_Traits<AMH__cxx_tryResponseHandler>::duplicate (AMH__cxx_tryResponseHandler_ptr p)
{
  return AMH__cxx_tryResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH__cxx_tryResponseHandler>::release (AMH__cxx_tryResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH__cxx_tryResponseHandler_ptr
TAO::Objref_Traits<AMH__cxx_tryResponseHandler>::nil ()
{
  return AMH__cxx_tryResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH__cxx_tryResponseHandler>::marshal (const AMH__cxx_tryResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH__cxx_tryResponseHandler::AMH__cxx_tryResponseHandler ()
{}void
AMH__cxx_tryResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH__cxx_tryResponseHandler *_tao_tmp_pointer =
    static_cast<AMH__cxx_tryResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH__cxx_tryResponseHandler_ptr
AMH__cxx_tryResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH__cxx_tryResponseHandler::_duplicate (
      dynamic_cast<AMH__cxx_tryResponseHandler_ptr> (_tao_objref));
}

AMH__cxx_tryResponseHandler_ptr
AMH__cxx_tryResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH__cxx_tryResponseHandler::_duplicate (
      dynamic_cast<AMH__cxx_tryResponseHandler_ptr> (_tao_objref));
}

AMH__cxx_tryResponseHandler_ptr
AMH__cxx_tryResponseHandler::_nil ()
{
  return nullptr;
}

AMH__cxx_tryResponseHandler_ptr
AMH__cxx_tryResponseHandler::_duplicate (AMH__cxx_tryResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH__cxx_tryResponseHandler::_tao_release (AMH__cxx_tryResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH__cxx_tryResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH__cxx_tryResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH__cxx_tryResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH__cxx_tryResponseHandler:1.0";
}

const char* AMH__cxx_tryResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH__cxx_tryResponseHandler:1.0";
}

const char* AMH__cxx_tryResponseHandler::_desc_interface_name ()
{
  return "AMH__cxx_tryResponseHandler";
}

::CORBA::Boolean
AMH__cxx_tryResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH__cxx_tryResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH__cxx_tryResponseHandler:1.0",
    "AMH__cxx_tryResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH__cxx_tryResponseHandler =
  &_tao_tc_AMH__cxx_tryResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI__cxx_tryHandler.

AMI__cxx_tryHandler_ptr
TAO::Objref_Traits<AMI__cxx_tryHandler>::duplicate (AMI__cxx_tryHandler_ptr p)
{
  return AMI__cxx_tryHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI__cxx_tryHandler>::release (AMI__cxx_tryHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI__cxx_tryHandler_ptr
TAO::Objref_Traits<AMI__cxx_tryHandler>::nil ()
{
  return AMI__cxx_tryHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI__cxx_tryHandler>::marshal (const AMI__cxx_tryHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI__cxx_tryHandler::AMI__cxx_tryHandler ()
{
}
void
AMI__cxx_tryHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI__cxx_tryHandler *_tao_tmp_pointer =
    static_cast<AMI__cxx_tryHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI__cxx_tryHandler_ptr
AMI__cxx_tryHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI__cxx_tryHandler>::narrow (_tao_objref, "IDL:AMI__cxx_tryHandler:1.0");
}

AMI__cxx_tryHandler_ptr
AMI__cxx_tryHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI__cxx_tryHandler>::unchecked_narrow (_tao_objref);
}

AMI__cxx_tryHandler_ptr
AMI__cxx_tryHandler::_nil ()
{
  return nullptr;
}

AMI__cxx_tryHandler_ptr
AMI__cxx_tryHandler::_duplicate (AMI__cxx_tryHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI__cxx_tryHandler::_tao_release (AMI__cxx_tryHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI__cxx_tryHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI__cxx_tryHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI__cxx_tryHandler::_interface_repository_id () const
{
  return "IDL:AMI__cxx_tryHandler:1.0";
}

const char* AMI__cxx_tryHandler::_desc_repository_id ()
{
  return "IDL:AMI__cxx_tryHandler:1.0";
}

const char* AMI__cxx_tryHandler::_desc_interface_name ()
{
  return "AMI__cxx_tryHandler";
}

::CORBA::Boolean
AMI__cxx_tryHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI__cxx_tryHandler (
    ::CORBA::tk_objref,
    "IDL:AMI__cxx_tryHandler:1.0",
    "AMI__cxx_tryHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI__cxx_tryHandler =
  &_tao_tc_AMI__cxx_tryHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Bool (
    ::CORBA::tk_alias,
    "IDL:Bool:1.0",
    "Bool",
    &CORBA::_tc_boolean);
  
::CORBA::TypeCode_ptr const _tc_Bool =
  &_tao_tc_Bool;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for later_user.

later_user_ptr
TAO::Objref_Traits<later_user>::duplicate (later_user_ptr p)
{
  return later_user::_duplicate (p);
}

void
TAO::Objref_Traits<later_user>::release (later_user_ptr p)
{
  ::CORBA::release (p);
}

later_user_ptr
TAO::Objref_Traits<later_user>::nil ()
{
  return later_user::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<later_user>::marshal (const later_user_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::later_ptr
later_user::op (
  ::later_ptr inarg,
  ::later_ptr & inoutarg,
  ::later_out outarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::later>::ret_val _tao_retval;
  TAO::Arg_Traits< ::later>::in_arg_val _tao_inarg (inarg);
  TAO::Arg_Traits< ::later>::inout_arg_val _tao_inoutarg (inoutarg);
  TAO::Arg_Traits< ::later>::out_arg_val _tao_outarg (outarg);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_inarg),
      std::addressof(_tao_inoutarg),
      std::addressof(_tao_outarg)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      4,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
later_user::op2 (
  ::Bool inarg2)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_inarg2 (inarg2);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_inarg2)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op2",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
later_user::sendc_op (
  ::AMI_later_userHandler_ptr ami_handler,
  ::later_ptr inarg,
  ::later_ptr inoutarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::later>::in_arg_val _tao_inarg (inarg);
  TAO::Arg_Traits< ::later>::in_arg_val _tao_inoutarg (inoutarg);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_inarg),
      std::addressof(_tao_inoutarg)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      3,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_later_userHandler::op_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
later_user::sendc_op2 (
  ::AMI_later_userHandler_ptr ami_handler,
  ::Bool inarg2)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_inarg2 (inarg2);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_inarg2)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op2",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_later_userHandler::op2_reply_stub
    );
}

later_user::later_user ()
{
}
void
later_user::_tao_any_destructor (void *_tao_void_pointer)
{
  later_user *_tao_tmp_pointer =
    static_cast<later_user *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

later_user_ptr
later_user::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<later_user>::narrow (_tao_objref, "IDL:later_user:1.0");
}

later_user_ptr
later_user::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<later_user>::unchecked_narrow (_tao_objref);
}

later_user_ptr
later_user::_nil ()
{
  return nullptr;
}

later_user_ptr
later_user::_duplicate (later_user_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
later_user::_tao_release (later_user_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
later_user::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:later_user:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* later_user::_interface_repository_id () const
{
  return "IDL:later_user:1.0";
}

const char* later_user::_desc_repository_id ()
{
  return "IDL:later_user:1.0";
}

const char* later_user::_desc_interface_name ()
{
  return "later_user";
}

::CORBA::Boolean
later_user::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_later_user (
    ::CORBA::tk_objref,
    "IDL:later_user:1.0",
    "later_user");
  
::CORBA::TypeCode_ptr const _tc_later_user =
  &_tao_tc_later_user;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_later_userExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_later_userExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_later_userExceptionHolder:1.0",
    "AMH_later_userExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_later_userExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_later_userExceptionHolder =
  &_tao_tc_AMH_later_userExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_later_userExceptionHolder>::add_ref (AMH_later_userExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_later_userExceptionHolder>::remove_ref (AMH_later_userExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_later_userExceptionHolder>::release (AMH_later_userExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_later_userExceptionHolder *
AMH_later_userExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_later_userExceptionHolder *> (v);
}

const char *
AMH_later_userExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_later_userExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_later_userExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_later_userExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_later_userExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_later_userExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_later_userExceptionHolder;
}

AMH_later_userExceptionHolder::~AMH_later_userExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_later_userExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_later_userExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_later_userExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_later_userExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_later_userExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_later_userExceptionHolder::_tao_marshal__AMH_later_userExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_later_userExceptionHolder::_tao_unmarshal__AMH_later_userExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_later_userExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_later_userExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_later_userExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_later_userExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_later_userExceptionHolder::raise_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_later_userExceptionHolder::raise_op2 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_later_userExceptionHolder::raise_sendc_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_later_userExceptionHolder::raise_sendc_op2 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_later_userResponseHandler.

AMH_later_userResponseHandler_ptr
TAO::Objref_Traits<AMH_later_userResponseHandler>::duplicate (AMH_later_userResponseHandler_ptr p)
{
  return AMH_later_userResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_later_userResponseHandler>::release (AMH_later_userResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_later_userResponseHandler_ptr
TAO::Objref_Traits<AMH_later_userResponseHandler>::nil ()
{
  return AMH_later_userResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_later_userResponseHandler>::marshal (const AMH_later_userResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_later_userResponseHandler::AMH_later_userResponseHandler ()
{}void
AMH_later_userResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_later_userResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_later_userResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_later_userResponseHandler_ptr
AMH_later_userResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_later_userResponseHandler::_duplicate (
      dynamic_cast<AMH_later_userResponseHandler_ptr> (_tao_objref));
}

AMH_later_userResponseHandler_ptr
AMH_later_userResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_later_userResponseHandler::_duplicate (
      dynamic_cast<AMH_later_userResponseHandler_ptr> (_tao_objref));
}

AMH_later_userResponseHandler_ptr
AMH_later_userResponseHandler::_nil ()
{
  return nullptr;
}

AMH_later_userResponseHandler_ptr
AMH_later_userResponseHandler::_duplicate (AMH_later_userResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_later_userResponseHandler::_tao_release (AMH_later_userResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_later_userResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_later_userResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_later_userResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_later_userResponseHandler:1.0";
}

const char* AMH_later_userResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_later_userResponseHandler:1.0";
}

const char* AMH_later_userResponseHandler::_desc_interface_name ()
{
  return "AMH_later_userResponseHandler";
}

::CORBA::Boolean
AMH_later_userResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_later_userResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_later_userResponseHandler:1.0",
    "AMH_later_userResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_later_userResponseHandler =
  &_tao_tc_AMH_later_userResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_later_userHandler.

AMI_later_userHandler_ptr
TAO::Objref_Traits<AMI_later_userHandler>::duplicate (AMI_later_userHandler_ptr p)
{
  return AMI_later_userHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_later_userHandler>::release (AMI_later_userHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_later_userHandler_ptr
TAO::Objref_Traits<AMI_later_userHandler>::nil ()
{
  return AMI_later_userHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_later_userHandler>::marshal (const AMI_later_userHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_later_userHandler::op (
  ::later_ptr ami_return_val,
  ::later_ptr inoutarg,
  ::later_ptr outarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::later>::in_arg_val _tao_ami_return_val (ami_return_val);
  TAO::Arg_Traits< ::later>::in_arg_val _tao_inoutarg (inoutarg);
  TAO::Arg_Traits< ::later>::in_arg_val _tao_outarg (outarg);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val),
      std::addressof(_tao_inoutarg),
      std::addressof(_tao_outarg)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      4,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_later_userHandler::op_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_later_userHandler_var _tao_reply_handler_object =
    AMI_later_userHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::later_var ami_return_val;
      ::later_var inoutarg;
      ::later_var outarg;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ()) &&
            (_tao_in >> inoutarg.out ()) &&
            (_tao_in >> outarg.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->op (
          
          ami_return_val.in (),
          
          inoutarg.in (),
          
          outarg.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->op_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_later_userHandler::op_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op_excep",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_later_userHandler::op2 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "op2",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_later_userHandler::op2_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_later_userHandler_var _tao_reply_handler_object =
    AMI_later_userHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->op2 (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->op2_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_later_userHandler::op2_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op2_excep",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

AMI_later_userHandler::AMI_later_userHandler ()
{
}
void
AMI_later_userHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_later_userHandler *_tao_tmp_pointer =
    static_cast<AMI_later_userHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_later_userHandler_ptr
AMI_later_userHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_later_userHandler>::narrow (_tao_objref, "IDL:AMI_later_userHandler:1.0");
}

AMI_later_userHandler_ptr
AMI_later_userHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_later_userHandler>::unchecked_narrow (_tao_objref);
}

AMI_later_userHandler_ptr
AMI_later_userHandler::_nil ()
{
  return nullptr;
}

AMI_later_userHandler_ptr
AMI_later_userHandler::_duplicate (AMI_later_userHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_later_userHandler::_tao_release (AMI_later_userHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_later_userHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_later_userHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_later_userHandler::_interface_repository_id () const
{
  return "IDL:AMI_later_userHandler:1.0";
}

const char* AMI_later_userHandler::_desc_repository_id ()
{
  return "IDL:AMI_later_userHandler:1.0";
}

const char* AMI_later_userHandler::_desc_interface_name ()
{
  return "AMI_later_userHandler";
}

::CORBA::Boolean
AMI_later_userHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_later_userHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_later_userHandler:1.0",
    "AMI_later_userHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_later_userHandler =
  &_tao_tc_AMI_later_userHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_later_holder[] =
      {
        { "member", &_tc_later }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_later_holder (
  ::CORBA::tk_struct,
  "IDL:later_holder:1.0",
  "later_holder",
  _tao_fields_later_holder,
  1);

::CORBA::TypeCode_ptr const _tc_later_holder =
  &_tao_tc_later_holder;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
later_holder::_tao_any_destructor (
    void *_tao_void_pointer)
{
  later_holder *_tao_tmp_pointer =
    static_cast<later_holder *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for later.

later_ptr
TAO::Objref_Traits<later>::duplicate (later_ptr p)
{
  return later::_duplicate (p);
}

void
TAO::Objref_Traits<later>::release (later_ptr p)
{
  ::CORBA::release (p);
}

later_ptr
TAO::Objref_Traits<later>::nil ()
{
  return later::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<later>::marshal (const later_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



later::later ()
{
}
void
later::_tao_any_destructor (void *_tao_void_pointer)
{
  later *_tao_tmp_pointer =
    static_cast<later *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

later_ptr
later::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<later>::narrow (_tao_objref, "IDL:later:1.0");
}

later_ptr
later::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<later>::unchecked_narrow (_tao_objref);
}

later_ptr
later::_nil ()
{
  return nullptr;
}

later_ptr
later::_duplicate (later_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
later::_tao_release (later_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
later::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:later:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* later::_interface_repository_id () const
{
  return "IDL:later:1.0";
}

const char* later::_desc_repository_id ()
{
  return "IDL:later:1.0";
}

const char* later::_desc_interface_name ()
{
  return "later";
}

::CORBA::Boolean
later::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_later (
    ::CORBA::tk_objref,
    "IDL:later:1.0",
    "later");
  
::CORBA::TypeCode_ptr const _tc_later =
  &_tao_tc_later;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_laterExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_laterExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_laterExceptionHolder:1.0",
    "AMH_laterExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_laterExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_laterExceptionHolder =
  &_tao_tc_AMH_laterExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_laterExceptionHolder>::add_ref (AMH_laterExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_laterExceptionHolder>::remove_ref (AMH_laterExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_laterExceptionHolder>::release (AMH_laterExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_laterExceptionHolder *
AMH_laterExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_laterExceptionHolder *> (v);
}

const char *
AMH_laterExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_laterExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_laterExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_laterExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_laterExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_laterExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_laterExceptionHolder;
}

AMH_laterExceptionHolder::~AMH_laterExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_laterExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_laterExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_laterExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_laterExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_laterExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_laterExceptionHolder::_tao_marshal__AMH_laterExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_laterExceptionHolder::_tao_unmarshal__AMH_laterExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_laterExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_laterExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_laterExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_laterExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_laterExceptionHolder_init::AMH_laterExceptionHolder_init ()
{
}

AMH_laterExceptionHolder_init::~AMH_laterExceptionHolder_init ()
{
}

AMH_laterExceptionHolder_init *
AMH_laterExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_laterExceptionHolder_init *> (v);
}

const char*
AMH_laterExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_laterExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_laterExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_laterExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_laterResponseHandler.

AMH_laterResponseHandler_ptr
TAO::Objref_Traits<AMH_laterResponseHandler>::duplicate (AMH_laterResponseHandler_ptr p)
{
  return AMH_laterResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_laterResponseHandler>::release (AMH_laterResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_laterResponseHandler_ptr
TAO::Objref_Traits<AMH_laterResponseHandler>::nil ()
{
  return AMH_laterResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_laterResponseHandler>::marshal (const AMH_laterResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_laterResponseHandler::AMH_laterResponseHandler ()
{}void
AMH_laterResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_laterResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_laterResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_laterResponseHandler_ptr
AMH_laterResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_laterResponseHandler::_duplicate (
      dynamic_cast<AMH_laterResponseHandler_ptr> (_tao_objref));
}

AMH_laterResponseHandler_ptr
AMH_laterResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_laterResponseHandler::_duplicate (
      dynamic_cast<AMH_laterResponseHandler_ptr> (_tao_objref));
}

AMH_laterResponseHandler_ptr
AMH_laterResponseHandler::_nil ()
{
  return nullptr;
}

AMH_laterResponseHandler_ptr
AMH_laterResponseHandler::_duplicate (AMH_laterResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_laterResponseHandler::_tao_release (AMH_laterResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_laterResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_laterResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_laterResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_laterResponseHandler:1.0";
}

const char* AMH_laterResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_laterResponseHandler:1.0";
}

const char* AMH_laterResponseHandler::_desc_interface_name ()
{
  return "AMH_laterResponseHandler";
}

::CORBA::Boolean
AMH_laterResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_laterResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_laterResponseHandler:1.0",
    "AMH_laterResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_laterResponseHandler =
  &_tao_tc_AMH_laterResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_laterHandler.

AMI_laterHandler_ptr
TAO::Objref_Traits<AMI_laterHandler>::duplicate (AMI_laterHandler_ptr p)
{
  return AMI_laterHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_laterHandler>::release (AMI_laterHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_laterHandler_ptr
TAO::Objref_Traits<AMI_laterHandler>::nil ()
{
  return AMI_laterHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_laterHandler>::marshal (const AMI_laterHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_laterHandler::AMI_laterHandler ()
{
}
void
AMI_laterHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_laterHandler *_tao_tmp_pointer =
    static_cast<AMI_laterHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_laterHandler_ptr
AMI_laterHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_laterHandler>::narrow (_tao_objref, "IDL:AMI_laterHandler:1.0");
}

AMI_laterHandler_ptr
AMI_laterHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_laterHandler>::unchecked_narrow (_tao_objref);
}

AMI_laterHandler_ptr
AMI_laterHandler::_nil ()
{
  return nullptr;
}

AMI_laterHandler_ptr
AMI_laterHandler::_duplicate (AMI_laterHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_laterHandler::_tao_release (AMI_laterHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_laterHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_laterHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_laterHandler::_interface_repository_id () const
{
  return "IDL:AMI_laterHandler:1.0";
}

const char* AMI_laterHandler::_desc_repository_id ()
{
  return "IDL:AMI_laterHandler:1.0";
}

const char* AMI_laterHandler::_desc_interface_name ()
{
  return "AMI_laterHandler";
}

::CORBA::Boolean
AMI_laterHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_laterHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_laterHandler:1.0",
    "AMI_laterHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_laterHandler =
  &_tao_tc_AMI_laterHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Begin.

Begin_ptr
TAO::Objref_Traits<Begin>::duplicate (Begin_ptr p)
{
  return Begin::_duplicate (p);
}

void
TAO::Objref_Traits<Begin>::release (Begin_ptr p)
{
  ::CORBA::release (p);
}

Begin_ptr
TAO::Objref_Traits<Begin>::nil ()
{
  return Begin::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Begin>::marshal (const Begin_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Begin_Value (
    ::CORBA::tk_alias,
    "IDL:Begin/Value:1.0",
    "Value",
    &CORBA::_tc_long);
  
::CORBA::TypeCode_ptr const Begin::_tc_Value =
  &_tao_tc_Begin_Value;

Begin::Begin ()
{
}
void
Begin::_tao_any_destructor (void *_tao_void_pointer)
{
  Begin *_tao_tmp_pointer =
    static_cast<Begin *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Begin_ptr
Begin::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Begin>::narrow (_tao_objref, "IDL:Begin:1.0");
}

Begin_ptr
Begin::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Begin>::unchecked_narrow (_tao_objref);
}

Begin_ptr
Begin::_nil ()
{
  return nullptr;
}

Begin_ptr
Begin::_duplicate (Begin_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Begin::_tao_release (Begin_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Begin::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Begin:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Begin::_interface_repository_id () const
{
  return "IDL:Begin:1.0";
}

const char* Begin::_desc_repository_id ()
{
  return "IDL:Begin:1.0";
}

const char* Begin::_desc_interface_name ()
{
  return "Begin";
}

::CORBA::Boolean
Begin::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Begin (
    ::CORBA::tk_objref,
    "IDL:Begin:1.0",
    "Begin");
  
::CORBA::TypeCode_ptr const _tc_Begin =
  &_tao_tc_Begin;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_BeginExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_BeginExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_BeginExceptionHolder:1.0",
    "AMH_BeginExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_BeginExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_BeginExceptionHolder =
  &_tao_tc_AMH_BeginExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_BeginExceptionHolder>::add_ref (AMH_BeginExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_BeginExceptionHolder>::remove_ref (AMH_BeginExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_BeginExceptionHolder>::release (AMH_BeginExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_BeginExceptionHolder *
AMH_BeginExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_BeginExceptionHolder *> (v);
}

const char *
AMH_BeginExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_BeginExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_BeginExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BeginExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_BeginExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_BeginExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_BeginExceptionHolder;
}

AMH_BeginExceptionHolder::~AMH_BeginExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_BeginExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_BeginExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_BeginExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_BeginExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_BeginExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_BeginExceptionHolder::_tao_marshal__AMH_BeginExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_BeginExceptionHolder::_tao_unmarshal__AMH_BeginExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_BeginExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_BeginExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_BeginExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_BeginExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_BeginExceptionHolder_init::AMH_BeginExceptionHolder_init ()
{
}

AMH_BeginExceptionHolder_init::~AMH_BeginExceptionHolder_init ()
{
}

AMH_BeginExceptionHolder_init *
AMH_BeginExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_BeginExceptionHolder_init *> (v);
}

const char*
AMH_BeginExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_BeginExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_BeginExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_BeginExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_BeginResponseHandler.

AMH_BeginResponseHandler_ptr
TAO::Objref_Traits<AMH_BeginResponseHandler>::duplicate (AMH_BeginResponseHandler_ptr p)
{
  return AMH_BeginResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_BeginResponseHandler>::release (AMH_BeginResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_BeginResponseHandler_ptr
TAO::Objref_Traits<AMH_BeginResponseHandler>::nil ()
{
  return AMH_BeginResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_BeginResponseHandler>::marshal (const AMH_BeginResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_BeginResponseHandler::AMH_BeginResponseHandler ()
{}void
AMH_BeginResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BeginResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_BeginResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_BeginResponseHandler_ptr
AMH_BeginResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_BeginResponseHandler::_duplicate (
      dynamic_cast<AMH_BeginResponseHandler_ptr> (_tao_objref));
}

AMH_BeginResponseHandler_ptr
AMH_BeginResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_BeginResponseHandler::_duplicate (
      dynamic_cast<AMH_BeginResponseHandler_ptr> (_tao_objref));
}

AMH_BeginResponseHandler_ptr
AMH_BeginResponseHandler::_nil ()
{
  return nullptr;
}

AMH_BeginResponseHandler_ptr
AMH_BeginResponseHandler::_duplicate (AMH_BeginResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_BeginResponseHandler::_tao_release (AMH_BeginResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_BeginResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_BeginResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_BeginResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_BeginResponseHandler:1.0";
}

const char* AMH_BeginResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_BeginResponseHandler:1.0";
}

const char* AMH_BeginResponseHandler::_desc_interface_name ()
{
  return "AMH_BeginResponseHandler";
}

::CORBA::Boolean
AMH_BeginResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_BeginResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_BeginResponseHandler:1.0",
    "AMH_BeginResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_BeginResponseHandler =
  &_tao_tc_AMH_BeginResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_BeginHandler.

AMI_BeginHandler_ptr
TAO::Objref_Traits<AMI_BeginHandler>::duplicate (AMI_BeginHandler_ptr p)
{
  return AMI_BeginHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_BeginHandler>::release (AMI_BeginHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_BeginHandler_ptr
TAO::Objref_Traits<AMI_BeginHandler>::nil ()
{
  return AMI_BeginHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_BeginHandler>::marshal (const AMI_BeginHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_BeginHandler::AMI_BeginHandler ()
{
}
void
AMI_BeginHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_BeginHandler *_tao_tmp_pointer =
    static_cast<AMI_BeginHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_BeginHandler_ptr
AMI_BeginHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_BeginHandler>::narrow (_tao_objref, "IDL:AMI_BeginHandler:1.0");
}

AMI_BeginHandler_ptr
AMI_BeginHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_BeginHandler>::unchecked_narrow (_tao_objref);
}

AMI_BeginHandler_ptr
AMI_BeginHandler::_nil ()
{
  return nullptr;
}

AMI_BeginHandler_ptr
AMI_BeginHandler::_duplicate (AMI_BeginHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_BeginHandler::_tao_release (AMI_BeginHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_BeginHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_BeginHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_BeginHandler::_interface_repository_id () const
{
  return "IDL:AMI_BeginHandler:1.0";
}

const char* AMI_BeginHandler::_desc_repository_id ()
{
  return "IDL:AMI_BeginHandler:1.0";
}

const char* AMI_BeginHandler::_desc_interface_name ()
{
  return "AMI_BeginHandler";
}

::CORBA::Boolean
AMI_BeginHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_BeginHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_BeginHandler:1.0",
    "AMI_BeginHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_BeginHandler =
  &_tao_tc_AMI_BeginHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Middle.

Middle_ptr
TAO::Objref_Traits<Middle>::duplicate (Middle_ptr p)
{
  return Middle::_duplicate (p);
}

void
TAO::Objref_Traits<Middle>::release (Middle_ptr p)
{
  ::CORBA::release (p);
}

Middle_ptr
TAO::Objref_Traits<Middle>::nil ()
{
  return Middle::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Middle>::marshal (const Middle_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Middle::Middle ()
{
}
void
Middle::_tao_any_destructor (void *_tao_void_pointer)
{
  Middle *_tao_tmp_pointer =
    static_cast<Middle *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Middle_ptr
Middle::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Middle>::narrow (_tao_objref, "IDL:Middle:1.0");
}

Middle_ptr
Middle::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Middle>::unchecked_narrow (_tao_objref);
}

Middle_ptr
Middle::_nil ()
{
  return nullptr;
}

Middle_ptr
Middle::_duplicate (Middle_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Middle::_tao_release (Middle_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Middle::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Begin:1.0") == 0 ||
      std::strcmp (value, "IDL:Middle:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Middle::_interface_repository_id () const
{
  return "IDL:Middle:1.0";
}

const char* Middle::_desc_repository_id ()
{
  return "IDL:Middle:1.0";
}

const char* Middle::_desc_interface_name ()
{
  return "Middle";
}

::CORBA::Boolean
Middle::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Middle (
    ::CORBA::tk_objref,
    "IDL:Middle:1.0",
    "Middle");
  
::CORBA::TypeCode_ptr const _tc_Middle =
  &_tao_tc_Middle;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_MiddleExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_MiddleExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_MiddleExceptionHolder:1.0",
    "AMH_MiddleExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_MiddleExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_MiddleExceptionHolder =
  &_tao_tc_AMH_MiddleExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_MiddleExceptionHolder>::add_ref (AMH_MiddleExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_MiddleExceptionHolder>::remove_ref (AMH_MiddleExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_MiddleExceptionHolder>::release (AMH_MiddleExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_MiddleExceptionHolder *
AMH_MiddleExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_MiddleExceptionHolder *> (v);
}

const char *
AMH_MiddleExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_MiddleExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_MiddleExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_MiddleExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_MiddleExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_MiddleExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_MiddleExceptionHolder;
}

AMH_MiddleExceptionHolder::~AMH_MiddleExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_MiddleExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_MiddleExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_MiddleExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_MiddleExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_MiddleExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_MiddleExceptionHolder::_tao_marshal__AMH_MiddleExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_MiddleExceptionHolder::_tao_unmarshal__AMH_MiddleExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_MiddleExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_MiddleExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_MiddleExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_MiddleExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_MiddleExceptionHolder_init::AMH_MiddleExceptionHolder_init ()
{
}

AMH_MiddleExceptionHolder_init::~AMH_MiddleExceptionHolder_init ()
{
}

AMH_MiddleExceptionHolder_init *
AMH_MiddleExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_MiddleExceptionHolder_init *> (v);
}

const char*
AMH_MiddleExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_MiddleExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_MiddleExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_MiddleExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_MiddleResponseHandler.

AMH_MiddleResponseHandler_ptr
TAO::Objref_Traits<AMH_MiddleResponseHandler>::duplicate (AMH_MiddleResponseHandler_ptr p)
{
  return AMH_MiddleResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_MiddleResponseHandler>::release (AMH_MiddleResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_MiddleResponseHandler_ptr
TAO::Objref_Traits<AMH_MiddleResponseHandler>::nil ()
{
  return AMH_MiddleResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_MiddleResponseHandler>::marshal (const AMH_MiddleResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_MiddleResponseHandler::AMH_MiddleResponseHandler ()
{}void
AMH_MiddleResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_MiddleResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_MiddleResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_MiddleResponseHandler_ptr
AMH_MiddleResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_MiddleResponseHandler::_duplicate (
      dynamic_cast<AMH_MiddleResponseHandler_ptr> (_tao_objref));
}

AMH_MiddleResponseHandler_ptr
AMH_MiddleResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_MiddleResponseHandler::_duplicate (
      dynamic_cast<AMH_MiddleResponseHandler_ptr> (_tao_objref));
}

AMH_MiddleResponseHandler_ptr
AMH_MiddleResponseHandler::_nil ()
{
  return nullptr;
}

AMH_MiddleResponseHandler_ptr
AMH_MiddleResponseHandler::_duplicate (AMH_MiddleResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_MiddleResponseHandler::_tao_release (AMH_MiddleResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_MiddleResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_MiddleResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_MiddleResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_MiddleResponseHandler:1.0";
}

const char* AMH_MiddleResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_MiddleResponseHandler:1.0";
}

const char* AMH_MiddleResponseHandler::_desc_interface_name ()
{
  return "AMH_MiddleResponseHandler";
}

::CORBA::Boolean
AMH_MiddleResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_MiddleResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_MiddleResponseHandler:1.0",
    "AMH_MiddleResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_MiddleResponseHandler =
  &_tao_tc_AMH_MiddleResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_MiddleHandler.

AMI_MiddleHandler_ptr
TAO::Objref_Traits<AMI_MiddleHandler>::duplicate (AMI_MiddleHandler_ptr p)
{
  return AMI_MiddleHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_MiddleHandler>::release (AMI_MiddleHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_MiddleHandler_ptr
TAO::Objref_Traits<AMI_MiddleHandler>::nil ()
{
  return AMI_MiddleHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_MiddleHandler>::marshal (const AMI_MiddleHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_MiddleHandler::AMI_MiddleHandler ()
{
}
void
AMI_MiddleHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_MiddleHandler *_tao_tmp_pointer =
    static_cast<AMI_MiddleHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_MiddleHandler_ptr
AMI_MiddleHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_MiddleHandler>::narrow (_tao_objref, "IDL:AMI_MiddleHandler:1.0");
}

AMI_MiddleHandler_ptr
AMI_MiddleHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_MiddleHandler>::unchecked_narrow (_tao_objref);
}

AMI_MiddleHandler_ptr
AMI_MiddleHandler::_nil ()
{
  return nullptr;
}

AMI_MiddleHandler_ptr
AMI_MiddleHandler::_duplicate (AMI_MiddleHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_MiddleHandler::_tao_release (AMI_MiddleHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_MiddleHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_BeginHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_MiddleHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_MiddleHandler::_interface_repository_id () const
{
  return "IDL:AMI_MiddleHandler:1.0";
}

const char* AMI_MiddleHandler::_desc_repository_id ()
{
  return "IDL:AMI_MiddleHandler:1.0";
}

const char* AMI_MiddleHandler::_desc_interface_name ()
{
  return "AMI_MiddleHandler";
}

::CORBA::Boolean
AMI_MiddleHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_MiddleHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_MiddleHandler:1.0",
    "AMI_MiddleHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_MiddleHandler =
  &_tao_tc_AMI_MiddleHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for End.

End_ptr
TAO::Objref_Traits<End>::duplicate (End_ptr p)
{
  return End::_duplicate (p);
}

void
TAO::Objref_Traits<End>::release (End_ptr p)
{
  ::CORBA::release (p);
}

End_ptr
TAO::Objref_Traits<End>::nil ()
{
  return End::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<End>::marshal (const End_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



End::End ()
{
}
void
End::_tao_any_destructor (void *_tao_void_pointer)
{
  End *_tao_tmp_pointer =
    static_cast<End *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

End_ptr
End::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<End>::narrow (_tao_objref, "IDL:End:1.0");
}

End_ptr
End::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<End>::unchecked_narrow (_tao_objref);
}

End_ptr
End::_nil ()
{
  return nullptr;
}

End_ptr
End::_duplicate (End_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
End::_tao_release (End_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
End::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Begin:1.0") == 0 ||
      std::strcmp (value, "IDL:Middle:1.0") == 0 ||
      std::strcmp (value, "IDL:End:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* End::_interface_repository_id () const
{
  return "IDL:End:1.0";
}

const char* End::_desc_repository_id ()
{
  return "IDL:End:1.0";
}

const char* End::_desc_interface_name ()
{
  return "End";
}

::CORBA::Boolean
End::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_End (
    ::CORBA::tk_objref,
    "IDL:End:1.0",
    "End");
  
::CORBA::TypeCode_ptr const _tc_End =
  &_tao_tc_End;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_EndExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_EndExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_EndExceptionHolder:1.0",
    "AMH_EndExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_EndExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_EndExceptionHolder =
  &_tao_tc_AMH_EndExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_EndExceptionHolder>::add_ref (AMH_EndExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_EndExceptionHolder>::remove_ref (AMH_EndExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_EndExceptionHolder>::release (AMH_EndExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_EndExceptionHolder *
AMH_EndExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_EndExceptionHolder *> (v);
}

const char *
AMH_EndExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_EndExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_EndExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_EndExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_EndExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_EndExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_EndExceptionHolder;
}

AMH_EndExceptionHolder::~AMH_EndExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_EndExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_EndExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_EndExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_EndExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_EndExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_EndExceptionHolder::_tao_marshal__AMH_EndExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_EndExceptionHolder::_tao_unmarshal__AMH_EndExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_EndExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_EndExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_EndExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_EndExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_EndExceptionHolder_init::AMH_EndExceptionHolder_init ()
{
}

AMH_EndExceptionHolder_init::~AMH_EndExceptionHolder_init ()
{
}

AMH_EndExceptionHolder_init *
AMH_EndExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_EndExceptionHolder_init *> (v);
}

const char*
AMH_EndExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_EndExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_EndExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_EndExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_EndResponseHandler.

AMH_EndResponseHandler_ptr
TAO::Objref_Traits<AMH_EndResponseHandler>::duplicate (AMH_EndResponseHandler_ptr p)
{
  return AMH_EndResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_EndResponseHandler>::release (AMH_EndResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_EndResponseHandler_ptr
TAO::Objref_Traits<AMH_EndResponseHandler>::nil ()
{
  return AMH_EndResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_EndResponseHandler>::marshal (const AMH_EndResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_EndResponseHandler::AMH_EndResponseHandler ()
{}void
AMH_EndResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_EndResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_EndResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_EndResponseHandler_ptr
AMH_EndResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_EndResponseHandler::_duplicate (
      dynamic_cast<AMH_EndResponseHandler_ptr> (_tao_objref));
}

AMH_EndResponseHandler_ptr
AMH_EndResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_EndResponseHandler::_duplicate (
      dynamic_cast<AMH_EndResponseHandler_ptr> (_tao_objref));
}

AMH_EndResponseHandler_ptr
AMH_EndResponseHandler::_nil ()
{
  return nullptr;
}

AMH_EndResponseHandler_ptr
AMH_EndResponseHandler::_duplicate (AMH_EndResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_EndResponseHandler::_tao_release (AMH_EndResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_EndResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_EndResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_EndResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_EndResponseHandler:1.0";
}

const char* AMH_EndResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_EndResponseHandler:1.0";
}

const char* AMH_EndResponseHandler::_desc_interface_name ()
{
  return "AMH_EndResponseHandler";
}

::CORBA::Boolean
AMH_EndResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_EndResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_EndResponseHandler:1.0",
    "AMH_EndResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_EndResponseHandler =
  &_tao_tc_AMH_EndResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_EndHandler.

AMI_EndHandler_ptr
TAO::Objref_Traits<AMI_EndHandler>::duplicate (AMI_EndHandler_ptr p)
{
  return AMI_EndHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_EndHandler>::release (AMI_EndHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_EndHandler_ptr
TAO::Objref_Traits<AMI_EndHandler>::nil ()
{
  return AMI_EndHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_EndHandler>::marshal (const AMI_EndHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_EndHandler::AMI_EndHandler ()
{
}
void
AMI_EndHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_EndHandler *_tao_tmp_pointer =
    static_cast<AMI_EndHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_EndHandler_ptr
AMI_EndHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_EndHandler>::narrow (_tao_objref, "IDL:AMI_EndHandler:1.0");
}

AMI_EndHandler_ptr
AMI_EndHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_EndHandler>::unchecked_narrow (_tao_objref);
}

AMI_EndHandler_ptr
AMI_EndHandler::_nil ()
{
  return nullptr;
}

AMI_EndHandler_ptr
AMI_EndHandler::_duplicate (AMI_EndHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_EndHandler::_tao_release (AMI_EndHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_EndHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_BeginHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_MiddleHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_EndHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_EndHandler::_interface_repository_id () const
{
  return "IDL:AMI_EndHandler:1.0";
}

const char* AMI_EndHandler::_desc_repository_id ()
{
  return "IDL:AMI_EndHandler:1.0";
}

const char* AMI_EndHandler::_desc_interface_name ()
{
  return "AMI_EndHandler";
}

::CORBA::Boolean
AMI_EndHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_EndHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_EndHandler:1.0",
    "AMI_EndHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_EndHandler =
  &_tao_tc_AMI_EndHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Client.

Client_ptr
TAO::Objref_Traits<Client>::duplicate (Client_ptr p)
{
  return Client::_duplicate (p);
}

void
TAO::Objref_Traits<Client>::release (Client_ptr p)
{
  ::CORBA::release (p);
}

Client_ptr
TAO::Objref_Traits<Client>::nil ()
{
  return Client::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Client>::marshal (const Client_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::Begin::Value
Client::v ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_v",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
Client::v (
  ::Begin::Value v)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_v (v);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_v)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_v",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
Client::sendc_set_v (
  ::AMI_ClientHandler_ptr ami_handler,
  ::Begin::Value v)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_v (v);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_v)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_v",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_ClientHandler::set_v_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
Client::sendc_get_v (
  ::AMI_ClientHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_v",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_ClientHandler::get_v_reply_stub
    );
}

Client::Client ()
{
}
void
Client::_tao_any_destructor (void *_tao_void_pointer)
{
  Client *_tao_tmp_pointer =
    static_cast<Client *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Client_ptr
Client::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Client>::narrow (_tao_objref, "IDL:Client:1.0");
}

Client_ptr
Client::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Client>::unchecked_narrow (_tao_objref);
}

Client_ptr
Client::_nil ()
{
  return nullptr;
}

Client_ptr
Client::_duplicate (Client_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Client::_tao_release (Client_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Client::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Client:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Client::_interface_repository_id () const
{
  return "IDL:Client:1.0";
}

const char* Client::_desc_repository_id ()
{
  return "IDL:Client:1.0";
}

const char* Client::_desc_interface_name ()
{
  return "Client";
}

::CORBA::Boolean
Client::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Client (
    ::CORBA::tk_objref,
    "IDL:Client:1.0",
    "Client");
  
::CORBA::TypeCode_ptr const _tc_Client =
  &_tao_tc_Client;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_ClientExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_ClientExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_ClientExceptionHolder:1.0",
    "AMH_ClientExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_ClientExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_ClientExceptionHolder =
  &_tao_tc_AMH_ClientExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_ClientExceptionHolder>::add_ref (AMH_ClientExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_ClientExceptionHolder>::remove_ref (AMH_ClientExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_ClientExceptionHolder>::release (AMH_ClientExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_ClientExceptionHolder *
AMH_ClientExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_ClientExceptionHolder *> (v);
}

const char *
AMH_ClientExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_ClientExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_ClientExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_ClientExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_ClientExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_ClientExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_ClientExceptionHolder;
}

AMH_ClientExceptionHolder::~AMH_ClientExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_ClientExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_ClientExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_ClientExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_ClientExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_ClientExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_ClientExceptionHolder::_tao_marshal__AMH_ClientExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_ClientExceptionHolder::_tao_unmarshal__AMH_ClientExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_ClientExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_ClientExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_ClientExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_ClientExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_ClientExceptionHolder::raise_get_v ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_ClientExceptionHolder::raise_set_v ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_ClientExceptionHolder::raise_sendc_set_v ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_ClientExceptionHolder::raise_sendc_get_v ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_ClientResponseHandler.

AMH_ClientResponseHandler_ptr
TAO::Objref_Traits<AMH_ClientResponseHandler>::duplicate (AMH_ClientResponseHandler_ptr p)
{
  return AMH_ClientResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_ClientResponseHandler>::release (AMH_ClientResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_ClientResponseHandler_ptr
TAO::Objref_Traits<AMH_ClientResponseHandler>::nil ()
{
  return AMH_ClientResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_ClientResponseHandler>::marshal (const AMH_ClientResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_ClientResponseHandler::AMH_ClientResponseHandler ()
{}void
AMH_ClientResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_ClientResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_ClientResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_ClientResponseHandler_ptr
AMH_ClientResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_ClientResponseHandler::_duplicate (
      dynamic_cast<AMH_ClientResponseHandler_ptr> (_tao_objref));
}

AMH_ClientResponseHandler_ptr
AMH_ClientResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_ClientResponseHandler::_duplicate (
      dynamic_cast<AMH_ClientResponseHandler_ptr> (_tao_objref));
}

AMH_ClientResponseHandler_ptr
AMH_ClientResponseHandler::_nil ()
{
  return nullptr;
}

AMH_ClientResponseHandler_ptr
AMH_ClientResponseHandler::_duplicate (AMH_ClientResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_ClientResponseHandler::_tao_release (AMH_ClientResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_ClientResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_ClientResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_ClientResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_ClientResponseHandler:1.0";
}

const char* AMH_ClientResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_ClientResponseHandler:1.0";
}

const char* AMH_ClientResponseHandler::_desc_interface_name ()
{
  return "AMH_ClientResponseHandler";
}

::CORBA::Boolean
AMH_ClientResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_ClientResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_ClientResponseHandler:1.0",
    "AMH_ClientResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_ClientResponseHandler =
  &_tao_tc_AMH_ClientResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_ClientHandler.

AMI_ClientHandler_ptr
TAO::Objref_Traits<AMI_ClientHandler>::duplicate (AMI_ClientHandler_ptr p)
{
  return AMI_ClientHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_ClientHandler>::release (AMI_ClientHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_ClientHandler_ptr
TAO::Objref_Traits<AMI_ClientHandler>::nil ()
{
  return AMI_ClientHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_ClientHandler>::marshal (const AMI_ClientHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_ClientHandler::get_v (
  ::Begin::Value ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_v",
      5,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_ClientHandler::get_v_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_ClientHandler_var _tao_reply_handler_object =
    AMI_ClientHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::Begin::Value ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_v (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_v_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_ClientHandler::get_v_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_v_excep",
      11,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_ClientHandler::set_v ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_v",
      5,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_ClientHandler::set_v_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_ClientHandler_var _tao_reply_handler_object =
    AMI_ClientHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_v (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_v_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_ClientHandler::set_v_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_v_excep",
      11,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

AMI_ClientHandler::AMI_ClientHandler ()
{
}
void
AMI_ClientHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_ClientHandler *_tao_tmp_pointer =
    static_cast<AMI_ClientHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_ClientHandler_ptr
AMI_ClientHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_ClientHandler>::narrow (_tao_objref, "IDL:AMI_ClientHandler:1.0");
}

AMI_ClientHandler_ptr
AMI_ClientHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_ClientHandler>::unchecked_narrow (_tao_objref);
}

AMI_ClientHandler_ptr
AMI_ClientHandler::_nil ()
{
  return nullptr;
}

AMI_ClientHandler_ptr
AMI_ClientHandler::_duplicate (AMI_ClientHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_ClientHandler::_tao_release (AMI_ClientHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_ClientHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_ClientHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_ClientHandler::_interface_repository_id () const
{
  return "IDL:AMI_ClientHandler:1.0";
}

const char* AMI_ClientHandler::_desc_repository_id ()
{
  return "IDL:AMI_ClientHandler:1.0";
}

const char* AMI_ClientHandler::_desc_interface_name ()
{
  return "AMI_ClientHandler";
}

::CORBA::Boolean
AMI_ClientHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_ClientHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_ClientHandler:1.0",
    "AMI_ClientHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_ClientHandler =
  &_tao_tc_AMI_ClientHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AttributeTester.

AttributeTester_ptr
TAO::Objref_Traits<AttributeTester>::duplicate (AttributeTester_ptr p)
{
  return AttributeTester::_duplicate (p);
}

void
TAO::Objref_Traits<AttributeTester>::release (AttributeTester_ptr p)
{
  ::CORBA::release (p);
}

AttributeTester_ptr
TAO::Objref_Traits<AttributeTester>::nil ()
{
  return AttributeTester::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AttributeTester>::marshal (const AttributeTester_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_array/array_cs.cpp:89

AttributeTester::string_1_slice *
AttributeTester::string_1_dup (const AttributeTester::string_1_slice *_tao_src_array)
{
  AttributeTester::string_1_slice *_tao_dup_array = AttributeTester::string_1_alloc ();
  
  if (_tao_dup_array)
    {
      AttributeTester::string_1_copy (_tao_dup_array, _tao_src_array);
    }
  
  return _tao_dup_array;
}

AttributeTester::string_1_slice *
AttributeTester::string_1_alloc ()
{
  AttributeTester::string_1_slice *retval {};
  ACE_NEW_RETURN (retval, ::TAO::String_Manager[1], nullptr);
  return retval;
}

void
AttributeTester::string_1_free (AttributeTester::string_1_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
AttributeTester::string_1_copy (
    AttributeTester::string_1_slice * _tao_to,
    const AttributeTester::string_1_slice *_tao_from)
{
  // Copy each individual element.
  for (::CORBA::ULong i0 = 0; i0 < 1; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:296


#ifndef _TAO_TYPECODE_AttributeTester_string_1_GUARD
#define _TAO_TYPECODE_AttributeTester_string_1_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        AttributeTester_string_1_1 (
          ::CORBA::tk_array,
          &CORBA::_tc_string,
          1U);
        
      ::CORBA::TypeCode_ptr const tc_AttributeTester_string_1 =
        &AttributeTester_string_1_1;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_AttributeTester_string_1_GUARD */
static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_AttributeTester_string_1 (
    ::CORBA::tk_alias,
    "IDL:AttributeTester/string_1:1.0",
    "string_1",
    &TAO::TypeCode::tc_AttributeTester_string_1);
  
::CORBA::TypeCode_ptr const AttributeTester::_tc_string_1 =
  &_tao_tc_AttributeTester_string_1;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

char *
AttributeTester::a_su ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_a_su",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AttributeTester::a_su (
  const char * a_su)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_a_su (a_su);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_a_su)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_a_su",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::AttributeTester::string_1_slice *
AttributeTester::a_sb ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::AttributeTester::string_1_tag>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_a_sb",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AttributeTester::a_sb (
  const ::AttributeTester::string_1 a_sb)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AttributeTester::string_1_tag>::in_arg_val _tao_a_sb (a_sb);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_a_sb)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_a_sb",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
AttributeTester::sendc_set_a_su (
  ::AMI_AttributeTesterHandler_ptr ami_handler,
  const char * a_su)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_a_su (a_su);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_a_su)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_a_su",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_AttributeTesterHandler::set_a_su_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
AttributeTester::sendc_get_a_su (
  ::AMI_AttributeTesterHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_a_su",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_AttributeTesterHandler::get_a_su_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
AttributeTester::sendc_set_a_sb (
  ::AMI_AttributeTesterHandler_ptr ami_handler,
  const ::AttributeTester::string_1 a_sb)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AttributeTester::string_1_tag>::in_arg_val _tao_a_sb (a_sb);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_a_sb)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_a_sb",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_AttributeTesterHandler::set_a_sb_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
AttributeTester::sendc_get_a_sb (
  ::AMI_AttributeTesterHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_a_sb",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_AttributeTesterHandler::get_a_sb_reply_stub
    );
}

AttributeTester::AttributeTester ()
{
}
void
AttributeTester::_tao_any_destructor (void *_tao_void_pointer)
{
  AttributeTester *_tao_tmp_pointer =
    static_cast<AttributeTester *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AttributeTester_ptr
AttributeTester::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AttributeTester>::narrow (_tao_objref, "IDL:AttributeTester:1.0");
}

AttributeTester_ptr
AttributeTester::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AttributeTester>::unchecked_narrow (_tao_objref);
}

AttributeTester_ptr
AttributeTester::_nil ()
{
  return nullptr;
}

AttributeTester_ptr
AttributeTester::_duplicate (AttributeTester_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AttributeTester::_tao_release (AttributeTester_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AttributeTester::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AttributeTester:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AttributeTester::_interface_repository_id () const
{
  return "IDL:AttributeTester:1.0";
}

const char* AttributeTester::_desc_repository_id ()
{
  return "IDL:AttributeTester:1.0";
}

const char* AttributeTester::_desc_interface_name ()
{
  return "AttributeTester";
}

::CORBA::Boolean
AttributeTester::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AttributeTester (
    ::CORBA::tk_objref,
    "IDL:AttributeTester:1.0",
    "AttributeTester");
  
::CORBA::TypeCode_ptr const _tc_AttributeTester =
  &_tao_tc_AttributeTester;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_AttributeTesterExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_AttributeTesterExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_AttributeTesterExceptionHolder:1.0",
    "AMH_AttributeTesterExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_AttributeTesterExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_AttributeTesterExceptionHolder =
  &_tao_tc_AMH_AttributeTesterExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_AttributeTesterExceptionHolder>::add_ref (AMH_AttributeTesterExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_AttributeTesterExceptionHolder>::remove_ref (AMH_AttributeTesterExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_AttributeTesterExceptionHolder>::release (AMH_AttributeTesterExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_AttributeTesterExceptionHolder *
AMH_AttributeTesterExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_AttributeTesterExceptionHolder *> (v);
}

const char *
AMH_AttributeTesterExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_AttributeTesterExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_AttributeTesterExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_AttributeTesterExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_AttributeTesterExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_AttributeTesterExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_AttributeTesterExceptionHolder;
}

AMH_AttributeTesterExceptionHolder::~AMH_AttributeTesterExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_AttributeTesterExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_AttributeTesterExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_AttributeTesterExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_AttributeTesterExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_AttributeTesterExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_AttributeTesterExceptionHolder::_tao_marshal__AMH_AttributeTesterExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_AttributeTesterExceptionHolder::_tao_unmarshal__AMH_AttributeTesterExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_AttributeTesterExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_AttributeTesterExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_AttributeTesterExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_AttributeTesterExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_AttributeTesterExceptionHolder::raise_get_a_su ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_AttributeTesterExceptionHolder::raise_set_a_su ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_AttributeTesterExceptionHolder::raise_get_a_sb ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_AttributeTesterExceptionHolder::raise_set_a_sb ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_AttributeTesterExceptionHolder::raise_sendc_set_a_su ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_AttributeTesterExceptionHolder::raise_sendc_get_a_su ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_AttributeTesterExceptionHolder::raise_sendc_set_a_sb ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_AttributeTesterExceptionHolder::raise_sendc_get_a_sb ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_AttributeTesterResponseHandler.

AMH_AttributeTesterResponseHandler_ptr
TAO::Objref_Traits<AMH_AttributeTesterResponseHandler>::duplicate (AMH_AttributeTesterResponseHandler_ptr p)
{
  return AMH_AttributeTesterResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_AttributeTesterResponseHandler>::release (AMH_AttributeTesterResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_AttributeTesterResponseHandler_ptr
TAO::Objref_Traits<AMH_AttributeTesterResponseHandler>::nil ()
{
  return AMH_AttributeTesterResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_AttributeTesterResponseHandler>::marshal (const AMH_AttributeTesterResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_AttributeTesterResponseHandler::AMH_AttributeTesterResponseHandler ()
{}void
AMH_AttributeTesterResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_AttributeTesterResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_AttributeTesterResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_AttributeTesterResponseHandler_ptr
AMH_AttributeTesterResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_AttributeTesterResponseHandler::_duplicate (
      dynamic_cast<AMH_AttributeTesterResponseHandler_ptr> (_tao_objref));
}

AMH_AttributeTesterResponseHandler_ptr
AMH_AttributeTesterResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_AttributeTesterResponseHandler::_duplicate (
      dynamic_cast<AMH_AttributeTesterResponseHandler_ptr> (_tao_objref));
}

AMH_AttributeTesterResponseHandler_ptr
AMH_AttributeTesterResponseHandler::_nil ()
{
  return nullptr;
}

AMH_AttributeTesterResponseHandler_ptr
AMH_AttributeTesterResponseHandler::_duplicate (AMH_AttributeTesterResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_AttributeTesterResponseHandler::_tao_release (AMH_AttributeTesterResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_AttributeTesterResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_AttributeTesterResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_AttributeTesterResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_AttributeTesterResponseHandler:1.0";
}

const char* AMH_AttributeTesterResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_AttributeTesterResponseHandler:1.0";
}

const char* AMH_AttributeTesterResponseHandler::_desc_interface_name ()
{
  return "AMH_AttributeTesterResponseHandler";
}

::CORBA::Boolean
AMH_AttributeTesterResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_AttributeTesterResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_AttributeTesterResponseHandler:1.0",
    "AMH_AttributeTesterResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_AttributeTesterResponseHandler =
  &_tao_tc_AMH_AttributeTesterResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_AttributeTesterHandler.

AMI_AttributeTesterHandler_ptr
TAO::Objref_Traits<AMI_AttributeTesterHandler>::duplicate (AMI_AttributeTesterHandler_ptr p)
{
  return AMI_AttributeTesterHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_AttributeTesterHandler>::release (AMI_AttributeTesterHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_AttributeTesterHandler_ptr
TAO::Objref_Traits<AMI_AttributeTesterHandler>::nil ()
{
  return AMI_AttributeTesterHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_AttributeTesterHandler>::marshal (const AMI_AttributeTesterHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_AttributeTesterHandler::get_a_su (
  const char * ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_a_su",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_AttributeTesterHandler::get_a_su_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_AttributeTesterHandler_var _tao_reply_handler_object =
    AMI_AttributeTesterHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::String_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_a_su (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_a_su_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_AttributeTesterHandler::get_a_su_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_a_su_excep",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_AttributeTesterHandler::set_a_su ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_a_su",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_AttributeTesterHandler::set_a_su_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_AttributeTesterHandler_var _tao_reply_handler_object =
    AMI_AttributeTesterHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_a_su (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_a_su_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_AttributeTesterHandler::set_a_su_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_a_su_excep",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_AttributeTesterHandler::get_a_sb (
  const ::AttributeTester::string_1 ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AttributeTester::string_1_tag>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_a_sb",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_AttributeTesterHandler::get_a_sb_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_AttributeTesterHandler_var _tao_reply_handler_object =
    AMI_AttributeTesterHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::AttributeTester::string_1 ami_return_val;
      ::AttributeTester::string_1_forany _tao_forany_ami_return_val (
          ami_return_val
        );      // Demarshall all the arguments.
      if (!(

            (_tao_in >> _tao_forany_ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_a_sb (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_a_sb_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_AttributeTesterHandler::get_a_sb_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_a_sb_excep",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_AttributeTesterHandler::set_a_sb ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_a_sb",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_AttributeTesterHandler::set_a_sb_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_AttributeTesterHandler_var _tao_reply_handler_object =
    AMI_AttributeTesterHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_a_sb (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_a_sb_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_AttributeTesterHandler::set_a_sb_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_a_sb_excep",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

AMI_AttributeTesterHandler::AMI_AttributeTesterHandler ()
{
}
void
AMI_AttributeTesterHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_AttributeTesterHandler *_tao_tmp_pointer =
    static_cast<AMI_AttributeTesterHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_AttributeTesterHandler_ptr
AMI_AttributeTesterHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_AttributeTesterHandler>::narrow (_tao_objref, "IDL:AMI_AttributeTesterHandler:1.0");
}

AMI_AttributeTesterHandler_ptr
AMI_AttributeTesterHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_AttributeTesterHandler>::unchecked_narrow (_tao_objref);
}

AMI_AttributeTesterHandler_ptr
AMI_AttributeTesterHandler::_nil ()
{
  return nullptr;
}

AMI_AttributeTesterHandler_ptr
AMI_AttributeTesterHandler::_duplicate (AMI_AttributeTesterHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_AttributeTesterHandler::_tao_release (AMI_AttributeTesterHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_AttributeTesterHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_AttributeTesterHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_AttributeTesterHandler::_interface_repository_id () const
{
  return "IDL:AMI_AttributeTesterHandler:1.0";
}

const char* AMI_AttributeTesterHandler::_desc_repository_id ()
{
  return "IDL:AMI_AttributeTesterHandler:1.0";
}

const char* AMI_AttributeTesterHandler::_desc_interface_name ()
{
  return "AMI_AttributeTesterHandler";
}

::CORBA::Boolean
AMI_AttributeTesterHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_AttributeTesterHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_AttributeTesterHandler:1.0",
    "AMI_AttributeTesterHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_AttributeTesterHandler =
  &_tao_tc_AMI_AttributeTesterHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for ParamMod::ParameterTester.

ParamMod::ParameterTester_ptr
TAO::Objref_Traits<ParamMod::ParameterTester>::duplicate (ParamMod::ParameterTester_ptr p)
{
  return ParamMod::ParameterTester::_duplicate (p);
}

void
TAO::Objref_Traits<ParamMod::ParameterTester>::release (ParamMod::ParameterTester_ptr p)
{
  ::CORBA::release (p);
}

ParamMod::ParameterTester_ptr
TAO::Objref_Traits<ParamMod::ParameterTester>::nil ()
{
  return ParamMod::ParameterTester::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<ParamMod::ParameterTester>::marshal (const ParamMod::ParameterTester_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



ParamMod::ParameterTester::object_excep_type::object_excep_type (
    const ParamMod::ParameterTester_ptr _tao_objref)
  : ::CORBA::UserException (
        "IDL:ParamMod/ParameterTester/object_excep_type:1.0",
        "object_excep_type")
{
  this->objref = TAO::Objref_Traits<ParamMod::ParameterTester>::duplicate (_tao_objref);
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

ParamMod::ParameterTester::object_excep_type::object_excep_type ()
  : ::CORBA::UserException (
        "IDL:ParamMod/ParameterTester/object_excep_type:1.0",
        "object_excep_type")
{
}

ParamMod::ParameterTester::object_excep_type::object_excep_type (const ::ParamMod::ParameterTester::object_excep_type &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->objref = TAO::Objref_Traits<ParamMod::ParameterTester>::duplicate (_tao_excp.objref.in ());
}

ParamMod::ParameterTester::object_excep_type&
ParamMod::ParameterTester::object_excep_type::operator= (const ::ParamMod::ParameterTester::object_excep_type &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->objref = TAO::Objref_Traits<ParamMod::ParameterTester>::duplicate (_tao_excp.objref.in ());
  return *this;
}

void ParamMod::ParameterTester::object_excep_type::_tao_any_destructor (void *_tao_void_pointer)
{
  object_excep_type *_tao_tmp_pointer =
    static_cast<object_excep_type *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

ParamMod::ParameterTester::object_excep_type *
ParamMod::ParameterTester::object_excep_type::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<object_excep_type *> (_tao_excp);
}

const ParamMod::ParameterTester::object_excep_type *
ParamMod::ParameterTester::object_excep_type::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const object_excep_type *> (_tao_excp);
}

::CORBA::Exception *ParamMod::ParameterTester::object_excep_type::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::ParamMod::ParameterTester::object_excep_type, nullptr);
  return retval;
}

::CORBA::Exception *
ParamMod::ParameterTester::object_excep_type::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::ParamMod::ParameterTester::object_excep_type (*this), nullptr);
  return result;
}

void ParamMod::ParameterTester::object_excep_type::_raise () const
{
  throw *this;
}

void ParamMod::ParameterTester::object_excep_type::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void ParamMod::ParameterTester::object_excep_type::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr ParamMod::ParameterTester::object_excep_type::_tao_type () const
{
  return ::ParamMod::ParameterTester::_tc_object_excep_type;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_ParamMod_ParameterTester_object_excep_type[] =
      {
        { "objref", &ParamMod::_tc_ParameterTester }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_ParamMod_ParameterTester_object_excep_type (
  ::CORBA::tk_except,
  "IDL:ParamMod/ParameterTester/object_excep_type:1.0",
  "object_excep_type",
  _tao_fields_ParamMod_ParameterTester_object_excep_type,
  1);

::CORBA::TypeCode_ptr const ParamMod::ParameterTester::_tc_object_excep_type =
  &_tao_tc_ParamMod_ParameterTester_object_excep_type;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/sequence_cs.cpp:104



#if !defined (_PARAMMOD_PARAMETERTESTER_OBJECT_SEQ_TYPE_CS_)
#define _PARAMMOD_PARAMETERTESTER_OBJECT_SEQ_TYPE_CS_

ParamMod::ParameterTester::object_seq_type::object_seq_type (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        ParamMod::ParameterTester,
        ParamMod::ParameterTester_var
      > (max)
{}

ParamMod::ParameterTester::object_seq_type::object_seq_type (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ParamMod::ParameterTester_ptr * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_object_reference_sequence<
        ParamMod::ParameterTester,
        ParamMod::ParameterTester_var
      >
    (max, length, buffer, release)
{}

void ParamMod::ParameterTester::object_seq_type::_tao_any_destructor (
    void * _tao_void_pointer)
{
  object_seq_type * _tao_tmp_pointer =
    static_cast<object_seq_type *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:457


#ifndef _TAO_TYPECODE_ParamMod_ParameterTester_object_seq_type_GUARD
#define _TAO_TYPECODE_ParamMod_ParameterTester_object_seq_type_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        ParamMod_ParameterTester_object_seq_type_0 (
          ::CORBA::tk_sequence,
          &ParamMod::_tc_ParameterTester,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_ParamMod_ParameterTester_object_seq_type_0 =
        &ParamMod_ParameterTester_object_seq_type_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_ParamMod_ParameterTester_object_seq_type_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_ParamMod_ParameterTester_object_seq_type (
    ::CORBA::tk_alias,
    "IDL:ParamMod/ParameterTester/object_seq_type:1.0",
    "object_seq_type",
    &TAO::TypeCode::tc_ParamMod_ParameterTester_object_seq_type_0);
  
::CORBA::TypeCode_ptr const ParamMod::ParameterTester::_tc_object_seq_type =
  &_tao_tc_ParamMod_ParameterTester_object_seq_type;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_array/array_cs.cpp:89

ParamMod::ParameterTester::object_array_type_slice *
ParamMod::ParameterTester::object_array_type_dup (const ParamMod::ParameterTester::object_array_type_slice *_tao_src_array)
{
  ParamMod::ParameterTester::object_array_type_slice *_tao_dup_array = ParamMod::ParameterTester::object_array_type_alloc ();
  
  if (_tao_dup_array)
    {
      ParamMod::ParameterTester::object_array_type_copy (_tao_dup_array, _tao_src_array);
    }
  
  return _tao_dup_array;
}

ParamMod::ParameterTester::object_array_type_slice *
ParamMod::ParameterTester::object_array_type_alloc ()
{
  ParamMod::ParameterTester::object_array_type_slice *retval {};
  ACE_NEW_RETURN (retval, ParamMod::ParameterTester_var[5], nullptr);
  return retval;
}

void
ParamMod::ParameterTester::object_array_type_free (ParamMod::ParameterTester::object_array_type_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
ParamMod::ParameterTester::object_array_type_copy (
    ParamMod::ParameterTester::object_array_type_slice * _tao_to,
    const ParamMod::ParameterTester::object_array_type_slice *_tao_from)
{
  // Copy each individual element.
  for (::CORBA::ULong i0 = 0; i0 < 5; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:296


#ifndef _TAO_TYPECODE_ParamMod_ParameterTester_object_array_type_GUARD
#define _TAO_TYPECODE_ParamMod_ParameterTester_object_array_type_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        ParamMod_ParameterTester_object_array_type_5 (
          ::CORBA::tk_array,
          &ParamMod::_tc_ParameterTester,
          5U);
        
      ::CORBA::TypeCode_ptr const tc_ParamMod_ParameterTester_object_array_type =
        &ParamMod_ParameterTester_object_array_type_5;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_ParamMod_ParameterTester_object_array_type_GUARD */
static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_ParamMod_ParameterTester_object_array_type (
    ::CORBA::tk_alias,
    "IDL:ParamMod/ParameterTester/object_array_type:1.0",
    "object_array_type",
    &TAO::TypeCode::tc_ParamMod_ParameterTester_object_array_type);
  
::CORBA::TypeCode_ptr const ParamMod::ParameterTester::_tc_object_array_type =
  &_tao_tc_ParamMod_ParameterTester_object_array_type;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_ParamMod_ParameterTester_object_struct_type[] =
      {
        { "o1", &CORBA::_tc_octet },
        { "p1", &ParamMod::_tc_ParameterTester },
        { "l1", &CORBA::_tc_long }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_ParamMod_ParameterTester_object_struct_type (
  ::CORBA::tk_struct,
  "IDL:ParamMod/ParameterTester/object_struct_type:1.0",
  "object_struct_type",
  _tao_fields_ParamMod_ParameterTester_object_struct_type,
  3);

::CORBA::TypeCode_ptr const ParamMod::ParameterTester::_tc_object_struct_type =
  &_tao_tc_ParamMod_ParameterTester_object_struct_type;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
ParamMod::ParameterTester::object_struct_type::_tao_any_destructor (
    void *_tao_void_pointer)
{
  object_struct_type *_tao_tmp_pointer =
    static_cast<object_struct_type *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/union_cs.cpp:75



ParamMod::ParameterTester::object_union_type::object_union_type ()
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -2147483647;
}

ParamMod::ParameterTester::object_union_type::object_union_type (const ::ParamMod::ParameterTester::object_union_type &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      this->u_.str_ = ::CORBA::string_dup (u.u_.str_);
    }
    break;
    case 1:
    {
      if (!u.u_.pt_)
        {
          this->u_.pt_ = nullptr;
        }
      else
        {
          typedef ParamMod::ParameterTester_var OBJECT_FIELD;
          ACE_NEW (
              this->u_.pt_,
              OBJECT_FIELD (
                  ParamMod::ParameterTester::_duplicate (
                      u.u_.pt_->in ()
                    )
                )
            );
        }
    }
    break;
    default:
    break;
  }
}

ParamMod::ParameterTester::object_union_type::~object_union_type ()
{
  // Finalize.
  this->_reset ();
}

void ParamMod::ParameterTester::object_union_type::_tao_any_destructor (void *_tao_void_pointer)
{
  object_union_type *tmp =
    static_cast<object_union_type *> (_tao_void_pointer);
  delete tmp;
}

ParamMod::ParameterTester::object_union_type &
ParamMod::ParameterTester::object_union_type::operator= (const ::ParamMod::ParameterTester::object_union_type &u)
{
  if (std::addressof(u) == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 0:
    {
      this->u_.str_ = ::CORBA::string_dup (u.u_.str_);
    }
    break;
    case 1:
    {
      if (!u.u_.pt_)
        {
          this->u_.pt_ = nullptr;
        }
      else
        {
          typedef ParamMod::ParameterTester_var OBJECT_FIELD;
          ACE_NEW_RETURN (
              this->u_.pt_,
              OBJECT_FIELD (
                  ParamMod::ParameterTester::_duplicate (
                      u.u_.pt_->in ()
                    )
                ),
              *this);
        }
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void ParamMod::ParameterTester::object_union_type::_reset ()
{
  switch (this->disc_)
  {
    
    case 0:
      ::CORBA::string_free (this->u_.str_);
      this->u_.str_ = nullptr;
      
    break;
    
    case 1:
      delete this->u_.pt_;
      this->u_.pt_ = nullptr;
      
    break;
    
    default:
    break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/union_typecode.cpp:63

static TAO::TypeCode::Case_T<CORBA::Long, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_ParamMod_ParameterTester_object_union_type__0 (0, "str", &CORBA::_tc_string);
static TAO::TypeCode::Case_T<CORBA::Long, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_ParamMod_ParameterTester_object_union_type__1 (1, "pt", &ParamMod::_tc_ParameterTester);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_ParamMod_ParameterTester_object_union_type[] =
  {
    &_tao_cases_ParamMod_ParameterTester_object_union_type__0,
    &_tao_cases_ParamMod_ParameterTester_object_union_type__1
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_ParamMod_ParameterTester_object_union_type (
    "IDL:ParamMod/ParameterTester/object_union_type:1.0",
    "object_union_type",
    &CORBA::_tc_long,
    _tao_cases_ParamMod_ParameterTester_object_union_type,
    sizeof (_tao_cases_ParamMod_ParameterTester_object_union_type)/sizeof (_tao_cases_ParamMod_ParameterTester_object_union_type[0]),
    -1);
  
::CORBA::TypeCode_ptr const ParamMod::ParameterTester::_tc_object_union_type =
  &_tao_tc_ParamMod_ParameterTester_object_union_type;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::ParamMod::ParameterTester::object_seq_type *
ParamMod::ParameterTester::parameter_tester_op (
  const ::ParamMod::ParameterTester::object_struct_type & inarg,
  ::ParamMod::ParameterTester::object_array_type inoutarg,
  ::ParamMod::ParameterTester::object_union_type_out outarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::ParamMod::ParameterTester::object_seq_type>::ret_val _tao_retval;
  TAO::Arg_Traits< ::ParamMod::ParameterTester::object_struct_type>::in_arg_val _tao_inarg (inarg);
  TAO::Arg_Traits< ::ParamMod::ParameterTester::object_array_type_tag>::inout_arg_val _tao_inoutarg (inoutarg);
  TAO::Arg_Traits< ::ParamMod::ParameterTester::object_union_type>::out_arg_val _tao_outarg (outarg);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_inarg),
      std::addressof(_tao_inoutarg),
      std::addressof(_tao_outarg)
    };

  static TAO::Exception_Data
  _tao_ParamMod_ParameterTester_parameter_tester_op_exceptiondata [] = 
    {
      {
        "IDL:ParamMod/ParameterTester/object_excep_type:1.0",
        ParamMod::ParameterTester::object_excep_type::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ParamMod::ParameterTester::_tc_object_excep_type
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      4,
      "parameter_tester_op",
      19,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (
      _tao_ParamMod_ParameterTester_parameter_tester_op_exceptiondata,
      1
    );

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
ParamMod::ParameterTester::sendc_parameter_tester_op (
  ::ParamMod::AMI_ParameterTesterHandler_ptr ami_handler,
  const ::ParamMod::ParameterTester::object_struct_type & inarg,
  const ::ParamMod::ParameterTester::object_array_type inoutarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::ParamMod::ParameterTester::object_struct_type>::in_arg_val _tao_inarg (inarg);
  TAO::Arg_Traits< ::ParamMod::ParameterTester::object_array_type_tag>::in_arg_val _tao_inoutarg (inoutarg);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_inarg),
      std::addressof(_tao_inoutarg)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      3,
      "parameter_tester_op",
      19,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &ParamMod::AMI_ParameterTesterHandler::parameter_tester_op_reply_stub
    );
}

ParamMod::ParameterTester::ParameterTester ()
{
}
void
ParamMod::ParameterTester::_tao_any_destructor (void *_tao_void_pointer)
{
  ParameterTester *_tao_tmp_pointer =
    static_cast<ParameterTester *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

ParamMod::ParameterTester_ptr
ParamMod::ParameterTester::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<ParameterTester>::narrow (_tao_objref, "IDL:ParamMod/ParameterTester:1.0");
}

ParamMod::ParameterTester_ptr
ParamMod::ParameterTester::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<ParameterTester>::unchecked_narrow (_tao_objref);
}

ParamMod::ParameterTester_ptr
ParamMod::ParameterTester::_nil ()
{
  return nullptr;
}

ParamMod::ParameterTester_ptr
ParamMod::ParameterTester::_duplicate (ParameterTester_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
ParamMod::ParameterTester::_tao_release (ParameterTester_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
ParamMod::ParameterTester::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:ParamMod/ParameterTester:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* ParamMod::ParameterTester::_interface_repository_id () const
{
  return "IDL:ParamMod/ParameterTester:1.0";
}

const char* ParamMod::ParameterTester::_desc_repository_id ()
{
  return "IDL:ParamMod/ParameterTester:1.0";
}

const char* ParamMod::ParameterTester::_desc_interface_name ()
{
  return "ParameterTester";
}

::CORBA::Boolean
ParamMod::ParameterTester::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_ParamMod_ParameterTester (
    ::CORBA::tk_objref,
    "IDL:ParamMod/ParameterTester:1.0",
    "ParameterTester");
  

namespace ParamMod
{
  ::CORBA::TypeCode_ptr const _tc_ParameterTester =
    &_tao_tc_ParamMod_ParameterTester;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_ParamMod_AMH_ParameterTesterExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_ParamMod_AMH_ParameterTesterExceptionHolder (
    ::CORBA::tk_value,
    "IDL:ParamMod/AMH_ParameterTesterExceptionHolder:1.0",
    "AMH_ParameterTesterExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_ParamMod_AMH_ParameterTesterExceptionHolder,
    0);
  

namespace ParamMod
{
  ::CORBA::TypeCode_ptr const _tc_AMH_ParameterTesterExceptionHolder =
    &_tao_tc_ParamMod_AMH_ParameterTesterExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<ParamMod::AMH_ParameterTesterExceptionHolder>::add_ref (ParamMod::AMH_ParameterTesterExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<ParamMod::AMH_ParameterTesterExceptionHolder>::remove_ref (ParamMod::AMH_ParameterTesterExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<ParamMod::AMH_ParameterTesterExceptionHolder>::release (ParamMod::AMH_ParameterTesterExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



ParamMod::AMH_ParameterTesterExceptionHolder *
ParamMod::AMH_ParameterTesterExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::ParamMod::AMH_ParameterTesterExceptionHolder *> (v);
}

const char *
ParamMod::AMH_ParameterTesterExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
ParamMod::AMH_ParameterTesterExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
ParamMod::AMH_ParameterTesterExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_ParameterTesterExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_ParameterTesterExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr ParamMod::AMH_ParameterTesterExceptionHolder::_tao_type () const
{
  return ::ParamMod::_tc_AMH_ParameterTesterExceptionHolder;
}

ParamMod::AMH_ParameterTesterExceptionHolder::~AMH_ParameterTesterExceptionHolder ()
{}

::CORBA::ValueBase *
ParamMod::AMH_ParameterTesterExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_ParameterTesterExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
ParamMod::AMH_ParameterTesterExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
ParamMod::AMH_ParameterTesterExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
ParamMod::AMH_ParameterTesterExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
ParamMod::AMH_ParameterTesterExceptionHolder::_tao_marshal__ParamMod_AMH_ParameterTesterExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
ParamMod::AMH_ParameterTesterExceptionHolder::_tao_unmarshal__ParamMod_AMH_ParameterTesterExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
ParamMod::AMH_ParameterTesterExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_ParameterTesterExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_ParameterTesterExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_ParameterTesterExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
ParamMod::AMH_ParameterTesterExceptionHolder::raise_parameter_tester_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
ParamMod::AMH_ParameterTesterExceptionHolder::raise_sendc_parameter_tester_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for ParamMod::AMH_ParameterTesterResponseHandler.

ParamMod::AMH_ParameterTesterResponseHandler_ptr
TAO::Objref_Traits<ParamMod::AMH_ParameterTesterResponseHandler>::duplicate (ParamMod::AMH_ParameterTesterResponseHandler_ptr p)
{
  return ParamMod::AMH_ParameterTesterResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<ParamMod::AMH_ParameterTesterResponseHandler>::release (ParamMod::AMH_ParameterTesterResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

ParamMod::AMH_ParameterTesterResponseHandler_ptr
TAO::Objref_Traits<ParamMod::AMH_ParameterTesterResponseHandler>::nil ()
{
  return ParamMod::AMH_ParameterTesterResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<ParamMod::AMH_ParameterTesterResponseHandler>::marshal (const ParamMod::AMH_ParameterTesterResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



ParamMod::AMH_ParameterTesterResponseHandler::AMH_ParameterTesterResponseHandler ()
{}void
ParamMod::AMH_ParameterTesterResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_ParameterTesterResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_ParameterTesterResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

ParamMod::AMH_ParameterTesterResponseHandler_ptr
ParamMod::AMH_ParameterTesterResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_ParameterTesterResponseHandler::_duplicate (
      dynamic_cast<AMH_ParameterTesterResponseHandler_ptr> (_tao_objref));
}

ParamMod::AMH_ParameterTesterResponseHandler_ptr
ParamMod::AMH_ParameterTesterResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_ParameterTesterResponseHandler::_duplicate (
      dynamic_cast<AMH_ParameterTesterResponseHandler_ptr> (_tao_objref));
}

ParamMod::AMH_ParameterTesterResponseHandler_ptr
ParamMod::AMH_ParameterTesterResponseHandler::_nil ()
{
  return nullptr;
}

ParamMod::AMH_ParameterTesterResponseHandler_ptr
ParamMod::AMH_ParameterTesterResponseHandler::_duplicate (AMH_ParameterTesterResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
ParamMod::AMH_ParameterTesterResponseHandler::_tao_release (AMH_ParameterTesterResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
ParamMod::AMH_ParameterTesterResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:ParamMod/AMH_ParameterTesterResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* ParamMod::AMH_ParameterTesterResponseHandler::_interface_repository_id () const
{
  return "IDL:ParamMod/AMH_ParameterTesterResponseHandler:1.0";
}

const char* ParamMod::AMH_ParameterTesterResponseHandler::_desc_repository_id ()
{
  return "IDL:ParamMod/AMH_ParameterTesterResponseHandler:1.0";
}

const char* ParamMod::AMH_ParameterTesterResponseHandler::_desc_interface_name ()
{
  return "AMH_ParameterTesterResponseHandler";
}

::CORBA::Boolean
ParamMod::AMH_ParameterTesterResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_ParamMod_AMH_ParameterTesterResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:ParamMod/AMH_ParameterTesterResponseHandler:1.0",
    "AMH_ParameterTesterResponseHandler");
  

namespace ParamMod
{
  ::CORBA::TypeCode_ptr const _tc_AMH_ParameterTesterResponseHandler =
    &_tao_tc_ParamMod_AMH_ParameterTesterResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for ParamMod::AMI_ParameterTesterHandler.

ParamMod::AMI_ParameterTesterHandler_ptr
TAO::Objref_Traits<ParamMod::AMI_ParameterTesterHandler>::duplicate (ParamMod::AMI_ParameterTesterHandler_ptr p)
{
  return ParamMod::AMI_ParameterTesterHandler::_duplicate (p);
}

void
TAO::Objref_Traits<ParamMod::AMI_ParameterTesterHandler>::release (ParamMod::AMI_ParameterTesterHandler_ptr p)
{
  ::CORBA::release (p);
}

ParamMod::AMI_ParameterTesterHandler_ptr
TAO::Objref_Traits<ParamMod::AMI_ParameterTesterHandler>::nil ()
{
  return ParamMod::AMI_ParameterTesterHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<ParamMod::AMI_ParameterTesterHandler>::marshal (const ParamMod::AMI_ParameterTesterHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
ParamMod::AMI_ParameterTesterHandler::parameter_tester_op (
  const ::ParamMod::ParameterTester::object_seq_type & ami_return_val,
  const ::ParamMod::ParameterTester::object_array_type inoutarg,
  const ::ParamMod::ParameterTester::object_union_type & outarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::ParamMod::ParameterTester::object_seq_type>::in_arg_val _tao_ami_return_val (ami_return_val);
  TAO::Arg_Traits< ::ParamMod::ParameterTester::object_array_type_tag>::in_arg_val _tao_inoutarg (inoutarg);
  TAO::Arg_Traits< ::ParamMod::ParameterTester::object_union_type>::in_arg_val _tao_outarg (outarg);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val),
      std::addressof(_tao_inoutarg),
      std::addressof(_tao_outarg)
    };

  static TAO::Exception_Data
  _tao_ParamMod_AMI_ParameterTesterHandler_parameter_tester_op_exceptiondata [] = 
    {
      {
        "IDL:ParamMod/ParameterTester/object_excep_type:1.0",
        ParamMod::ParameterTester::object_excep_type::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ParamMod::ParameterTester::_tc_object_excep_type
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      4,
      "parameter_tester_op",
      19,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (
      _tao_ParamMod_AMI_ParameterTesterHandler_parameter_tester_op_exceptiondata,
      1
    );
}

void
ParamMod::AMI_ParameterTesterHandler::parameter_tester_op_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  ParamMod::AMI_ParameterTesterHandler_var _tao_reply_handler_object =
    ParamMod::AMI_ParameterTesterHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::ParamMod::ParameterTester::object_seq_type ami_return_val;
      ::ParamMod::ParameterTester::object_array_type inoutarg;
      ::ParamMod::ParameterTester::object_array_type_forany _tao_forany_inoutarg (
          inoutarg
        );
      ::ParamMod::ParameterTester::object_union_type outarg;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val) &&
            (_tao_in >> _tao_forany_inoutarg) &&
            (_tao_in >> outarg)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->parameter_tester_op (
          
          ami_return_val,
          
          inoutarg,
          
          outarg
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] =
      {
        {
          "IDL:ParamMod/ParameterTester/object_excep_type:1.0",
          ParamMod::ParameterTester::object_excep_type::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , ParamMod::ParameterTester::_tc_object_excep_type
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            1,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->parameter_tester_op_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
ParamMod::AMI_ParameterTesterHandler::parameter_tester_op_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  static TAO::Exception_Data
  _tao_ParamMod_AMI_ParameterTesterHandler_parameter_tester_op_excep_exceptiondata [] = 
    {
      {
        "IDL:ParamMod/ParameterTester/object_excep_type:1.0",
        ParamMod::ParameterTester::object_excep_type::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , ParamMod::ParameterTester::_tc_object_excep_type
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "parameter_tester_op_excep",
      25,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (
      _tao_ParamMod_AMI_ParameterTesterHandler_parameter_tester_op_excep_exceptiondata,
      1
    );
}

ParamMod::AMI_ParameterTesterHandler::AMI_ParameterTesterHandler ()
{
}
void
ParamMod::AMI_ParameterTesterHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_ParameterTesterHandler *_tao_tmp_pointer =
    static_cast<AMI_ParameterTesterHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

ParamMod::AMI_ParameterTesterHandler_ptr
ParamMod::AMI_ParameterTesterHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_ParameterTesterHandler>::narrow (_tao_objref, "IDL:ParamMod/AMI_ParameterTesterHandler:1.0");
}

ParamMod::AMI_ParameterTesterHandler_ptr
ParamMod::AMI_ParameterTesterHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_ParameterTesterHandler>::unchecked_narrow (_tao_objref);
}

ParamMod::AMI_ParameterTesterHandler_ptr
ParamMod::AMI_ParameterTesterHandler::_nil ()
{
  return nullptr;
}

ParamMod::AMI_ParameterTesterHandler_ptr
ParamMod::AMI_ParameterTesterHandler::_duplicate (AMI_ParameterTesterHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
ParamMod::AMI_ParameterTesterHandler::_tao_release (AMI_ParameterTesterHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
ParamMod::AMI_ParameterTesterHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:ParamMod/AMI_ParameterTesterHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* ParamMod::AMI_ParameterTesterHandler::_interface_repository_id () const
{
  return "IDL:ParamMod/AMI_ParameterTesterHandler:1.0";
}

const char* ParamMod::AMI_ParameterTesterHandler::_desc_repository_id ()
{
  return "IDL:ParamMod/AMI_ParameterTesterHandler:1.0";
}

const char* ParamMod::AMI_ParameterTesterHandler::_desc_interface_name ()
{
  return "AMI_ParameterTesterHandler";
}

::CORBA::Boolean
ParamMod::AMI_ParameterTesterHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_ParamMod_AMI_ParameterTesterHandler (
    ::CORBA::tk_objref,
    "IDL:ParamMod/AMI_ParameterTesterHandler:1.0",
    "AMI_ParameterTesterHandler");
  

namespace ParamMod
{
  ::CORBA::TypeCode_ptr const _tc_AMI_ParameterTesterHandler =
    &_tao_tc_ParamMod_AMI_ParameterTesterHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for testlocal.

testlocal_ptr
TAO::Objref_Traits<testlocal>::duplicate (testlocal_ptr p)
{
  return testlocal::_duplicate (p);
}

void
TAO::Objref_Traits<testlocal>::release (testlocal_ptr p)
{
  ::CORBA::release (p);
}

testlocal_ptr
TAO::Objref_Traits<testlocal>::nil ()
{
  return testlocal::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<testlocal>::marshal (const testlocal_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



testlocal::testlocal ()
{}void
testlocal::_tao_any_destructor (void *_tao_void_pointer)
{
  testlocal *_tao_tmp_pointer =
    static_cast<testlocal *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

testlocal_ptr
testlocal::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return testlocal::_duplicate (
      dynamic_cast<testlocal_ptr> (_tao_objref));
}

testlocal_ptr
testlocal::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return testlocal::_duplicate (
      dynamic_cast<testlocal_ptr> (_tao_objref));
}

testlocal_ptr
testlocal::_nil ()
{
  return nullptr;
}

testlocal_ptr
testlocal::_duplicate (testlocal_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
testlocal::_tao_release (testlocal_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
testlocal::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:testlocal:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* testlocal::_interface_repository_id () const
{
  return "IDL:testlocal:1.0";
}

const char* testlocal::_desc_repository_id ()
{
  return "IDL:testlocal:1.0";
}

const char* testlocal::_desc_interface_name ()
{
  return "testlocal";
}

::CORBA::Boolean
testlocal::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_testlocal (
    ::CORBA::tk_local_interface,
    "IDL:testlocal:1.0",
    "testlocal");
  
::CORBA::TypeCode_ptr const _tc_testlocal =
  &_tao_tc_testlocal;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for A.

A_ptr
TAO::Objref_Traits<A>::duplicate (A_ptr p)
{
  return A::_duplicate (p);
}

void
TAO::Objref_Traits<A>::release (A_ptr p)
{
  ::CORBA::release (p);
}

A_ptr
TAO::Objref_Traits<A>::nil ()
{
  return A::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<A>::marshal (const A_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/union_cs.cpp:75



A::U::U ()
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = false;
}

A::U::U (const ::A::U &u)
{
  this->disc_ = u.disc_;
  
  if (this->disc_)
    {
      if (!u.u_.aa_)
        {
          this->u_.aa_ = nullptr;
        }
      else
        {
          typedef A_var OBJECT_FIELD;
          ACE_NEW (
              this->u_.aa_,
              OBJECT_FIELD (
                  A::_duplicate (
                      u.u_.aa_->in ()
                    )
                )
            );
        }
    }
  
}

A::U::~U ()
{
  // Finalize.
  this->_reset ();
}

void A::U::_tao_any_destructor (void *_tao_void_pointer)
{
  U *tmp =
    static_cast<U *> (_tao_void_pointer);
  delete tmp;
}

A::U &
A::U::operator= (const ::A::U &u)
{
  if (std::addressof(u) == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  
  if (this->disc_)
    {
      if (!u.u_.aa_)
        {
          this->u_.aa_ = nullptr;
        }
      else
        {
          typedef A_var OBJECT_FIELD;
          ACE_NEW_RETURN (
              this->u_.aa_,
              OBJECT_FIELD (
                  A::_duplicate (
                      u.u_.aa_->in ()
                    )
                ),
              *this);
        }
    }
  
  return *this;
}

/// Reset method to reset old values of a union.
void A::U::_reset ()
{
  
  if (this->disc_)
    {
      delete this->u_.aa_;
      this->u_.aa_ = nullptr;
      
    }
  
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/union_typecode.cpp:63

static TAO::TypeCode::Case_T<CORBA::Boolean, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_A_U__0 (true, "aa", &_tc_A);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_A_U[] =
  {
    &_tao_cases_A_U__0
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_A_U (
    "IDL:A/U:1.0",
    "U",
    &CORBA::_tc_boolean,
    _tao_cases_A_U,
    sizeof (_tao_cases_A_U)/sizeof (_tao_cases_A_U[0]),
    -1);
  
::CORBA::TypeCode_ptr const A::_tc_U =
  &_tao_tc_A_U;

A::A ()
{
}
void
A::_tao_any_destructor (void *_tao_void_pointer)
{
  A *_tao_tmp_pointer =
    static_cast<A *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

A_ptr
A::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<A>::narrow (_tao_objref, "IDL:A:1.0");
}

A_ptr
A::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<A>::unchecked_narrow (_tao_objref);
}

A_ptr
A::_nil ()
{
  return nullptr;
}

A_ptr
A::_duplicate (A_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
A::_tao_release (A_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
A::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:A:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* A::_interface_repository_id () const
{
  return "IDL:A:1.0";
}

const char* A::_desc_repository_id ()
{
  return "IDL:A:1.0";
}

const char* A::_desc_interface_name ()
{
  return "A";
}

::CORBA::Boolean
A::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_A (
    ::CORBA::tk_objref,
    "IDL:A:1.0",
    "A");
  
::CORBA::TypeCode_ptr const _tc_A =
  &_tao_tc_A;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_AExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_AExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_AExceptionHolder:1.0",
    "AMH_AExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_AExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_AExceptionHolder =
  &_tao_tc_AMH_AExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_AExceptionHolder>::add_ref (AMH_AExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_AExceptionHolder>::remove_ref (AMH_AExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_AExceptionHolder>::release (AMH_AExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_AExceptionHolder *
AMH_AExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_AExceptionHolder *> (v);
}

const char *
AMH_AExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_AExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_AExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_AExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_AExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_AExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_AExceptionHolder;
}

AMH_AExceptionHolder::~AMH_AExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_AExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_AExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_AExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_AExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_AExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_AExceptionHolder::_tao_marshal__AMH_AExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_AExceptionHolder::_tao_unmarshal__AMH_AExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_AExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_AExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_AExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_AExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_AExceptionHolder_init::AMH_AExceptionHolder_init ()
{
}

AMH_AExceptionHolder_init::~AMH_AExceptionHolder_init ()
{
}

AMH_AExceptionHolder_init *
AMH_AExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_AExceptionHolder_init *> (v);
}

const char*
AMH_AExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_AExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_AExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_AExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_AResponseHandler.

AMH_AResponseHandler_ptr
TAO::Objref_Traits<AMH_AResponseHandler>::duplicate (AMH_AResponseHandler_ptr p)
{
  return AMH_AResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_AResponseHandler>::release (AMH_AResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_AResponseHandler_ptr
TAO::Objref_Traits<AMH_AResponseHandler>::nil ()
{
  return AMH_AResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_AResponseHandler>::marshal (const AMH_AResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_AResponseHandler::AMH_AResponseHandler ()
{}void
AMH_AResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_AResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_AResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_AResponseHandler_ptr
AMH_AResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_AResponseHandler::_duplicate (
      dynamic_cast<AMH_AResponseHandler_ptr> (_tao_objref));
}

AMH_AResponseHandler_ptr
AMH_AResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_AResponseHandler::_duplicate (
      dynamic_cast<AMH_AResponseHandler_ptr> (_tao_objref));
}

AMH_AResponseHandler_ptr
AMH_AResponseHandler::_nil ()
{
  return nullptr;
}

AMH_AResponseHandler_ptr
AMH_AResponseHandler::_duplicate (AMH_AResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_AResponseHandler::_tao_release (AMH_AResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_AResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_AResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_AResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_AResponseHandler:1.0";
}

const char* AMH_AResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_AResponseHandler:1.0";
}

const char* AMH_AResponseHandler::_desc_interface_name ()
{
  return "AMH_AResponseHandler";
}

::CORBA::Boolean
AMH_AResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_AResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_AResponseHandler:1.0",
    "AMH_AResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_AResponseHandler =
  &_tao_tc_AMH_AResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_AHandler.

AMI_AHandler_ptr
TAO::Objref_Traits<AMI_AHandler>::duplicate (AMI_AHandler_ptr p)
{
  return AMI_AHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_AHandler>::release (AMI_AHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_AHandler_ptr
TAO::Objref_Traits<AMI_AHandler>::nil ()
{
  return AMI_AHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_AHandler>::marshal (const AMI_AHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_AHandler::AMI_AHandler ()
{
}
void
AMI_AHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_AHandler *_tao_tmp_pointer =
    static_cast<AMI_AHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_AHandler_ptr
AMI_AHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_AHandler>::narrow (_tao_objref, "IDL:AMI_AHandler:1.0");
}

AMI_AHandler_ptr
AMI_AHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_AHandler>::unchecked_narrow (_tao_objref);
}

AMI_AHandler_ptr
AMI_AHandler::_nil ()
{
  return nullptr;
}

AMI_AHandler_ptr
AMI_AHandler::_duplicate (AMI_AHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_AHandler::_tao_release (AMI_AHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_AHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_AHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_AHandler::_interface_repository_id () const
{
  return "IDL:AMI_AHandler:1.0";
}

const char* AMI_AHandler::_desc_repository_id ()
{
  return "IDL:AMI_AHandler:1.0";
}

const char* AMI_AHandler::_desc_interface_name ()
{
  return "AMI_AHandler";
}

::CORBA::Boolean
AMI_AHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_AHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_AHandler:1.0",
    "AMI_AHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_AHandler =
  &_tao_tc_AMI_AHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M::A.

M::A_ptr
TAO::Objref_Traits<M::A>::duplicate (M::A_ptr p)
{
  return M::A::_duplicate (p);
}

void
TAO::Objref_Traits<M::A>::release (M::A_ptr p)
{
  ::CORBA::release (p);
}

M::A_ptr
TAO::Objref_Traits<M::A>::nil ()
{
  return M::A::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M::A>::marshal (const M::A_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



M::A::A ()
{
}
void
M::A::_tao_any_destructor (void *_tao_void_pointer)
{
  A *_tao_tmp_pointer =
    static_cast<A *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M::A_ptr
M::A::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<A>::narrow (_tao_objref, "IDL:M/A:1.0");
}

M::A_ptr
M::A::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<A>::unchecked_narrow (_tao_objref);
}

M::A_ptr
M::A::_nil ()
{
  return nullptr;
}

M::A_ptr
M::A::_duplicate (A_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M::A::_tao_release (A_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M::A::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M/A:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* M::A::_interface_repository_id () const
{
  return "IDL:M/A:1.0";
}

const char* M::A::_desc_repository_id ()
{
  return "IDL:M/A:1.0";
}

const char* M::A::_desc_interface_name ()
{
  return "A";
}

::CORBA::Boolean
M::A::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M_A (
    ::CORBA::tk_objref,
    "IDL:M/A:1.0",
    "A");
  

namespace M
{
  ::CORBA::TypeCode_ptr const _tc_A =
    &_tao_tc_M_A;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_M_AMH_AExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_M_AMH_AExceptionHolder (
    ::CORBA::tk_value,
    "IDL:M/AMH_AExceptionHolder:1.0",
    "AMH_AExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_M_AMH_AExceptionHolder,
    0);
  

namespace M
{
  ::CORBA::TypeCode_ptr const _tc_AMH_AExceptionHolder =
    &_tao_tc_M_AMH_AExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<M::AMH_AExceptionHolder>::add_ref (M::AMH_AExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<M::AMH_AExceptionHolder>::remove_ref (M::AMH_AExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<M::AMH_AExceptionHolder>::release (M::AMH_AExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



M::AMH_AExceptionHolder *
M::AMH_AExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::M::AMH_AExceptionHolder *> (v);
}

const char *
M::AMH_AExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
M::AMH_AExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
M::AMH_AExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_AExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_AExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr M::AMH_AExceptionHolder::_tao_type () const
{
  return ::M::_tc_AMH_AExceptionHolder;
}

M::AMH_AExceptionHolder::~AMH_AExceptionHolder ()
{}

::CORBA::ValueBase *
M::AMH_AExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_AExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
M::AMH_AExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
M::AMH_AExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
M::AMH_AExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
M::AMH_AExceptionHolder::_tao_marshal__M_AMH_AExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
M::AMH_AExceptionHolder::_tao_unmarshal__M_AMH_AExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
M::AMH_AExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_AExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_AExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_AExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



M::AMH_AExceptionHolder_init::AMH_AExceptionHolder_init ()
{
}

M::AMH_AExceptionHolder_init::~AMH_AExceptionHolder_init ()
{
}

M::AMH_AExceptionHolder_init *
M::AMH_AExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::M::AMH_AExceptionHolder_init *> (v);
}

const char*
M::AMH_AExceptionHolder_init::tao_repository_id ()
{
  return ::M::AMH_AExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
M::AMH_AExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_M::AMH_AExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M::AMH_AResponseHandler.

M::AMH_AResponseHandler_ptr
TAO::Objref_Traits<M::AMH_AResponseHandler>::duplicate (M::AMH_AResponseHandler_ptr p)
{
  return M::AMH_AResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<M::AMH_AResponseHandler>::release (M::AMH_AResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

M::AMH_AResponseHandler_ptr
TAO::Objref_Traits<M::AMH_AResponseHandler>::nil ()
{
  return M::AMH_AResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M::AMH_AResponseHandler>::marshal (const M::AMH_AResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



M::AMH_AResponseHandler::AMH_AResponseHandler ()
{}void
M::AMH_AResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_AResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_AResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M::AMH_AResponseHandler_ptr
M::AMH_AResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_AResponseHandler::_duplicate (
      dynamic_cast<AMH_AResponseHandler_ptr> (_tao_objref));
}

M::AMH_AResponseHandler_ptr
M::AMH_AResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_AResponseHandler::_duplicate (
      dynamic_cast<AMH_AResponseHandler_ptr> (_tao_objref));
}

M::AMH_AResponseHandler_ptr
M::AMH_AResponseHandler::_nil ()
{
  return nullptr;
}

M::AMH_AResponseHandler_ptr
M::AMH_AResponseHandler::_duplicate (AMH_AResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M::AMH_AResponseHandler::_tao_release (AMH_AResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M::AMH_AResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M/AMH_AResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* M::AMH_AResponseHandler::_interface_repository_id () const
{
  return "IDL:M/AMH_AResponseHandler:1.0";
}

const char* M::AMH_AResponseHandler::_desc_repository_id ()
{
  return "IDL:M/AMH_AResponseHandler:1.0";
}

const char* M::AMH_AResponseHandler::_desc_interface_name ()
{
  return "AMH_AResponseHandler";
}

::CORBA::Boolean
M::AMH_AResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M_AMH_AResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:M/AMH_AResponseHandler:1.0",
    "AMH_AResponseHandler");
  

namespace M
{
  ::CORBA::TypeCode_ptr const _tc_AMH_AResponseHandler =
    &_tao_tc_M_AMH_AResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M::AMI_AHandler.

M::AMI_AHandler_ptr
TAO::Objref_Traits<M::AMI_AHandler>::duplicate (M::AMI_AHandler_ptr p)
{
  return M::AMI_AHandler::_duplicate (p);
}

void
TAO::Objref_Traits<M::AMI_AHandler>::release (M::AMI_AHandler_ptr p)
{
  ::CORBA::release (p);
}

M::AMI_AHandler_ptr
TAO::Objref_Traits<M::AMI_AHandler>::nil ()
{
  return M::AMI_AHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M::AMI_AHandler>::marshal (const M::AMI_AHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



M::AMI_AHandler::AMI_AHandler ()
{
}
void
M::AMI_AHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_AHandler *_tao_tmp_pointer =
    static_cast<AMI_AHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

M::AMI_AHandler_ptr
M::AMI_AHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_AHandler>::narrow (_tao_objref, "IDL:M/AMI_AHandler:1.0");
}

M::AMI_AHandler_ptr
M::AMI_AHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_AHandler>::unchecked_narrow (_tao_objref);
}

M::AMI_AHandler_ptr
M::AMI_AHandler::_nil ()
{
  return nullptr;
}

M::AMI_AHandler_ptr
M::AMI_AHandler::_duplicate (AMI_AHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M::AMI_AHandler::_tao_release (AMI_AHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M::AMI_AHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:M/AMI_AHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* M::AMI_AHandler::_interface_repository_id () const
{
  return "IDL:M/AMI_AHandler:1.0";
}

const char* M::AMI_AHandler::_desc_repository_id ()
{
  return "IDL:M/AMI_AHandler:1.0";
}

const char* M::AMI_AHandler::_desc_interface_name ()
{
  return "AMI_AHandler";
}

::CORBA::Boolean
M::AMI_AHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M_AMI_AHandler (
    ::CORBA::tk_objref,
    "IDL:M/AMI_AHandler:1.0",
    "AMI_AHandler");
  

namespace M
{
  ::CORBA::TypeCode_ptr const _tc_AMI_AHandler =
    &_tao_tc_M_AMI_AHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for i1::if1.

i1::if1_ptr
TAO::Objref_Traits<i1::if1>::duplicate (i1::if1_ptr p)
{
  return i1::if1::_duplicate (p);
}

void
TAO::Objref_Traits<i1::if1>::release (i1::if1_ptr p)
{
  ::CORBA::release (p);
}

i1::if1_ptr
TAO::Objref_Traits<i1::if1>::nil ()
{
  return i1::if1::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<i1::if1>::marshal (const i1::if1_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

char *
i1::if1::getStr ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "getStr",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
i1::if1::sendc_getStr (
  ::i1::AMI_if1Handler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "getStr",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &i1::AMI_if1Handler::getStr_reply_stub
    );
}

i1::if1::if1 ()
{
}
void
i1::if1::_tao_any_destructor (void *_tao_void_pointer)
{
  if1 *_tao_tmp_pointer =
    static_cast<if1 *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

i1::if1_ptr
i1::if1::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<if1>::narrow (_tao_objref, "IDL:i1/if1:1.0");
}

i1::if1_ptr
i1::if1::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<if1>::unchecked_narrow (_tao_objref);
}

i1::if1_ptr
i1::if1::_nil ()
{
  return nullptr;
}

i1::if1_ptr
i1::if1::_duplicate (if1_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
i1::if1::_tao_release (if1_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
i1::if1::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:i1/if1:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* i1::if1::_interface_repository_id () const
{
  return "IDL:i1/if1:1.0";
}

const char* i1::if1::_desc_repository_id ()
{
  return "IDL:i1/if1:1.0";
}

const char* i1::if1::_desc_interface_name ()
{
  return "if1";
}

::CORBA::Boolean
i1::if1::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_i1_if1 (
    ::CORBA::tk_objref,
    "IDL:i1/if1:1.0",
    "if1");
  

namespace i1
{
  ::CORBA::TypeCode_ptr const _tc_if1 =
    &_tao_tc_i1_if1;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_i1_AMH_if1ExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_i1_AMH_if1ExceptionHolder (
    ::CORBA::tk_value,
    "IDL:i1/AMH_if1ExceptionHolder:1.0",
    "AMH_if1ExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_i1_AMH_if1ExceptionHolder,
    0);
  

namespace i1
{
  ::CORBA::TypeCode_ptr const _tc_AMH_if1ExceptionHolder =
    &_tao_tc_i1_AMH_if1ExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<i1::AMH_if1ExceptionHolder>::add_ref (i1::AMH_if1ExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<i1::AMH_if1ExceptionHolder>::remove_ref (i1::AMH_if1ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<i1::AMH_if1ExceptionHolder>::release (i1::AMH_if1ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



i1::AMH_if1ExceptionHolder *
i1::AMH_if1ExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::i1::AMH_if1ExceptionHolder *> (v);
}

const char *
i1::AMH_if1ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
i1::AMH_if1ExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
i1::AMH_if1ExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_if1ExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_if1ExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr i1::AMH_if1ExceptionHolder::_tao_type () const
{
  return ::i1::_tc_AMH_if1ExceptionHolder;
}

i1::AMH_if1ExceptionHolder::~AMH_if1ExceptionHolder ()
{}

::CORBA::ValueBase *
i1::AMH_if1ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_if1ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
i1::AMH_if1ExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
i1::AMH_if1ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
i1::AMH_if1ExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
i1::AMH_if1ExceptionHolder::_tao_marshal__i1_AMH_if1ExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
i1::AMH_if1ExceptionHolder::_tao_unmarshal__i1_AMH_if1ExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
i1::AMH_if1ExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_if1ExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_if1ExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_if1ExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
i1::AMH_if1ExceptionHolder::raise_getStr ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
i1::AMH_if1ExceptionHolder::raise_sendc_getStr ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for i1::AMH_if1ResponseHandler.

i1::AMH_if1ResponseHandler_ptr
TAO::Objref_Traits<i1::AMH_if1ResponseHandler>::duplicate (i1::AMH_if1ResponseHandler_ptr p)
{
  return i1::AMH_if1ResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<i1::AMH_if1ResponseHandler>::release (i1::AMH_if1ResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

i1::AMH_if1ResponseHandler_ptr
TAO::Objref_Traits<i1::AMH_if1ResponseHandler>::nil ()
{
  return i1::AMH_if1ResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<i1::AMH_if1ResponseHandler>::marshal (const i1::AMH_if1ResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



i1::AMH_if1ResponseHandler::AMH_if1ResponseHandler ()
{}void
i1::AMH_if1ResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_if1ResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_if1ResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

i1::AMH_if1ResponseHandler_ptr
i1::AMH_if1ResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_if1ResponseHandler::_duplicate (
      dynamic_cast<AMH_if1ResponseHandler_ptr> (_tao_objref));
}

i1::AMH_if1ResponseHandler_ptr
i1::AMH_if1ResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_if1ResponseHandler::_duplicate (
      dynamic_cast<AMH_if1ResponseHandler_ptr> (_tao_objref));
}

i1::AMH_if1ResponseHandler_ptr
i1::AMH_if1ResponseHandler::_nil ()
{
  return nullptr;
}

i1::AMH_if1ResponseHandler_ptr
i1::AMH_if1ResponseHandler::_duplicate (AMH_if1ResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
i1::AMH_if1ResponseHandler::_tao_release (AMH_if1ResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
i1::AMH_if1ResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:i1/AMH_if1ResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* i1::AMH_if1ResponseHandler::_interface_repository_id () const
{
  return "IDL:i1/AMH_if1ResponseHandler:1.0";
}

const char* i1::AMH_if1ResponseHandler::_desc_repository_id ()
{
  return "IDL:i1/AMH_if1ResponseHandler:1.0";
}

const char* i1::AMH_if1ResponseHandler::_desc_interface_name ()
{
  return "AMH_if1ResponseHandler";
}

::CORBA::Boolean
i1::AMH_if1ResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_i1_AMH_if1ResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:i1/AMH_if1ResponseHandler:1.0",
    "AMH_if1ResponseHandler");
  

namespace i1
{
  ::CORBA::TypeCode_ptr const _tc_AMH_if1ResponseHandler =
    &_tao_tc_i1_AMH_if1ResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for i1::AMI_if1Handler.

i1::AMI_if1Handler_ptr
TAO::Objref_Traits<i1::AMI_if1Handler>::duplicate (i1::AMI_if1Handler_ptr p)
{
  return i1::AMI_if1Handler::_duplicate (p);
}

void
TAO::Objref_Traits<i1::AMI_if1Handler>::release (i1::AMI_if1Handler_ptr p)
{
  ::CORBA::release (p);
}

i1::AMI_if1Handler_ptr
TAO::Objref_Traits<i1::AMI_if1Handler>::nil ()
{
  return i1::AMI_if1Handler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<i1::AMI_if1Handler>::marshal (const i1::AMI_if1Handler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
i1::AMI_if1Handler::getStr (
  const char * ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getStr",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
i1::AMI_if1Handler::getStr_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  i1::AMI_if1Handler_var _tao_reply_handler_object =
    i1::AMI_if1Handler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::String_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->getStr (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->getStr_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
i1::AMI_if1Handler::getStr_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getStr_excep",
      12,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

i1::AMI_if1Handler::AMI_if1Handler ()
{
}
void
i1::AMI_if1Handler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_if1Handler *_tao_tmp_pointer =
    static_cast<AMI_if1Handler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

i1::AMI_if1Handler_ptr
i1::AMI_if1Handler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_if1Handler>::narrow (_tao_objref, "IDL:i1/AMI_if1Handler:1.0");
}

i1::AMI_if1Handler_ptr
i1::AMI_if1Handler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_if1Handler>::unchecked_narrow (_tao_objref);
}

i1::AMI_if1Handler_ptr
i1::AMI_if1Handler::_nil ()
{
  return nullptr;
}

i1::AMI_if1Handler_ptr
i1::AMI_if1Handler::_duplicate (AMI_if1Handler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
i1::AMI_if1Handler::_tao_release (AMI_if1Handler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
i1::AMI_if1Handler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:i1/AMI_if1Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* i1::AMI_if1Handler::_interface_repository_id () const
{
  return "IDL:i1/AMI_if1Handler:1.0";
}

const char* i1::AMI_if1Handler::_desc_repository_id ()
{
  return "IDL:i1/AMI_if1Handler:1.0";
}

const char* i1::AMI_if1Handler::_desc_interface_name ()
{
  return "AMI_if1Handler";
}

::CORBA::Boolean
i1::AMI_if1Handler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_i1_AMI_if1Handler (
    ::CORBA::tk_objref,
    "IDL:i1/AMI_if1Handler:1.0",
    "AMI_if1Handler");
  

namespace i1
{
  ::CORBA::TypeCode_ptr const _tc_AMI_if1Handler =
    &_tao_tc_i1_AMI_if1Handler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for i2::if2.

i2::if2_ptr
TAO::Objref_Traits<i2::if2>::duplicate (i2::if2_ptr p)
{
  return i2::if2::_duplicate (p);
}

void
TAO::Objref_Traits<i2::if2>::release (i2::if2_ptr p)
{
  ::CORBA::release (p);
}

i2::if2_ptr
TAO::Objref_Traits<i2::if2>::nil ()
{
  return i2::if2::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<i2::if2>::marshal (const i2::if2_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

char *
i2::if2::getstr2 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "getstr2",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
i2::if2::sendc_getstr2 (
  ::i2::AMI_if2Handler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "getstr2",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &i2::AMI_if2Handler::getstr2_reply_stub
    );
}

i2::if2::if2 ()
{
}
void
i2::if2::_tao_any_destructor (void *_tao_void_pointer)
{
  if2 *_tao_tmp_pointer =
    static_cast<if2 *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

i2::if2_ptr
i2::if2::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<if2>::narrow (_tao_objref, "IDL:i2/if2:1.0");
}

i2::if2_ptr
i2::if2::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<if2>::unchecked_narrow (_tao_objref);
}

i2::if2_ptr
i2::if2::_nil ()
{
  return nullptr;
}

i2::if2_ptr
i2::if2::_duplicate (if2_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
i2::if2::_tao_release (if2_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
i2::if2::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:i1/if1:1.0") == 0 ||
      std::strcmp (value, "IDL:i2/if2:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* i2::if2::_interface_repository_id () const
{
  return "IDL:i2/if2:1.0";
}

const char* i2::if2::_desc_repository_id ()
{
  return "IDL:i2/if2:1.0";
}

const char* i2::if2::_desc_interface_name ()
{
  return "if2";
}

::CORBA::Boolean
i2::if2::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_i2_if2 (
    ::CORBA::tk_objref,
    "IDL:i2/if2:1.0",
    "if2");
  

namespace i2
{
  ::CORBA::TypeCode_ptr const _tc_if2 =
    &_tao_tc_i2_if2;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_i2_AMH_if2ExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_i2_AMH_if2ExceptionHolder (
    ::CORBA::tk_value,
    "IDL:i2/AMH_if2ExceptionHolder:1.0",
    "AMH_if2ExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_i2_AMH_if2ExceptionHolder,
    0);
  

namespace i2
{
  ::CORBA::TypeCode_ptr const _tc_AMH_if2ExceptionHolder =
    &_tao_tc_i2_AMH_if2ExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<i2::AMH_if2ExceptionHolder>::add_ref (i2::AMH_if2ExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<i2::AMH_if2ExceptionHolder>::remove_ref (i2::AMH_if2ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<i2::AMH_if2ExceptionHolder>::release (i2::AMH_if2ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



i2::AMH_if2ExceptionHolder *
i2::AMH_if2ExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::i2::AMH_if2ExceptionHolder *> (v);
}

const char *
i2::AMH_if2ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
i2::AMH_if2ExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
i2::AMH_if2ExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_if2ExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_if2ExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr i2::AMH_if2ExceptionHolder::_tao_type () const
{
  return ::i2::_tc_AMH_if2ExceptionHolder;
}

i2::AMH_if2ExceptionHolder::~AMH_if2ExceptionHolder ()
{}

::CORBA::ValueBase *
i2::AMH_if2ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_if2ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
i2::AMH_if2ExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
i2::AMH_if2ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
i2::AMH_if2ExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
i2::AMH_if2ExceptionHolder::_tao_marshal__i2_AMH_if2ExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
i2::AMH_if2ExceptionHolder::_tao_unmarshal__i2_AMH_if2ExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
i2::AMH_if2ExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_if2ExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_if2ExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_if2ExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
i2::AMH_if2ExceptionHolder::raise_getstr2 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
i2::AMH_if2ExceptionHolder::raise_sendc_getstr2 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for i2::AMH_if2ResponseHandler.

i2::AMH_if2ResponseHandler_ptr
TAO::Objref_Traits<i2::AMH_if2ResponseHandler>::duplicate (i2::AMH_if2ResponseHandler_ptr p)
{
  return i2::AMH_if2ResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<i2::AMH_if2ResponseHandler>::release (i2::AMH_if2ResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

i2::AMH_if2ResponseHandler_ptr
TAO::Objref_Traits<i2::AMH_if2ResponseHandler>::nil ()
{
  return i2::AMH_if2ResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<i2::AMH_if2ResponseHandler>::marshal (const i2::AMH_if2ResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



i2::AMH_if2ResponseHandler::AMH_if2ResponseHandler ()
{}void
i2::AMH_if2ResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_if2ResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_if2ResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

i2::AMH_if2ResponseHandler_ptr
i2::AMH_if2ResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_if2ResponseHandler::_duplicate (
      dynamic_cast<AMH_if2ResponseHandler_ptr> (_tao_objref));
}

i2::AMH_if2ResponseHandler_ptr
i2::AMH_if2ResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_if2ResponseHandler::_duplicate (
      dynamic_cast<AMH_if2ResponseHandler_ptr> (_tao_objref));
}

i2::AMH_if2ResponseHandler_ptr
i2::AMH_if2ResponseHandler::_nil ()
{
  return nullptr;
}

i2::AMH_if2ResponseHandler_ptr
i2::AMH_if2ResponseHandler::_duplicate (AMH_if2ResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
i2::AMH_if2ResponseHandler::_tao_release (AMH_if2ResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
i2::AMH_if2ResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:i2/AMH_if2ResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* i2::AMH_if2ResponseHandler::_interface_repository_id () const
{
  return "IDL:i2/AMH_if2ResponseHandler:1.0";
}

const char* i2::AMH_if2ResponseHandler::_desc_repository_id ()
{
  return "IDL:i2/AMH_if2ResponseHandler:1.0";
}

const char* i2::AMH_if2ResponseHandler::_desc_interface_name ()
{
  return "AMH_if2ResponseHandler";
}

::CORBA::Boolean
i2::AMH_if2ResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_i2_AMH_if2ResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:i2/AMH_if2ResponseHandler:1.0",
    "AMH_if2ResponseHandler");
  

namespace i2
{
  ::CORBA::TypeCode_ptr const _tc_AMH_if2ResponseHandler =
    &_tao_tc_i2_AMH_if2ResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for i2::AMI_if2Handler.

i2::AMI_if2Handler_ptr
TAO::Objref_Traits<i2::AMI_if2Handler>::duplicate (i2::AMI_if2Handler_ptr p)
{
  return i2::AMI_if2Handler::_duplicate (p);
}

void
TAO::Objref_Traits<i2::AMI_if2Handler>::release (i2::AMI_if2Handler_ptr p)
{
  ::CORBA::release (p);
}

i2::AMI_if2Handler_ptr
TAO::Objref_Traits<i2::AMI_if2Handler>::nil ()
{
  return i2::AMI_if2Handler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<i2::AMI_if2Handler>::marshal (const i2::AMI_if2Handler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
i2::AMI_if2Handler::getstr2 (
  const char * ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getstr2",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
i2::AMI_if2Handler::getstr2_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  i2::AMI_if2Handler_var _tao_reply_handler_object =
    i2::AMI_if2Handler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::String_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->getstr2 (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->getstr2_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
i2::AMI_if2Handler::getstr2_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getstr2_excep",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

i2::AMI_if2Handler::AMI_if2Handler ()
{
}
void
i2::AMI_if2Handler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_if2Handler *_tao_tmp_pointer =
    static_cast<AMI_if2Handler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

i2::AMI_if2Handler_ptr
i2::AMI_if2Handler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_if2Handler>::narrow (_tao_objref, "IDL:i2/AMI_if2Handler:1.0");
}

i2::AMI_if2Handler_ptr
i2::AMI_if2Handler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_if2Handler>::unchecked_narrow (_tao_objref);
}

i2::AMI_if2Handler_ptr
i2::AMI_if2Handler::_nil ()
{
  return nullptr;
}

i2::AMI_if2Handler_ptr
i2::AMI_if2Handler::_duplicate (AMI_if2Handler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
i2::AMI_if2Handler::_tao_release (AMI_if2Handler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
i2::AMI_if2Handler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:i1/AMI_if1Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:i2/AMI_if2Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* i2::AMI_if2Handler::_interface_repository_id () const
{
  return "IDL:i2/AMI_if2Handler:1.0";
}

const char* i2::AMI_if2Handler::_desc_repository_id ()
{
  return "IDL:i2/AMI_if2Handler:1.0";
}

const char* i2::AMI_if2Handler::_desc_interface_name ()
{
  return "AMI_if2Handler";
}

::CORBA::Boolean
i2::AMI_if2Handler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_i2_AMI_if2Handler (
    ::CORBA::tk_objref,
    "IDL:i2/AMI_if2Handler:1.0",
    "AMI_if2Handler");
  

namespace i2
{
  ::CORBA::TypeCode_ptr const _tc_AMI_if2Handler =
    &_tao_tc_i2_AMI_if2Handler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for i2::if3.

i2::if3_ptr
TAO::Objref_Traits<i2::if3>::duplicate (i2::if3_ptr p)
{
  return i2::if3::_duplicate (p);
}

void
TAO::Objref_Traits<i2::if3>::release (i2::if3_ptr p)
{
  ::CORBA::release (p);
}

i2::if3_ptr
TAO::Objref_Traits<i2::if3>::nil ()
{
  return i2::if3::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<i2::if3>::marshal (const i2::if3_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

char *
i2::if3::getstr3 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "getstr3",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
i2::if3::sendc_getstr3 (
  ::i2::AMI_if3Handler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "getstr3",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &i2::AMI_if3Handler::getstr3_reply_stub
    );
}

i2::if3::if3 ()
{
}
void
i2::if3::_tao_any_destructor (void *_tao_void_pointer)
{
  if3 *_tao_tmp_pointer =
    static_cast<if3 *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

i2::if3_ptr
i2::if3::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<if3>::narrow (_tao_objref, "IDL:i2/if3:1.0");
}

i2::if3_ptr
i2::if3::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<if3>::unchecked_narrow (_tao_objref);
}

i2::if3_ptr
i2::if3::_nil ()
{
  return nullptr;
}

i2::if3_ptr
i2::if3::_duplicate (if3_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
i2::if3::_tao_release (if3_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
i2::if3::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:i1/if1:1.0") == 0 ||
      std::strcmp (value, "IDL:i2/if2:1.0") == 0 ||
      std::strcmp (value, "IDL:i2/if3:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* i2::if3::_interface_repository_id () const
{
  return "IDL:i2/if3:1.0";
}

const char* i2::if3::_desc_repository_id ()
{
  return "IDL:i2/if3:1.0";
}

const char* i2::if3::_desc_interface_name ()
{
  return "if3";
}

::CORBA::Boolean
i2::if3::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_i2_if3 (
    ::CORBA::tk_objref,
    "IDL:i2/if3:1.0",
    "if3");
  

namespace i2
{
  ::CORBA::TypeCode_ptr const _tc_if3 =
    &_tao_tc_i2_if3;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_i2_AMH_if3ExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_i2_AMH_if3ExceptionHolder (
    ::CORBA::tk_value,
    "IDL:i2/AMH_if3ExceptionHolder:1.0",
    "AMH_if3ExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_i2_AMH_if3ExceptionHolder,
    0);
  

namespace i2
{
  ::CORBA::TypeCode_ptr const _tc_AMH_if3ExceptionHolder =
    &_tao_tc_i2_AMH_if3ExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<i2::AMH_if3ExceptionHolder>::add_ref (i2::AMH_if3ExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<i2::AMH_if3ExceptionHolder>::remove_ref (i2::AMH_if3ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<i2::AMH_if3ExceptionHolder>::release (i2::AMH_if3ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



i2::AMH_if3ExceptionHolder *
i2::AMH_if3ExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::i2::AMH_if3ExceptionHolder *> (v);
}

const char *
i2::AMH_if3ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
i2::AMH_if3ExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
i2::AMH_if3ExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_if3ExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_if3ExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr i2::AMH_if3ExceptionHolder::_tao_type () const
{
  return ::i2::_tc_AMH_if3ExceptionHolder;
}

i2::AMH_if3ExceptionHolder::~AMH_if3ExceptionHolder ()
{}

::CORBA::ValueBase *
i2::AMH_if3ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_if3ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
i2::AMH_if3ExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
i2::AMH_if3ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
i2::AMH_if3ExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
i2::AMH_if3ExceptionHolder::_tao_marshal__i2_AMH_if3ExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
i2::AMH_if3ExceptionHolder::_tao_unmarshal__i2_AMH_if3ExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
i2::AMH_if3ExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_if3ExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_if3ExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_if3ExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
i2::AMH_if3ExceptionHolder::raise_getstr3 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
i2::AMH_if3ExceptionHolder::raise_sendc_getstr3 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for i2::AMH_if3ResponseHandler.

i2::AMH_if3ResponseHandler_ptr
TAO::Objref_Traits<i2::AMH_if3ResponseHandler>::duplicate (i2::AMH_if3ResponseHandler_ptr p)
{
  return i2::AMH_if3ResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<i2::AMH_if3ResponseHandler>::release (i2::AMH_if3ResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

i2::AMH_if3ResponseHandler_ptr
TAO::Objref_Traits<i2::AMH_if3ResponseHandler>::nil ()
{
  return i2::AMH_if3ResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<i2::AMH_if3ResponseHandler>::marshal (const i2::AMH_if3ResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



i2::AMH_if3ResponseHandler::AMH_if3ResponseHandler ()
{}void
i2::AMH_if3ResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_if3ResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_if3ResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

i2::AMH_if3ResponseHandler_ptr
i2::AMH_if3ResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_if3ResponseHandler::_duplicate (
      dynamic_cast<AMH_if3ResponseHandler_ptr> (_tao_objref));
}

i2::AMH_if3ResponseHandler_ptr
i2::AMH_if3ResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_if3ResponseHandler::_duplicate (
      dynamic_cast<AMH_if3ResponseHandler_ptr> (_tao_objref));
}

i2::AMH_if3ResponseHandler_ptr
i2::AMH_if3ResponseHandler::_nil ()
{
  return nullptr;
}

i2::AMH_if3ResponseHandler_ptr
i2::AMH_if3ResponseHandler::_duplicate (AMH_if3ResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
i2::AMH_if3ResponseHandler::_tao_release (AMH_if3ResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
i2::AMH_if3ResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:i2/AMH_if3ResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* i2::AMH_if3ResponseHandler::_interface_repository_id () const
{
  return "IDL:i2/AMH_if3ResponseHandler:1.0";
}

const char* i2::AMH_if3ResponseHandler::_desc_repository_id ()
{
  return "IDL:i2/AMH_if3ResponseHandler:1.0";
}

const char* i2::AMH_if3ResponseHandler::_desc_interface_name ()
{
  return "AMH_if3ResponseHandler";
}

::CORBA::Boolean
i2::AMH_if3ResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_i2_AMH_if3ResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:i2/AMH_if3ResponseHandler:1.0",
    "AMH_if3ResponseHandler");
  

namespace i2
{
  ::CORBA::TypeCode_ptr const _tc_AMH_if3ResponseHandler =
    &_tao_tc_i2_AMH_if3ResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for i2::AMI_if3Handler.

i2::AMI_if3Handler_ptr
TAO::Objref_Traits<i2::AMI_if3Handler>::duplicate (i2::AMI_if3Handler_ptr p)
{
  return i2::AMI_if3Handler::_duplicate (p);
}

void
TAO::Objref_Traits<i2::AMI_if3Handler>::release (i2::AMI_if3Handler_ptr p)
{
  ::CORBA::release (p);
}

i2::AMI_if3Handler_ptr
TAO::Objref_Traits<i2::AMI_if3Handler>::nil ()
{
  return i2::AMI_if3Handler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<i2::AMI_if3Handler>::marshal (const i2::AMI_if3Handler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
i2::AMI_if3Handler::getstr3 (
  const char * ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getstr3",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
i2::AMI_if3Handler::getstr3_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  i2::AMI_if3Handler_var _tao_reply_handler_object =
    i2::AMI_if3Handler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::String_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->getstr3 (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->getstr3_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
i2::AMI_if3Handler::getstr3_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getstr3_excep",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

i2::AMI_if3Handler::AMI_if3Handler ()
{
}
void
i2::AMI_if3Handler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_if3Handler *_tao_tmp_pointer =
    static_cast<AMI_if3Handler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

i2::AMI_if3Handler_ptr
i2::AMI_if3Handler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_if3Handler>::narrow (_tao_objref, "IDL:i2/AMI_if3Handler:1.0");
}

i2::AMI_if3Handler_ptr
i2::AMI_if3Handler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_if3Handler>::unchecked_narrow (_tao_objref);
}

i2::AMI_if3Handler_ptr
i2::AMI_if3Handler::_nil ()
{
  return nullptr;
}

i2::AMI_if3Handler_ptr
i2::AMI_if3Handler::_duplicate (AMI_if3Handler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
i2::AMI_if3Handler::_tao_release (AMI_if3Handler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
i2::AMI_if3Handler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:i1/AMI_if1Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:i2/AMI_if2Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:i2/AMI_if3Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* i2::AMI_if3Handler::_interface_repository_id () const
{
  return "IDL:i2/AMI_if3Handler:1.0";
}

const char* i2::AMI_if3Handler::_desc_repository_id ()
{
  return "IDL:i2/AMI_if3Handler:1.0";
}

const char* i2::AMI_if3Handler::_desc_interface_name ()
{
  return "AMI_if3Handler";
}

::CORBA::Boolean
i2::AMI_if3Handler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_i2_AMI_if3Handler (
    ::CORBA::tk_objref,
    "IDL:i2/AMI_if3Handler:1.0",
    "AMI_if3Handler");
  

namespace i2
{
  ::CORBA::TypeCode_ptr const _tc_AMI_if3Handler =
    &_tao_tc_i2_AMI_if3Handler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for redefs::base.

redefs::base_ptr
TAO::Objref_Traits<redefs::base>::duplicate (redefs::base_ptr p)
{
  return redefs::base::_duplicate (p);
}

void
TAO::Objref_Traits<redefs::base>::release (redefs::base_ptr p)
{
  ::CORBA::release (p);
}

redefs::base_ptr
TAO::Objref_Traits<redefs::base>::nil ()
{
  return redefs::base::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<redefs::base>::marshal (const redefs::base_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_constant/constant_cs.cpp:53



const CORBA::Long redefs::base::lconst;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



redefs::base::ex::ex (
    const char * _tao_info)
  : ::CORBA::UserException (
        "IDL:redefs/base/ex:1.0",
        "ex")
{
  this->info = ::CORBA::string_dup (_tao_info);
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

redefs::base::ex::ex ()
  : ::CORBA::UserException (
        "IDL:redefs/base/ex:1.0",
        "ex")
{
}

redefs::base::ex::ex (const ::redefs::base::ex &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->info = ::CORBA::string_dup (_tao_excp.info.in ());
}

redefs::base::ex&
redefs::base::ex::operator= (const ::redefs::base::ex &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->info = ::CORBA::string_dup (_tao_excp.info.in ());
  return *this;
}

void redefs::base::ex::_tao_any_destructor (void *_tao_void_pointer)
{
  ex *_tao_tmp_pointer =
    static_cast<ex *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

redefs::base::ex *
redefs::base::ex::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ex *> (_tao_excp);
}

const redefs::base::ex *
redefs::base::ex::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ex *> (_tao_excp);
}

::CORBA::Exception *redefs::base::ex::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::redefs::base::ex, nullptr);
  return retval;
}

::CORBA::Exception *
redefs::base::ex::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::redefs::base::ex (*this), nullptr);
  return result;
}

void redefs::base::ex::_raise () const
{
  throw *this;
}

void redefs::base::ex::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void redefs::base::ex::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr redefs::base::ex::_tao_type () const
{
  return ::redefs::base::_tc_ex;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_redefs_base_ex[] =
      {
        { "info", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_redefs_base_ex (
  ::CORBA::tk_except,
  "IDL:redefs/base/ex:1.0",
  "ex",
  _tao_fields_redefs_base_ex,
  1);

::CORBA::TypeCode_ptr const redefs::base::_tc_ex =
  &_tao_tc_redefs_base_ex;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_redefs_base_foo[] =
      {
        { "index", &CORBA::_tc_short }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_redefs_base_foo (
  ::CORBA::tk_struct,
  "IDL:redefs/base/foo:1.0",
  "foo",
  _tao_fields_redefs_base_foo,
  1);

::CORBA::TypeCode_ptr const redefs::base::_tc_foo =
  &_tao_tc_redefs_base_foo;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
redefs::base::foo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  foo *_tao_tmp_pointer =
    static_cast<foo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

redefs::base::base ()
{
}
void
redefs::base::_tao_any_destructor (void *_tao_void_pointer)
{
  base *_tao_tmp_pointer =
    static_cast<base *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

redefs::base_ptr
redefs::base::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<base>::narrow (_tao_objref, "IDL:redefs/base:1.0");
}

redefs::base_ptr
redefs::base::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<base>::unchecked_narrow (_tao_objref);
}

redefs::base_ptr
redefs::base::_nil ()
{
  return nullptr;
}

redefs::base_ptr
redefs::base::_duplicate (base_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
redefs::base::_tao_release (base_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
redefs::base::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:redefs/base:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* redefs::base::_interface_repository_id () const
{
  return "IDL:redefs/base:1.0";
}

const char* redefs::base::_desc_repository_id ()
{
  return "IDL:redefs/base:1.0";
}

const char* redefs::base::_desc_interface_name ()
{
  return "base";
}

::CORBA::Boolean
redefs::base::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_redefs_base (
    ::CORBA::tk_objref,
    "IDL:redefs/base:1.0",
    "base");
  

namespace redefs
{
  ::CORBA::TypeCode_ptr const _tc_base =
    &_tao_tc_redefs_base;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_redefs_AMH_baseExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_redefs_AMH_baseExceptionHolder (
    ::CORBA::tk_value,
    "IDL:redefs/AMH_baseExceptionHolder:1.0",
    "AMH_baseExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_redefs_AMH_baseExceptionHolder,
    0);
  

namespace redefs
{
  ::CORBA::TypeCode_ptr const _tc_AMH_baseExceptionHolder =
    &_tao_tc_redefs_AMH_baseExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<redefs::AMH_baseExceptionHolder>::add_ref (redefs::AMH_baseExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<redefs::AMH_baseExceptionHolder>::remove_ref (redefs::AMH_baseExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<redefs::AMH_baseExceptionHolder>::release (redefs::AMH_baseExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



redefs::AMH_baseExceptionHolder *
redefs::AMH_baseExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::redefs::AMH_baseExceptionHolder *> (v);
}

const char *
redefs::AMH_baseExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
redefs::AMH_baseExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
redefs::AMH_baseExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_baseExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_baseExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr redefs::AMH_baseExceptionHolder::_tao_type () const
{
  return ::redefs::_tc_AMH_baseExceptionHolder;
}

redefs::AMH_baseExceptionHolder::~AMH_baseExceptionHolder ()
{}

::CORBA::ValueBase *
redefs::AMH_baseExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_baseExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
redefs::AMH_baseExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
redefs::AMH_baseExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
redefs::AMH_baseExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
redefs::AMH_baseExceptionHolder::_tao_marshal__redefs_AMH_baseExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
redefs::AMH_baseExceptionHolder::_tao_unmarshal__redefs_AMH_baseExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
redefs::AMH_baseExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_baseExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_baseExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_baseExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



redefs::AMH_baseExceptionHolder_init::AMH_baseExceptionHolder_init ()
{
}

redefs::AMH_baseExceptionHolder_init::~AMH_baseExceptionHolder_init ()
{
}

redefs::AMH_baseExceptionHolder_init *
redefs::AMH_baseExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::redefs::AMH_baseExceptionHolder_init *> (v);
}

const char*
redefs::AMH_baseExceptionHolder_init::tao_repository_id ()
{
  return ::redefs::AMH_baseExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
redefs::AMH_baseExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_redefs::AMH_baseExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for redefs::AMH_baseResponseHandler.

redefs::AMH_baseResponseHandler_ptr
TAO::Objref_Traits<redefs::AMH_baseResponseHandler>::duplicate (redefs::AMH_baseResponseHandler_ptr p)
{
  return redefs::AMH_baseResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<redefs::AMH_baseResponseHandler>::release (redefs::AMH_baseResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

redefs::AMH_baseResponseHandler_ptr
TAO::Objref_Traits<redefs::AMH_baseResponseHandler>::nil ()
{
  return redefs::AMH_baseResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<redefs::AMH_baseResponseHandler>::marshal (const redefs::AMH_baseResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



redefs::AMH_baseResponseHandler::AMH_baseResponseHandler ()
{}void
redefs::AMH_baseResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_baseResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_baseResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

redefs::AMH_baseResponseHandler_ptr
redefs::AMH_baseResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_baseResponseHandler::_duplicate (
      dynamic_cast<AMH_baseResponseHandler_ptr> (_tao_objref));
}

redefs::AMH_baseResponseHandler_ptr
redefs::AMH_baseResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_baseResponseHandler::_duplicate (
      dynamic_cast<AMH_baseResponseHandler_ptr> (_tao_objref));
}

redefs::AMH_baseResponseHandler_ptr
redefs::AMH_baseResponseHandler::_nil ()
{
  return nullptr;
}

redefs::AMH_baseResponseHandler_ptr
redefs::AMH_baseResponseHandler::_duplicate (AMH_baseResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
redefs::AMH_baseResponseHandler::_tao_release (AMH_baseResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
redefs::AMH_baseResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:redefs/AMH_baseResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* redefs::AMH_baseResponseHandler::_interface_repository_id () const
{
  return "IDL:redefs/AMH_baseResponseHandler:1.0";
}

const char* redefs::AMH_baseResponseHandler::_desc_repository_id ()
{
  return "IDL:redefs/AMH_baseResponseHandler:1.0";
}

const char* redefs::AMH_baseResponseHandler::_desc_interface_name ()
{
  return "AMH_baseResponseHandler";
}

::CORBA::Boolean
redefs::AMH_baseResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_redefs_AMH_baseResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:redefs/AMH_baseResponseHandler:1.0",
    "AMH_baseResponseHandler");
  

namespace redefs
{
  ::CORBA::TypeCode_ptr const _tc_AMH_baseResponseHandler =
    &_tao_tc_redefs_AMH_baseResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for redefs::AMI_baseHandler.

redefs::AMI_baseHandler_ptr
TAO::Objref_Traits<redefs::AMI_baseHandler>::duplicate (redefs::AMI_baseHandler_ptr p)
{
  return redefs::AMI_baseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<redefs::AMI_baseHandler>::release (redefs::AMI_baseHandler_ptr p)
{
  ::CORBA::release (p);
}

redefs::AMI_baseHandler_ptr
TAO::Objref_Traits<redefs::AMI_baseHandler>::nil ()
{
  return redefs::AMI_baseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<redefs::AMI_baseHandler>::marshal (const redefs::AMI_baseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



redefs::AMI_baseHandler::AMI_baseHandler ()
{
}
void
redefs::AMI_baseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_baseHandler *_tao_tmp_pointer =
    static_cast<AMI_baseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

redefs::AMI_baseHandler_ptr
redefs::AMI_baseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_baseHandler>::narrow (_tao_objref, "IDL:redefs/AMI_baseHandler:1.0");
}

redefs::AMI_baseHandler_ptr
redefs::AMI_baseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_baseHandler>::unchecked_narrow (_tao_objref);
}

redefs::AMI_baseHandler_ptr
redefs::AMI_baseHandler::_nil ()
{
  return nullptr;
}

redefs::AMI_baseHandler_ptr
redefs::AMI_baseHandler::_duplicate (AMI_baseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
redefs::AMI_baseHandler::_tao_release (AMI_baseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
redefs::AMI_baseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:redefs/AMI_baseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* redefs::AMI_baseHandler::_interface_repository_id () const
{
  return "IDL:redefs/AMI_baseHandler:1.0";
}

const char* redefs::AMI_baseHandler::_desc_repository_id ()
{
  return "IDL:redefs/AMI_baseHandler:1.0";
}

const char* redefs::AMI_baseHandler::_desc_interface_name ()
{
  return "AMI_baseHandler";
}

::CORBA::Boolean
redefs::AMI_baseHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_redefs_AMI_baseHandler (
    ::CORBA::tk_objref,
    "IDL:redefs/AMI_baseHandler:1.0",
    "AMI_baseHandler");
  

namespace redefs
{
  ::CORBA::TypeCode_ptr const _tc_AMI_baseHandler =
    &_tao_tc_redefs_AMI_baseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for redefs::derived.

redefs::derived_ptr
TAO::Objref_Traits<redefs::derived>::duplicate (redefs::derived_ptr p)
{
  return redefs::derived::_duplicate (p);
}

void
TAO::Objref_Traits<redefs::derived>::release (redefs::derived_ptr p)
{
  ::CORBA::release (p);
}

redefs::derived_ptr
TAO::Objref_Traits<redefs::derived>::nil ()
{
  return redefs::derived::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<redefs::derived>::marshal (const redefs::derived_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_constant/constant_cs.cpp:53



const CORBA::Long redefs::derived::lconst;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



redefs::derived::ex::ex (
    ::CORBA::Long _tao_serial)
  : ::CORBA::UserException (
        "IDL:redefs/derived/ex:1.0",
        "ex")
{
  this->serial = _tao_serial;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

redefs::derived::ex::ex ()
  : ::CORBA::UserException (
        "IDL:redefs/derived/ex:1.0",
        "ex")
{
}

redefs::derived::ex::ex (const ::redefs::derived::ex &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->serial = _tao_excp.serial;
}

redefs::derived::ex&
redefs::derived::ex::operator= (const ::redefs::derived::ex &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->serial = _tao_excp.serial;
  return *this;
}

void redefs::derived::ex::_tao_any_destructor (void *_tao_void_pointer)
{
  ex *_tao_tmp_pointer =
    static_cast<ex *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

redefs::derived::ex *
redefs::derived::ex::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ex *> (_tao_excp);
}

const redefs::derived::ex *
redefs::derived::ex::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ex *> (_tao_excp);
}

::CORBA::Exception *redefs::derived::ex::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::redefs::derived::ex, nullptr);
  return retval;
}

::CORBA::Exception *
redefs::derived::ex::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::redefs::derived::ex (*this), nullptr);
  return result;
}

void redefs::derived::ex::_raise () const
{
  throw *this;
}

void redefs::derived::ex::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void redefs::derived::ex::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr redefs::derived::ex::_tao_type () const
{
  return ::redefs::derived::_tc_ex;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_redefs_derived_ex[] =
      {
        { "serial", &CORBA::_tc_long }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_redefs_derived_ex (
  ::CORBA::tk_except,
  "IDL:redefs/derived/ex:1.0",
  "ex",
  _tao_fields_redefs_derived_ex,
  1);

::CORBA::TypeCode_ptr const redefs::derived::_tc_ex =
  &_tao_tc_redefs_derived_ex;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_redefs_derived_foo[] =
      {
        { "str", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_redefs_derived_foo (
  ::CORBA::tk_struct,
  "IDL:redefs/derived/foo:1.0",
  "foo",
  _tao_fields_redefs_derived_foo,
  1);

::CORBA::TypeCode_ptr const redefs::derived::_tc_foo =
  &_tao_tc_redefs_derived_foo;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
redefs::derived::foo::_tao_any_destructor (
    void *_tao_void_pointer)
{
  foo *_tao_tmp_pointer =
    static_cast<foo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

redefs::derived::derived ()
{
}
void
redefs::derived::_tao_any_destructor (void *_tao_void_pointer)
{
  derived *_tao_tmp_pointer =
    static_cast<derived *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

redefs::derived_ptr
redefs::derived::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<derived>::narrow (_tao_objref, "IDL:redefs/derived:1.0");
}

redefs::derived_ptr
redefs::derived::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<derived>::unchecked_narrow (_tao_objref);
}

redefs::derived_ptr
redefs::derived::_nil ()
{
  return nullptr;
}

redefs::derived_ptr
redefs::derived::_duplicate (derived_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
redefs::derived::_tao_release (derived_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
redefs::derived::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:redefs/base:1.0") == 0 ||
      std::strcmp (value, "IDL:redefs/derived:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* redefs::derived::_interface_repository_id () const
{
  return "IDL:redefs/derived:1.0";
}

const char* redefs::derived::_desc_repository_id ()
{
  return "IDL:redefs/derived:1.0";
}

const char* redefs::derived::_desc_interface_name ()
{
  return "derived";
}

::CORBA::Boolean
redefs::derived::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_redefs_derived (
    ::CORBA::tk_objref,
    "IDL:redefs/derived:1.0",
    "derived");
  

namespace redefs
{
  ::CORBA::TypeCode_ptr const _tc_derived =
    &_tao_tc_redefs_derived;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_redefs_AMH_derivedExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_redefs_AMH_derivedExceptionHolder (
    ::CORBA::tk_value,
    "IDL:redefs/AMH_derivedExceptionHolder:1.0",
    "AMH_derivedExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_redefs_AMH_derivedExceptionHolder,
    0);
  

namespace redefs
{
  ::CORBA::TypeCode_ptr const _tc_AMH_derivedExceptionHolder =
    &_tao_tc_redefs_AMH_derivedExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<redefs::AMH_derivedExceptionHolder>::add_ref (redefs::AMH_derivedExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<redefs::AMH_derivedExceptionHolder>::remove_ref (redefs::AMH_derivedExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<redefs::AMH_derivedExceptionHolder>::release (redefs::AMH_derivedExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



redefs::AMH_derivedExceptionHolder *
redefs::AMH_derivedExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::redefs::AMH_derivedExceptionHolder *> (v);
}

const char *
redefs::AMH_derivedExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
redefs::AMH_derivedExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
redefs::AMH_derivedExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_derivedExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_derivedExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr redefs::AMH_derivedExceptionHolder::_tao_type () const
{
  return ::redefs::_tc_AMH_derivedExceptionHolder;
}

redefs::AMH_derivedExceptionHolder::~AMH_derivedExceptionHolder ()
{}

::CORBA::ValueBase *
redefs::AMH_derivedExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_derivedExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
redefs::AMH_derivedExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
redefs::AMH_derivedExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
redefs::AMH_derivedExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
redefs::AMH_derivedExceptionHolder::_tao_marshal__redefs_AMH_derivedExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
redefs::AMH_derivedExceptionHolder::_tao_unmarshal__redefs_AMH_derivedExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
redefs::AMH_derivedExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_derivedExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_derivedExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_derivedExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



redefs::AMH_derivedExceptionHolder_init::AMH_derivedExceptionHolder_init ()
{
}

redefs::AMH_derivedExceptionHolder_init::~AMH_derivedExceptionHolder_init ()
{
}

redefs::AMH_derivedExceptionHolder_init *
redefs::AMH_derivedExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::redefs::AMH_derivedExceptionHolder_init *> (v);
}

const char*
redefs::AMH_derivedExceptionHolder_init::tao_repository_id ()
{
  return ::redefs::AMH_derivedExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
redefs::AMH_derivedExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_redefs::AMH_derivedExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for redefs::AMH_derivedResponseHandler.

redefs::AMH_derivedResponseHandler_ptr
TAO::Objref_Traits<redefs::AMH_derivedResponseHandler>::duplicate (redefs::AMH_derivedResponseHandler_ptr p)
{
  return redefs::AMH_derivedResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<redefs::AMH_derivedResponseHandler>::release (redefs::AMH_derivedResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

redefs::AMH_derivedResponseHandler_ptr
TAO::Objref_Traits<redefs::AMH_derivedResponseHandler>::nil ()
{
  return redefs::AMH_derivedResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<redefs::AMH_derivedResponseHandler>::marshal (const redefs::AMH_derivedResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



redefs::AMH_derivedResponseHandler::AMH_derivedResponseHandler ()
{}void
redefs::AMH_derivedResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_derivedResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_derivedResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

redefs::AMH_derivedResponseHandler_ptr
redefs::AMH_derivedResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_derivedResponseHandler::_duplicate (
      dynamic_cast<AMH_derivedResponseHandler_ptr> (_tao_objref));
}

redefs::AMH_derivedResponseHandler_ptr
redefs::AMH_derivedResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_derivedResponseHandler::_duplicate (
      dynamic_cast<AMH_derivedResponseHandler_ptr> (_tao_objref));
}

redefs::AMH_derivedResponseHandler_ptr
redefs::AMH_derivedResponseHandler::_nil ()
{
  return nullptr;
}

redefs::AMH_derivedResponseHandler_ptr
redefs::AMH_derivedResponseHandler::_duplicate (AMH_derivedResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
redefs::AMH_derivedResponseHandler::_tao_release (AMH_derivedResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
redefs::AMH_derivedResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:redefs/AMH_derivedResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* redefs::AMH_derivedResponseHandler::_interface_repository_id () const
{
  return "IDL:redefs/AMH_derivedResponseHandler:1.0";
}

const char* redefs::AMH_derivedResponseHandler::_desc_repository_id ()
{
  return "IDL:redefs/AMH_derivedResponseHandler:1.0";
}

const char* redefs::AMH_derivedResponseHandler::_desc_interface_name ()
{
  return "AMH_derivedResponseHandler";
}

::CORBA::Boolean
redefs::AMH_derivedResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_redefs_AMH_derivedResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:redefs/AMH_derivedResponseHandler:1.0",
    "AMH_derivedResponseHandler");
  

namespace redefs
{
  ::CORBA::TypeCode_ptr const _tc_AMH_derivedResponseHandler =
    &_tao_tc_redefs_AMH_derivedResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for redefs::AMI_derivedHandler.

redefs::AMI_derivedHandler_ptr
TAO::Objref_Traits<redefs::AMI_derivedHandler>::duplicate (redefs::AMI_derivedHandler_ptr p)
{
  return redefs::AMI_derivedHandler::_duplicate (p);
}

void
TAO::Objref_Traits<redefs::AMI_derivedHandler>::release (redefs::AMI_derivedHandler_ptr p)
{
  ::CORBA::release (p);
}

redefs::AMI_derivedHandler_ptr
TAO::Objref_Traits<redefs::AMI_derivedHandler>::nil ()
{
  return redefs::AMI_derivedHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<redefs::AMI_derivedHandler>::marshal (const redefs::AMI_derivedHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



redefs::AMI_derivedHandler::AMI_derivedHandler ()
{
}
void
redefs::AMI_derivedHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_derivedHandler *_tao_tmp_pointer =
    static_cast<AMI_derivedHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

redefs::AMI_derivedHandler_ptr
redefs::AMI_derivedHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_derivedHandler>::narrow (_tao_objref, "IDL:redefs/AMI_derivedHandler:1.0");
}

redefs::AMI_derivedHandler_ptr
redefs::AMI_derivedHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_derivedHandler>::unchecked_narrow (_tao_objref);
}

redefs::AMI_derivedHandler_ptr
redefs::AMI_derivedHandler::_nil ()
{
  return nullptr;
}

redefs::AMI_derivedHandler_ptr
redefs::AMI_derivedHandler::_duplicate (AMI_derivedHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
redefs::AMI_derivedHandler::_tao_release (AMI_derivedHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
redefs::AMI_derivedHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:redefs/AMI_baseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:redefs/AMI_derivedHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* redefs::AMI_derivedHandler::_interface_repository_id () const
{
  return "IDL:redefs/AMI_derivedHandler:1.0";
}

const char* redefs::AMI_derivedHandler::_desc_repository_id ()
{
  return "IDL:redefs/AMI_derivedHandler:1.0";
}

const char* redefs::AMI_derivedHandler::_desc_interface_name ()
{
  return "AMI_derivedHandler";
}

::CORBA::Boolean
redefs::AMI_derivedHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_redefs_AMI_derivedHandler (
    ::CORBA::tk_objref,
    "IDL:redefs/AMI_derivedHandler:1.0",
    "AMI_derivedHandler");
  

namespace redefs
{
  ::CORBA::TypeCode_ptr const _tc_AMI_derivedHandler =
    &_tao_tc_redefs_AMI_derivedHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Rec_Arg_Traits::base.

Rec_Arg_Traits::base_ptr
TAO::Objref_Traits<Rec_Arg_Traits::base>::duplicate (Rec_Arg_Traits::base_ptr p)
{
  return Rec_Arg_Traits::base::_duplicate (p);
}

void
TAO::Objref_Traits<Rec_Arg_Traits::base>::release (Rec_Arg_Traits::base_ptr p)
{
  ::CORBA::release (p);
}

Rec_Arg_Traits::base_ptr
TAO::Objref_Traits<Rec_Arg_Traits::base>::nil ()
{
  return Rec_Arg_Traits::base::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Rec_Arg_Traits::base>::marshal (const Rec_Arg_Traits::base_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Rec_Arg_Traits_base_plan_stub_type (
    ::CORBA::tk_alias,
    "IDL:Rec_Arg_Traits/base/plan_stub_type:1.0",
    "plan_stub_type",
    &Rec_Arg_Traits::_tc_base);
  
::CORBA::TypeCode_ptr const Rec_Arg_Traits::base::_tc_plan_stub_type =
  &_tao_tc_Rec_Arg_Traits_base_plan_stub_type;

Rec_Arg_Traits::base::base ()
{
}
void
Rec_Arg_Traits::base::_tao_any_destructor (void *_tao_void_pointer)
{
  base *_tao_tmp_pointer =
    static_cast<base *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Rec_Arg_Traits::base_ptr
Rec_Arg_Traits::base::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<base>::narrow (_tao_objref, "IDL:Rec_Arg_Traits/base:1.0");
}

Rec_Arg_Traits::base_ptr
Rec_Arg_Traits::base::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<base>::unchecked_narrow (_tao_objref);
}

Rec_Arg_Traits::base_ptr
Rec_Arg_Traits::base::_nil ()
{
  return nullptr;
}

Rec_Arg_Traits::base_ptr
Rec_Arg_Traits::base::_duplicate (base_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Rec_Arg_Traits::base::_tao_release (base_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Rec_Arg_Traits::base::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Rec_Arg_Traits/base:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Rec_Arg_Traits::base::_interface_repository_id () const
{
  return "IDL:Rec_Arg_Traits/base:1.0";
}

const char* Rec_Arg_Traits::base::_desc_repository_id ()
{
  return "IDL:Rec_Arg_Traits/base:1.0";
}

const char* Rec_Arg_Traits::base::_desc_interface_name ()
{
  return "base";
}

::CORBA::Boolean
Rec_Arg_Traits::base::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Rec_Arg_Traits_base (
    ::CORBA::tk_objref,
    "IDL:Rec_Arg_Traits/base:1.0",
    "base");
  

namespace Rec_Arg_Traits
{
  ::CORBA::TypeCode_ptr const _tc_base =
    &_tao_tc_Rec_Arg_Traits_base;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_Rec_Arg_Traits_AMH_baseExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_Rec_Arg_Traits_AMH_baseExceptionHolder (
    ::CORBA::tk_value,
    "IDL:Rec_Arg_Traits/AMH_baseExceptionHolder:1.0",
    "AMH_baseExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Rec_Arg_Traits_AMH_baseExceptionHolder,
    0);
  

namespace Rec_Arg_Traits
{
  ::CORBA::TypeCode_ptr const _tc_AMH_baseExceptionHolder =
    &_tao_tc_Rec_Arg_Traits_AMH_baseExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<Rec_Arg_Traits::AMH_baseExceptionHolder>::add_ref (Rec_Arg_Traits::AMH_baseExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Rec_Arg_Traits::AMH_baseExceptionHolder>::remove_ref (Rec_Arg_Traits::AMH_baseExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Rec_Arg_Traits::AMH_baseExceptionHolder>::release (Rec_Arg_Traits::AMH_baseExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Rec_Arg_Traits::AMH_baseExceptionHolder *
Rec_Arg_Traits::AMH_baseExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::Rec_Arg_Traits::AMH_baseExceptionHolder *> (v);
}

const char *
Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_baseExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_baseExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_type () const
{
  return ::Rec_Arg_Traits::_tc_AMH_baseExceptionHolder;
}

Rec_Arg_Traits::AMH_baseExceptionHolder::~AMH_baseExceptionHolder ()
{}

::CORBA::ValueBase *
Rec_Arg_Traits::AMH_baseExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_baseExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_marshal__Rec_Arg_Traits_AMH_baseExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_unmarshal__Rec_Arg_Traits_AMH_baseExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_baseExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_baseExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_baseExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



Rec_Arg_Traits::AMH_baseExceptionHolder_init::AMH_baseExceptionHolder_init ()
{
}

Rec_Arg_Traits::AMH_baseExceptionHolder_init::~AMH_baseExceptionHolder_init ()
{
}

Rec_Arg_Traits::AMH_baseExceptionHolder_init *
Rec_Arg_Traits::AMH_baseExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::Rec_Arg_Traits::AMH_baseExceptionHolder_init *> (v);
}

const char*
Rec_Arg_Traits::AMH_baseExceptionHolder_init::tao_repository_id ()
{
  return ::Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
Rec_Arg_Traits::AMH_baseExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_Rec_Arg_Traits::AMH_baseExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Rec_Arg_Traits::AMH_baseResponseHandler.

Rec_Arg_Traits::AMH_baseResponseHandler_ptr
TAO::Objref_Traits<Rec_Arg_Traits::AMH_baseResponseHandler>::duplicate (Rec_Arg_Traits::AMH_baseResponseHandler_ptr p)
{
  return Rec_Arg_Traits::AMH_baseResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Rec_Arg_Traits::AMH_baseResponseHandler>::release (Rec_Arg_Traits::AMH_baseResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

Rec_Arg_Traits::AMH_baseResponseHandler_ptr
TAO::Objref_Traits<Rec_Arg_Traits::AMH_baseResponseHandler>::nil ()
{
  return Rec_Arg_Traits::AMH_baseResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Rec_Arg_Traits::AMH_baseResponseHandler>::marshal (const Rec_Arg_Traits::AMH_baseResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Rec_Arg_Traits::AMH_baseResponseHandler::AMH_baseResponseHandler ()
{}void
Rec_Arg_Traits::AMH_baseResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_baseResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_baseResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Rec_Arg_Traits::AMH_baseResponseHandler_ptr
Rec_Arg_Traits::AMH_baseResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_baseResponseHandler::_duplicate (
      dynamic_cast<AMH_baseResponseHandler_ptr> (_tao_objref));
}

Rec_Arg_Traits::AMH_baseResponseHandler_ptr
Rec_Arg_Traits::AMH_baseResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_baseResponseHandler::_duplicate (
      dynamic_cast<AMH_baseResponseHandler_ptr> (_tao_objref));
}

Rec_Arg_Traits::AMH_baseResponseHandler_ptr
Rec_Arg_Traits::AMH_baseResponseHandler::_nil ()
{
  return nullptr;
}

Rec_Arg_Traits::AMH_baseResponseHandler_ptr
Rec_Arg_Traits::AMH_baseResponseHandler::_duplicate (AMH_baseResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Rec_Arg_Traits::AMH_baseResponseHandler::_tao_release (AMH_baseResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_baseResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Rec_Arg_Traits/AMH_baseResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* Rec_Arg_Traits::AMH_baseResponseHandler::_interface_repository_id () const
{
  return "IDL:Rec_Arg_Traits/AMH_baseResponseHandler:1.0";
}

const char* Rec_Arg_Traits::AMH_baseResponseHandler::_desc_repository_id ()
{
  return "IDL:Rec_Arg_Traits/AMH_baseResponseHandler:1.0";
}

const char* Rec_Arg_Traits::AMH_baseResponseHandler::_desc_interface_name ()
{
  return "AMH_baseResponseHandler";
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_baseResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Rec_Arg_Traits_AMH_baseResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:Rec_Arg_Traits/AMH_baseResponseHandler:1.0",
    "AMH_baseResponseHandler");
  

namespace Rec_Arg_Traits
{
  ::CORBA::TypeCode_ptr const _tc_AMH_baseResponseHandler =
    &_tao_tc_Rec_Arg_Traits_AMH_baseResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Rec_Arg_Traits::AMI_baseHandler.

Rec_Arg_Traits::AMI_baseHandler_ptr
TAO::Objref_Traits<Rec_Arg_Traits::AMI_baseHandler>::duplicate (Rec_Arg_Traits::AMI_baseHandler_ptr p)
{
  return Rec_Arg_Traits::AMI_baseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Rec_Arg_Traits::AMI_baseHandler>::release (Rec_Arg_Traits::AMI_baseHandler_ptr p)
{
  ::CORBA::release (p);
}

Rec_Arg_Traits::AMI_baseHandler_ptr
TAO::Objref_Traits<Rec_Arg_Traits::AMI_baseHandler>::nil ()
{
  return Rec_Arg_Traits::AMI_baseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Rec_Arg_Traits::AMI_baseHandler>::marshal (const Rec_Arg_Traits::AMI_baseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Rec_Arg_Traits::AMI_baseHandler::AMI_baseHandler ()
{
}
void
Rec_Arg_Traits::AMI_baseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_baseHandler *_tao_tmp_pointer =
    static_cast<AMI_baseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Rec_Arg_Traits::AMI_baseHandler_ptr
Rec_Arg_Traits::AMI_baseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_baseHandler>::narrow (_tao_objref, "IDL:Rec_Arg_Traits/AMI_baseHandler:1.0");
}

Rec_Arg_Traits::AMI_baseHandler_ptr
Rec_Arg_Traits::AMI_baseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_baseHandler>::unchecked_narrow (_tao_objref);
}

Rec_Arg_Traits::AMI_baseHandler_ptr
Rec_Arg_Traits::AMI_baseHandler::_nil ()
{
  return nullptr;
}

Rec_Arg_Traits::AMI_baseHandler_ptr
Rec_Arg_Traits::AMI_baseHandler::_duplicate (AMI_baseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Rec_Arg_Traits::AMI_baseHandler::_tao_release (AMI_baseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Rec_Arg_Traits::AMI_baseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:Rec_Arg_Traits/AMI_baseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Rec_Arg_Traits::AMI_baseHandler::_interface_repository_id () const
{
  return "IDL:Rec_Arg_Traits/AMI_baseHandler:1.0";
}

const char* Rec_Arg_Traits::AMI_baseHandler::_desc_repository_id ()
{
  return "IDL:Rec_Arg_Traits/AMI_baseHandler:1.0";
}

const char* Rec_Arg_Traits::AMI_baseHandler::_desc_interface_name ()
{
  return "AMI_baseHandler";
}

::CORBA::Boolean
Rec_Arg_Traits::AMI_baseHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Rec_Arg_Traits_AMI_baseHandler (
    ::CORBA::tk_objref,
    "IDL:Rec_Arg_Traits/AMI_baseHandler:1.0",
    "AMI_baseHandler");
  

namespace Rec_Arg_Traits
{
  ::CORBA::TypeCode_ptr const _tc_AMI_baseHandler =
    &_tao_tc_Rec_Arg_Traits_AMI_baseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Rec_Arg_Traits::derived.

Rec_Arg_Traits::derived_ptr
TAO::Objref_Traits<Rec_Arg_Traits::derived>::duplicate (Rec_Arg_Traits::derived_ptr p)
{
  return Rec_Arg_Traits::derived::_duplicate (p);
}

void
TAO::Objref_Traits<Rec_Arg_Traits::derived>::release (Rec_Arg_Traits::derived_ptr p)
{
  ::CORBA::release (p);
}

Rec_Arg_Traits::derived_ptr
TAO::Objref_Traits<Rec_Arg_Traits::derived>::nil ()
{
  return Rec_Arg_Traits::derived::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Rec_Arg_Traits::derived>::marshal (const Rec_Arg_Traits::derived_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
Rec_Arg_Traits::derived::remove_task (
  ::Rec_Arg_Traits::base::plan_stub_type_ptr listener)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Rec_Arg_Traits::base>::in_arg_val _tao_listener (listener);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_listener)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_task",
      11,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
Rec_Arg_Traits::derived::sendc_remove_task (
  ::Rec_Arg_Traits::AMI_derivedHandler_ptr ami_handler,
  ::Rec_Arg_Traits::base::plan_stub_type_ptr listener)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Rec_Arg_Traits::base>::in_arg_val _tao_listener (listener);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_listener)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_task",
      11,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &Rec_Arg_Traits::AMI_derivedHandler::remove_task_reply_stub
    );
}

Rec_Arg_Traits::derived::derived ()
{
}
void
Rec_Arg_Traits::derived::_tao_any_destructor (void *_tao_void_pointer)
{
  derived *_tao_tmp_pointer =
    static_cast<derived *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Rec_Arg_Traits::derived_ptr
Rec_Arg_Traits::derived::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<derived>::narrow (_tao_objref, "IDL:Rec_Arg_Traits/derived:1.0");
}

Rec_Arg_Traits::derived_ptr
Rec_Arg_Traits::derived::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<derived>::unchecked_narrow (_tao_objref);
}

Rec_Arg_Traits::derived_ptr
Rec_Arg_Traits::derived::_nil ()
{
  return nullptr;
}

Rec_Arg_Traits::derived_ptr
Rec_Arg_Traits::derived::_duplicate (derived_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Rec_Arg_Traits::derived::_tao_release (derived_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Rec_Arg_Traits::derived::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Rec_Arg_Traits/base:1.0") == 0 ||
      std::strcmp (value, "IDL:Rec_Arg_Traits/derived:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Rec_Arg_Traits::derived::_interface_repository_id () const
{
  return "IDL:Rec_Arg_Traits/derived:1.0";
}

const char* Rec_Arg_Traits::derived::_desc_repository_id ()
{
  return "IDL:Rec_Arg_Traits/derived:1.0";
}

const char* Rec_Arg_Traits::derived::_desc_interface_name ()
{
  return "derived";
}

::CORBA::Boolean
Rec_Arg_Traits::derived::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Rec_Arg_Traits_derived (
    ::CORBA::tk_objref,
    "IDL:Rec_Arg_Traits/derived:1.0",
    "derived");
  

namespace Rec_Arg_Traits
{
  ::CORBA::TypeCode_ptr const _tc_derived =
    &_tao_tc_Rec_Arg_Traits_derived;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_Rec_Arg_Traits_AMH_derivedExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_Rec_Arg_Traits_AMH_derivedExceptionHolder (
    ::CORBA::tk_value,
    "IDL:Rec_Arg_Traits/AMH_derivedExceptionHolder:1.0",
    "AMH_derivedExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Rec_Arg_Traits_AMH_derivedExceptionHolder,
    0);
  

namespace Rec_Arg_Traits
{
  ::CORBA::TypeCode_ptr const _tc_AMH_derivedExceptionHolder =
    &_tao_tc_Rec_Arg_Traits_AMH_derivedExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<Rec_Arg_Traits::AMH_derivedExceptionHolder>::add_ref (Rec_Arg_Traits::AMH_derivedExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Rec_Arg_Traits::AMH_derivedExceptionHolder>::remove_ref (Rec_Arg_Traits::AMH_derivedExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Rec_Arg_Traits::AMH_derivedExceptionHolder>::release (Rec_Arg_Traits::AMH_derivedExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Rec_Arg_Traits::AMH_derivedExceptionHolder *
Rec_Arg_Traits::AMH_derivedExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::Rec_Arg_Traits::AMH_derivedExceptionHolder *> (v);
}

const char *
Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_derivedExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_derivedExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_type () const
{
  return ::Rec_Arg_Traits::_tc_AMH_derivedExceptionHolder;
}

Rec_Arg_Traits::AMH_derivedExceptionHolder::~AMH_derivedExceptionHolder ()
{}

::CORBA::ValueBase *
Rec_Arg_Traits::AMH_derivedExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_derivedExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_marshal__Rec_Arg_Traits_AMH_derivedExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_unmarshal__Rec_Arg_Traits_AMH_derivedExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_derivedExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_derivedExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_derivedExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
Rec_Arg_Traits::AMH_derivedExceptionHolder::raise_remove_task ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
Rec_Arg_Traits::AMH_derivedExceptionHolder::raise_sendc_remove_task ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Rec_Arg_Traits::AMH_derivedResponseHandler.

Rec_Arg_Traits::AMH_derivedResponseHandler_ptr
TAO::Objref_Traits<Rec_Arg_Traits::AMH_derivedResponseHandler>::duplicate (Rec_Arg_Traits::AMH_derivedResponseHandler_ptr p)
{
  return Rec_Arg_Traits::AMH_derivedResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Rec_Arg_Traits::AMH_derivedResponseHandler>::release (Rec_Arg_Traits::AMH_derivedResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

Rec_Arg_Traits::AMH_derivedResponseHandler_ptr
TAO::Objref_Traits<Rec_Arg_Traits::AMH_derivedResponseHandler>::nil ()
{
  return Rec_Arg_Traits::AMH_derivedResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Rec_Arg_Traits::AMH_derivedResponseHandler>::marshal (const Rec_Arg_Traits::AMH_derivedResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Rec_Arg_Traits::AMH_derivedResponseHandler::AMH_derivedResponseHandler ()
{}void
Rec_Arg_Traits::AMH_derivedResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_derivedResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_derivedResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Rec_Arg_Traits::AMH_derivedResponseHandler_ptr
Rec_Arg_Traits::AMH_derivedResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_derivedResponseHandler::_duplicate (
      dynamic_cast<AMH_derivedResponseHandler_ptr> (_tao_objref));
}

Rec_Arg_Traits::AMH_derivedResponseHandler_ptr
Rec_Arg_Traits::AMH_derivedResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_derivedResponseHandler::_duplicate (
      dynamic_cast<AMH_derivedResponseHandler_ptr> (_tao_objref));
}

Rec_Arg_Traits::AMH_derivedResponseHandler_ptr
Rec_Arg_Traits::AMH_derivedResponseHandler::_nil ()
{
  return nullptr;
}

Rec_Arg_Traits::AMH_derivedResponseHandler_ptr
Rec_Arg_Traits::AMH_derivedResponseHandler::_duplicate (AMH_derivedResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Rec_Arg_Traits::AMH_derivedResponseHandler::_tao_release (AMH_derivedResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_derivedResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Rec_Arg_Traits/AMH_derivedResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* Rec_Arg_Traits::AMH_derivedResponseHandler::_interface_repository_id () const
{
  return "IDL:Rec_Arg_Traits/AMH_derivedResponseHandler:1.0";
}

const char* Rec_Arg_Traits::AMH_derivedResponseHandler::_desc_repository_id ()
{
  return "IDL:Rec_Arg_Traits/AMH_derivedResponseHandler:1.0";
}

const char* Rec_Arg_Traits::AMH_derivedResponseHandler::_desc_interface_name ()
{
  return "AMH_derivedResponseHandler";
}

::CORBA::Boolean
Rec_Arg_Traits::AMH_derivedResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Rec_Arg_Traits_AMH_derivedResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:Rec_Arg_Traits/AMH_derivedResponseHandler:1.0",
    "AMH_derivedResponseHandler");
  

namespace Rec_Arg_Traits
{
  ::CORBA::TypeCode_ptr const _tc_AMH_derivedResponseHandler =
    &_tao_tc_Rec_Arg_Traits_AMH_derivedResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Rec_Arg_Traits::AMI_derivedHandler.

Rec_Arg_Traits::AMI_derivedHandler_ptr
TAO::Objref_Traits<Rec_Arg_Traits::AMI_derivedHandler>::duplicate (Rec_Arg_Traits::AMI_derivedHandler_ptr p)
{
  return Rec_Arg_Traits::AMI_derivedHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Rec_Arg_Traits::AMI_derivedHandler>::release (Rec_Arg_Traits::AMI_derivedHandler_ptr p)
{
  ::CORBA::release (p);
}

Rec_Arg_Traits::AMI_derivedHandler_ptr
TAO::Objref_Traits<Rec_Arg_Traits::AMI_derivedHandler>::nil ()
{
  return Rec_Arg_Traits::AMI_derivedHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Rec_Arg_Traits::AMI_derivedHandler>::marshal (const Rec_Arg_Traits::AMI_derivedHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
Rec_Arg_Traits::AMI_derivedHandler::remove_task ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "remove_task",
      11,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
Rec_Arg_Traits::AMI_derivedHandler::remove_task_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  Rec_Arg_Traits::AMI_derivedHandler_var _tao_reply_handler_object =
    Rec_Arg_Traits::AMI_derivedHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->remove_task (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->remove_task_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
Rec_Arg_Traits::AMI_derivedHandler::remove_task_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "remove_task_excep",
      17,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

Rec_Arg_Traits::AMI_derivedHandler::AMI_derivedHandler ()
{
}
void
Rec_Arg_Traits::AMI_derivedHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_derivedHandler *_tao_tmp_pointer =
    static_cast<AMI_derivedHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Rec_Arg_Traits::AMI_derivedHandler_ptr
Rec_Arg_Traits::AMI_derivedHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_derivedHandler>::narrow (_tao_objref, "IDL:Rec_Arg_Traits/AMI_derivedHandler:1.0");
}

Rec_Arg_Traits::AMI_derivedHandler_ptr
Rec_Arg_Traits::AMI_derivedHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_derivedHandler>::unchecked_narrow (_tao_objref);
}

Rec_Arg_Traits::AMI_derivedHandler_ptr
Rec_Arg_Traits::AMI_derivedHandler::_nil ()
{
  return nullptr;
}

Rec_Arg_Traits::AMI_derivedHandler_ptr
Rec_Arg_Traits::AMI_derivedHandler::_duplicate (AMI_derivedHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Rec_Arg_Traits::AMI_derivedHandler::_tao_release (AMI_derivedHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Rec_Arg_Traits::AMI_derivedHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:Rec_Arg_Traits/AMI_baseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:Rec_Arg_Traits/AMI_derivedHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Rec_Arg_Traits::AMI_derivedHandler::_interface_repository_id () const
{
  return "IDL:Rec_Arg_Traits/AMI_derivedHandler:1.0";
}

const char* Rec_Arg_Traits::AMI_derivedHandler::_desc_repository_id ()
{
  return "IDL:Rec_Arg_Traits/AMI_derivedHandler:1.0";
}

const char* Rec_Arg_Traits::AMI_derivedHandler::_desc_interface_name ()
{
  return "AMI_derivedHandler";
}

::CORBA::Boolean
Rec_Arg_Traits::AMI_derivedHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Rec_Arg_Traits_AMI_derivedHandler (
    ::CORBA::tk_objref,
    "IDL:Rec_Arg_Traits/AMI_derivedHandler:1.0",
    "AMI_derivedHandler");
  

namespace Rec_Arg_Traits
{
  ::CORBA::TypeCode_ptr const _tc_AMI_derivedHandler =
    &_tao_tc_Rec_Arg_Traits_AMI_derivedHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for call_test::iTest.

call_test::iTest_ptr
TAO::Objref_Traits<call_test::iTest>::duplicate (call_test::iTest_ptr p)
{
  return call_test::iTest::_duplicate (p);
}

void
TAO::Objref_Traits<call_test::iTest>::release (call_test::iTest_ptr p)
{
  ::CORBA::release (p);
}

call_test::iTest_ptr
TAO::Objref_Traits<call_test::iTest>::nil ()
{
  return call_test::iTest::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<call_test::iTest>::marshal (const call_test::iTest_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
call_test::iTest::do_op (
  const char * call)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_call (call);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_call)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "do_op",
      5,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
call_test::iTest::sendc_do_op (
  ::call_test::AMI_iTestHandler_ptr ami_handler,
  const char * call)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_call (call);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_call)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "do_op",
      5,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &call_test::AMI_iTestHandler::do_op_reply_stub
    );
}

call_test::iTest::iTest ()
{
}
void
call_test::iTest::_tao_any_destructor (void *_tao_void_pointer)
{
  iTest *_tao_tmp_pointer =
    static_cast<iTest *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

call_test::iTest_ptr
call_test::iTest::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<iTest>::narrow (_tao_objref, "IDL:call_test/iTest:1.0");
}

call_test::iTest_ptr
call_test::iTest::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<iTest>::unchecked_narrow (_tao_objref);
}

call_test::iTest_ptr
call_test::iTest::_nil ()
{
  return nullptr;
}

call_test::iTest_ptr
call_test::iTest::_duplicate (iTest_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
call_test::iTest::_tao_release (iTest_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
call_test::iTest::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:call_test/iTest:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* call_test::iTest::_interface_repository_id () const
{
  return "IDL:call_test/iTest:1.0";
}

const char* call_test::iTest::_desc_repository_id ()
{
  return "IDL:call_test/iTest:1.0";
}

const char* call_test::iTest::_desc_interface_name ()
{
  return "iTest";
}

::CORBA::Boolean
call_test::iTest::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_call_test_iTest (
    ::CORBA::tk_objref,
    "IDL:call_test/iTest:1.0",
    "iTest");
  

namespace call_test
{
  ::CORBA::TypeCode_ptr const _tc_iTest =
    &_tao_tc_call_test_iTest;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_call_test_AMH_iTestExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_call_test_AMH_iTestExceptionHolder (
    ::CORBA::tk_value,
    "IDL:call_test/AMH_iTestExceptionHolder:1.0",
    "AMH_iTestExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_call_test_AMH_iTestExceptionHolder,
    0);
  

namespace call_test
{
  ::CORBA::TypeCode_ptr const _tc_AMH_iTestExceptionHolder =
    &_tao_tc_call_test_AMH_iTestExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<call_test::AMH_iTestExceptionHolder>::add_ref (call_test::AMH_iTestExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<call_test::AMH_iTestExceptionHolder>::remove_ref (call_test::AMH_iTestExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<call_test::AMH_iTestExceptionHolder>::release (call_test::AMH_iTestExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



call_test::AMH_iTestExceptionHolder *
call_test::AMH_iTestExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::call_test::AMH_iTestExceptionHolder *> (v);
}

const char *
call_test::AMH_iTestExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
call_test::AMH_iTestExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
call_test::AMH_iTestExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_iTestExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_iTestExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr call_test::AMH_iTestExceptionHolder::_tao_type () const
{
  return ::call_test::_tc_AMH_iTestExceptionHolder;
}

call_test::AMH_iTestExceptionHolder::~AMH_iTestExceptionHolder ()
{}

::CORBA::ValueBase *
call_test::AMH_iTestExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_iTestExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
call_test::AMH_iTestExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
call_test::AMH_iTestExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
call_test::AMH_iTestExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
call_test::AMH_iTestExceptionHolder::_tao_marshal__call_test_AMH_iTestExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
call_test::AMH_iTestExceptionHolder::_tao_unmarshal__call_test_AMH_iTestExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
call_test::AMH_iTestExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_iTestExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_iTestExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_iTestExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
call_test::AMH_iTestExceptionHolder::raise_do_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
call_test::AMH_iTestExceptionHolder::raise_sendc_do_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for call_test::AMH_iTestResponseHandler.

call_test::AMH_iTestResponseHandler_ptr
TAO::Objref_Traits<call_test::AMH_iTestResponseHandler>::duplicate (call_test::AMH_iTestResponseHandler_ptr p)
{
  return call_test::AMH_iTestResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<call_test::AMH_iTestResponseHandler>::release (call_test::AMH_iTestResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

call_test::AMH_iTestResponseHandler_ptr
TAO::Objref_Traits<call_test::AMH_iTestResponseHandler>::nil ()
{
  return call_test::AMH_iTestResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<call_test::AMH_iTestResponseHandler>::marshal (const call_test::AMH_iTestResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



call_test::AMH_iTestResponseHandler::AMH_iTestResponseHandler ()
{}void
call_test::AMH_iTestResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_iTestResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_iTestResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

call_test::AMH_iTestResponseHandler_ptr
call_test::AMH_iTestResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_iTestResponseHandler::_duplicate (
      dynamic_cast<AMH_iTestResponseHandler_ptr> (_tao_objref));
}

call_test::AMH_iTestResponseHandler_ptr
call_test::AMH_iTestResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_iTestResponseHandler::_duplicate (
      dynamic_cast<AMH_iTestResponseHandler_ptr> (_tao_objref));
}

call_test::AMH_iTestResponseHandler_ptr
call_test::AMH_iTestResponseHandler::_nil ()
{
  return nullptr;
}

call_test::AMH_iTestResponseHandler_ptr
call_test::AMH_iTestResponseHandler::_duplicate (AMH_iTestResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
call_test::AMH_iTestResponseHandler::_tao_release (AMH_iTestResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
call_test::AMH_iTestResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:call_test/AMH_iTestResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* call_test::AMH_iTestResponseHandler::_interface_repository_id () const
{
  return "IDL:call_test/AMH_iTestResponseHandler:1.0";
}

const char* call_test::AMH_iTestResponseHandler::_desc_repository_id ()
{
  return "IDL:call_test/AMH_iTestResponseHandler:1.0";
}

const char* call_test::AMH_iTestResponseHandler::_desc_interface_name ()
{
  return "AMH_iTestResponseHandler";
}

::CORBA::Boolean
call_test::AMH_iTestResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_call_test_AMH_iTestResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:call_test/AMH_iTestResponseHandler:1.0",
    "AMH_iTestResponseHandler");
  

namespace call_test
{
  ::CORBA::TypeCode_ptr const _tc_AMH_iTestResponseHandler =
    &_tao_tc_call_test_AMH_iTestResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for call_test::AMI_iTestHandler.

call_test::AMI_iTestHandler_ptr
TAO::Objref_Traits<call_test::AMI_iTestHandler>::duplicate (call_test::AMI_iTestHandler_ptr p)
{
  return call_test::AMI_iTestHandler::_duplicate (p);
}

void
TAO::Objref_Traits<call_test::AMI_iTestHandler>::release (call_test::AMI_iTestHandler_ptr p)
{
  ::CORBA::release (p);
}

call_test::AMI_iTestHandler_ptr
TAO::Objref_Traits<call_test::AMI_iTestHandler>::nil ()
{
  return call_test::AMI_iTestHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<call_test::AMI_iTestHandler>::marshal (const call_test::AMI_iTestHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
call_test::AMI_iTestHandler::do_op ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "do_op",
      5,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
call_test::AMI_iTestHandler::do_op_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  call_test::AMI_iTestHandler_var _tao_reply_handler_object =
    call_test::AMI_iTestHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->do_op (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->do_op_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
call_test::AMI_iTestHandler::do_op_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "do_op_excep",
      11,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

call_test::AMI_iTestHandler::AMI_iTestHandler ()
{
}
void
call_test::AMI_iTestHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_iTestHandler *_tao_tmp_pointer =
    static_cast<AMI_iTestHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

call_test::AMI_iTestHandler_ptr
call_test::AMI_iTestHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_iTestHandler>::narrow (_tao_objref, "IDL:call_test/AMI_iTestHandler:1.0");
}

call_test::AMI_iTestHandler_ptr
call_test::AMI_iTestHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_iTestHandler>::unchecked_narrow (_tao_objref);
}

call_test::AMI_iTestHandler_ptr
call_test::AMI_iTestHandler::_nil ()
{
  return nullptr;
}

call_test::AMI_iTestHandler_ptr
call_test::AMI_iTestHandler::_duplicate (AMI_iTestHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
call_test::AMI_iTestHandler::_tao_release (AMI_iTestHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
call_test::AMI_iTestHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:call_test/AMI_iTestHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* call_test::AMI_iTestHandler::_interface_repository_id () const
{
  return "IDL:call_test/AMI_iTestHandler:1.0";
}

const char* call_test::AMI_iTestHandler::_desc_repository_id ()
{
  return "IDL:call_test/AMI_iTestHandler:1.0";
}

const char* call_test::AMI_iTestHandler::_desc_interface_name ()
{
  return "AMI_iTestHandler";
}

::CORBA::Boolean
call_test::AMI_iTestHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_call_test_AMI_iTestHandler (
    ::CORBA::tk_objref,
    "IDL:call_test/AMI_iTestHandler:1.0",
    "AMI_iTestHandler");
  

namespace call_test
{
  ::CORBA::TypeCode_ptr const _tc_AMI_iTestHandler =
    &_tao_tc_call_test_AMI_iTestHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for call_attribute::iBar.

call_attribute::iBar_ptr
TAO::Objref_Traits<call_attribute::iBar>::duplicate (call_attribute::iBar_ptr p)
{
  return call_attribute::iBar::_duplicate (p);
}

void
TAO::Objref_Traits<call_attribute::iBar>::release (call_attribute::iBar_ptr p)
{
  ::CORBA::release (p);
}

call_attribute::iBar_ptr
TAO::Objref_Traits<call_attribute::iBar>::nil ()
{
  return call_attribute::iBar::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<call_attribute::iBar>::marshal (const call_attribute::iBar_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

char *
call_attribute::iBar::call ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_call",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
call_attribute::iBar::call (
  const char * call)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_call (call);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_call)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_call",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
call_attribute::iBar::sendc_set_call (
  ::call_attribute::AMI_iBarHandler_ptr ami_handler,
  const char * call)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_call (call);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_call)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_call",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &call_attribute::AMI_iBarHandler::set_call_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
call_attribute::iBar::sendc_get_call (
  ::call_attribute::AMI_iBarHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_call",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &call_attribute::AMI_iBarHandler::get_call_reply_stub
    );
}

call_attribute::iBar::iBar ()
{
}
void
call_attribute::iBar::_tao_any_destructor (void *_tao_void_pointer)
{
  iBar *_tao_tmp_pointer =
    static_cast<iBar *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

call_attribute::iBar_ptr
call_attribute::iBar::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<iBar>::narrow (_tao_objref, "IDL:call_attribute/iBar:1.0");
}

call_attribute::iBar_ptr
call_attribute::iBar::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<iBar>::unchecked_narrow (_tao_objref);
}

call_attribute::iBar_ptr
call_attribute::iBar::_nil ()
{
  return nullptr;
}

call_attribute::iBar_ptr
call_attribute::iBar::_duplicate (iBar_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
call_attribute::iBar::_tao_release (iBar_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
call_attribute::iBar::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:call_attribute/iBar:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* call_attribute::iBar::_interface_repository_id () const
{
  return "IDL:call_attribute/iBar:1.0";
}

const char* call_attribute::iBar::_desc_repository_id ()
{
  return "IDL:call_attribute/iBar:1.0";
}

const char* call_attribute::iBar::_desc_interface_name ()
{
  return "iBar";
}

::CORBA::Boolean
call_attribute::iBar::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_call_attribute_iBar (
    ::CORBA::tk_objref,
    "IDL:call_attribute/iBar:1.0",
    "iBar");
  

namespace call_attribute
{
  ::CORBA::TypeCode_ptr const _tc_iBar =
    &_tao_tc_call_attribute_iBar;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_call_attribute_AMH_iBarExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_call_attribute_AMH_iBarExceptionHolder (
    ::CORBA::tk_value,
    "IDL:call_attribute/AMH_iBarExceptionHolder:1.0",
    "AMH_iBarExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_call_attribute_AMH_iBarExceptionHolder,
    0);
  

namespace call_attribute
{
  ::CORBA::TypeCode_ptr const _tc_AMH_iBarExceptionHolder =
    &_tao_tc_call_attribute_AMH_iBarExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<call_attribute::AMH_iBarExceptionHolder>::add_ref (call_attribute::AMH_iBarExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<call_attribute::AMH_iBarExceptionHolder>::remove_ref (call_attribute::AMH_iBarExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<call_attribute::AMH_iBarExceptionHolder>::release (call_attribute::AMH_iBarExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



call_attribute::AMH_iBarExceptionHolder *
call_attribute::AMH_iBarExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::call_attribute::AMH_iBarExceptionHolder *> (v);
}

const char *
call_attribute::AMH_iBarExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
call_attribute::AMH_iBarExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
call_attribute::AMH_iBarExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_iBarExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_iBarExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr call_attribute::AMH_iBarExceptionHolder::_tao_type () const
{
  return ::call_attribute::_tc_AMH_iBarExceptionHolder;
}

call_attribute::AMH_iBarExceptionHolder::~AMH_iBarExceptionHolder ()
{}

::CORBA::ValueBase *
call_attribute::AMH_iBarExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_iBarExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
call_attribute::AMH_iBarExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
call_attribute::AMH_iBarExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
call_attribute::AMH_iBarExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
call_attribute::AMH_iBarExceptionHolder::_tao_marshal__call_attribute_AMH_iBarExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
call_attribute::AMH_iBarExceptionHolder::_tao_unmarshal__call_attribute_AMH_iBarExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
call_attribute::AMH_iBarExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_iBarExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_iBarExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_iBarExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
call_attribute::AMH_iBarExceptionHolder::raise_get_call ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
call_attribute::AMH_iBarExceptionHolder::raise_set_call ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
call_attribute::AMH_iBarExceptionHolder::raise_sendc_set_call ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
call_attribute::AMH_iBarExceptionHolder::raise_sendc_get_call ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for call_attribute::AMH_iBarResponseHandler.

call_attribute::AMH_iBarResponseHandler_ptr
TAO::Objref_Traits<call_attribute::AMH_iBarResponseHandler>::duplicate (call_attribute::AMH_iBarResponseHandler_ptr p)
{
  return call_attribute::AMH_iBarResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<call_attribute::AMH_iBarResponseHandler>::release (call_attribute::AMH_iBarResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

call_attribute::AMH_iBarResponseHandler_ptr
TAO::Objref_Traits<call_attribute::AMH_iBarResponseHandler>::nil ()
{
  return call_attribute::AMH_iBarResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<call_attribute::AMH_iBarResponseHandler>::marshal (const call_attribute::AMH_iBarResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



call_attribute::AMH_iBarResponseHandler::AMH_iBarResponseHandler ()
{}void
call_attribute::AMH_iBarResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_iBarResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_iBarResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

call_attribute::AMH_iBarResponseHandler_ptr
call_attribute::AMH_iBarResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_iBarResponseHandler::_duplicate (
      dynamic_cast<AMH_iBarResponseHandler_ptr> (_tao_objref));
}

call_attribute::AMH_iBarResponseHandler_ptr
call_attribute::AMH_iBarResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_iBarResponseHandler::_duplicate (
      dynamic_cast<AMH_iBarResponseHandler_ptr> (_tao_objref));
}

call_attribute::AMH_iBarResponseHandler_ptr
call_attribute::AMH_iBarResponseHandler::_nil ()
{
  return nullptr;
}

call_attribute::AMH_iBarResponseHandler_ptr
call_attribute::AMH_iBarResponseHandler::_duplicate (AMH_iBarResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
call_attribute::AMH_iBarResponseHandler::_tao_release (AMH_iBarResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
call_attribute::AMH_iBarResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:call_attribute/AMH_iBarResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* call_attribute::AMH_iBarResponseHandler::_interface_repository_id () const
{
  return "IDL:call_attribute/AMH_iBarResponseHandler:1.0";
}

const char* call_attribute::AMH_iBarResponseHandler::_desc_repository_id ()
{
  return "IDL:call_attribute/AMH_iBarResponseHandler:1.0";
}

const char* call_attribute::AMH_iBarResponseHandler::_desc_interface_name ()
{
  return "AMH_iBarResponseHandler";
}

::CORBA::Boolean
call_attribute::AMH_iBarResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_call_attribute_AMH_iBarResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:call_attribute/AMH_iBarResponseHandler:1.0",
    "AMH_iBarResponseHandler");
  

namespace call_attribute
{
  ::CORBA::TypeCode_ptr const _tc_AMH_iBarResponseHandler =
    &_tao_tc_call_attribute_AMH_iBarResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for call_attribute::AMI_iBarHandler.

call_attribute::AMI_iBarHandler_ptr
TAO::Objref_Traits<call_attribute::AMI_iBarHandler>::duplicate (call_attribute::AMI_iBarHandler_ptr p)
{
  return call_attribute::AMI_iBarHandler::_duplicate (p);
}

void
TAO::Objref_Traits<call_attribute::AMI_iBarHandler>::release (call_attribute::AMI_iBarHandler_ptr p)
{
  ::CORBA::release (p);
}

call_attribute::AMI_iBarHandler_ptr
TAO::Objref_Traits<call_attribute::AMI_iBarHandler>::nil ()
{
  return call_attribute::AMI_iBarHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<call_attribute::AMI_iBarHandler>::marshal (const call_attribute::AMI_iBarHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
call_attribute::AMI_iBarHandler::get_call (
  const char * ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_call",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
call_attribute::AMI_iBarHandler::get_call_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  call_attribute::AMI_iBarHandler_var _tao_reply_handler_object =
    call_attribute::AMI_iBarHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::String_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_call (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_call_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
call_attribute::AMI_iBarHandler::get_call_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_call_excep",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
call_attribute::AMI_iBarHandler::set_call ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_call",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
call_attribute::AMI_iBarHandler::set_call_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  call_attribute::AMI_iBarHandler_var _tao_reply_handler_object =
    call_attribute::AMI_iBarHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_call (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_call_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
call_attribute::AMI_iBarHandler::set_call_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_call_excep",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

call_attribute::AMI_iBarHandler::AMI_iBarHandler ()
{
}
void
call_attribute::AMI_iBarHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_iBarHandler *_tao_tmp_pointer =
    static_cast<AMI_iBarHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

call_attribute::AMI_iBarHandler_ptr
call_attribute::AMI_iBarHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_iBarHandler>::narrow (_tao_objref, "IDL:call_attribute/AMI_iBarHandler:1.0");
}

call_attribute::AMI_iBarHandler_ptr
call_attribute::AMI_iBarHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_iBarHandler>::unchecked_narrow (_tao_objref);
}

call_attribute::AMI_iBarHandler_ptr
call_attribute::AMI_iBarHandler::_nil ()
{
  return nullptr;
}

call_attribute::AMI_iBarHandler_ptr
call_attribute::AMI_iBarHandler::_duplicate (AMI_iBarHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
call_attribute::AMI_iBarHandler::_tao_release (AMI_iBarHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
call_attribute::AMI_iBarHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:call_attribute/AMI_iBarHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* call_attribute::AMI_iBarHandler::_interface_repository_id () const
{
  return "IDL:call_attribute/AMI_iBarHandler:1.0";
}

const char* call_attribute::AMI_iBarHandler::_desc_repository_id ()
{
  return "IDL:call_attribute/AMI_iBarHandler:1.0";
}

const char* call_attribute::AMI_iBarHandler::_desc_interface_name ()
{
  return "AMI_iBarHandler";
}

::CORBA::Boolean
call_attribute::AMI_iBarHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_call_attribute_AMI_iBarHandler (
    ::CORBA::tk_objref,
    "IDL:call_attribute/AMI_iBarHandler:1.0",
    "AMI_iBarHandler");
  

namespace call_attribute
{
  ::CORBA::TypeCode_ptr const _tc_AMI_iBarHandler =
    &_tao_tc_call_attribute_AMI_iBarHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_BaseExceptionHolder::~OBV_AMH_BaseExceptionHolder ()
{}

::CORBA::Boolean
OBV_AMH_BaseExceptionHolder::_tao_marshal__AMH_BaseExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_BaseExceptionHolder::_tao_unmarshal__AMH_BaseExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_DerivedExceptionHolder::~OBV_AMH_DerivedExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_DerivedExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_DerivedExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_DerivedExceptionHolder::_tao_marshal__AMH_DerivedExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_DerivedExceptionHolder::_tao_unmarshal__AMH_DerivedExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_foostepExceptionHolder::~OBV_AMH_foostepExceptionHolder ()
{}

::CORBA::Boolean
OBV_AMH_foostepExceptionHolder::_tao_marshal__AMH_foostepExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_foostepExceptionHolder::_tao_unmarshal__AMH_foostepExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_motherExceptionHolder::~OBV_AMH_motherExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_motherExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_motherExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_motherExceptionHolder::_tao_marshal__AMH_motherExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_motherExceptionHolder::_tao_unmarshal__AMH_motherExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_fatherExceptionHolder::~OBV_AMH_fatherExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_fatherExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_fatherExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_fatherExceptionHolder::_tao_marshal__AMH_fatherExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_fatherExceptionHolder::_tao_unmarshal__AMH_fatherExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_childExceptionHolder::~OBV_AMH_childExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_childExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_childExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_childExceptionHolder::_tao_marshal__AMH_childExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_childExceptionHolder::_tao_unmarshal__AMH_childExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH__cxx_tryExceptionHolder::~OBV_AMH__cxx_tryExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH__cxx_tryExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH__cxx_tryExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH__cxx_tryExceptionHolder::_tao_marshal__AMH__cxx_tryExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH__cxx_tryExceptionHolder::_tao_unmarshal__AMH__cxx_tryExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_later_userExceptionHolder::~OBV_AMH_later_userExceptionHolder ()
{}

::CORBA::Boolean
OBV_AMH_later_userExceptionHolder::_tao_marshal__AMH_later_userExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_later_userExceptionHolder::_tao_unmarshal__AMH_later_userExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_laterExceptionHolder::~OBV_AMH_laterExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_laterExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_laterExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_laterExceptionHolder::_tao_marshal__AMH_laterExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_laterExceptionHolder::_tao_unmarshal__AMH_laterExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_BeginExceptionHolder::~OBV_AMH_BeginExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_BeginExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_BeginExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_BeginExceptionHolder::_tao_marshal__AMH_BeginExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_BeginExceptionHolder::_tao_unmarshal__AMH_BeginExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_MiddleExceptionHolder::~OBV_AMH_MiddleExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_MiddleExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_MiddleExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_MiddleExceptionHolder::_tao_marshal__AMH_MiddleExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_MiddleExceptionHolder::_tao_unmarshal__AMH_MiddleExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_EndExceptionHolder::~OBV_AMH_EndExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_EndExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_EndExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_EndExceptionHolder::_tao_marshal__AMH_EndExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_EndExceptionHolder::_tao_unmarshal__AMH_EndExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_ClientExceptionHolder::~OBV_AMH_ClientExceptionHolder ()
{}

::CORBA::Boolean
OBV_AMH_ClientExceptionHolder::_tao_marshal__AMH_ClientExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_ClientExceptionHolder::_tao_unmarshal__AMH_ClientExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_AttributeTesterExceptionHolder::~OBV_AMH_AttributeTesterExceptionHolder ()
{}

::CORBA::Boolean
OBV_AMH_AttributeTesterExceptionHolder::_tao_marshal__AMH_AttributeTesterExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_AttributeTesterExceptionHolder::_tao_unmarshal__AMH_AttributeTesterExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_ParamMod::AMH_ParameterTesterExceptionHolder::~AMH_ParameterTesterExceptionHolder ()
{}

::CORBA::Boolean
OBV_ParamMod::AMH_ParameterTesterExceptionHolder::_tao_marshal__ParamMod_AMH_ParameterTesterExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_ParamMod::AMH_ParameterTesterExceptionHolder::_tao_unmarshal__ParamMod_AMH_ParameterTesterExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_AExceptionHolder::~OBV_AMH_AExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_AExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_AExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_AExceptionHolder::_tao_marshal__AMH_AExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_AExceptionHolder::_tao_unmarshal__AMH_AExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_M::AMH_AExceptionHolder::~AMH_AExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_M::AMH_AExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_AExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_M::AMH_AExceptionHolder::_tao_marshal__M_AMH_AExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_M::AMH_AExceptionHolder::_tao_unmarshal__M_AMH_AExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_i1::AMH_if1ExceptionHolder::~AMH_if1ExceptionHolder ()
{}

::CORBA::Boolean
OBV_i1::AMH_if1ExceptionHolder::_tao_marshal__i1_AMH_if1ExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_i1::AMH_if1ExceptionHolder::_tao_unmarshal__i1_AMH_if1ExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_i2::AMH_if2ExceptionHolder::~AMH_if2ExceptionHolder ()
{}

::CORBA::Boolean
OBV_i2::AMH_if2ExceptionHolder::_tao_marshal__i2_AMH_if2ExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_i2::AMH_if2ExceptionHolder::_tao_unmarshal__i2_AMH_if2ExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_i2::AMH_if3ExceptionHolder::~AMH_if3ExceptionHolder ()
{}

::CORBA::Boolean
OBV_i2::AMH_if3ExceptionHolder::_tao_marshal__i2_AMH_if3ExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_i2::AMH_if3ExceptionHolder::_tao_unmarshal__i2_AMH_if3ExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_redefs::AMH_baseExceptionHolder::~AMH_baseExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_redefs::AMH_baseExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_baseExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_redefs::AMH_baseExceptionHolder::_tao_marshal__redefs_AMH_baseExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_redefs::AMH_baseExceptionHolder::_tao_unmarshal__redefs_AMH_baseExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_redefs::AMH_derivedExceptionHolder::~AMH_derivedExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_redefs::AMH_derivedExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_derivedExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_redefs::AMH_derivedExceptionHolder::_tao_marshal__redefs_AMH_derivedExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_redefs::AMH_derivedExceptionHolder::_tao_unmarshal__redefs_AMH_derivedExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_Rec_Arg_Traits::AMH_baseExceptionHolder::~AMH_baseExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_Rec_Arg_Traits::AMH_baseExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_baseExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_marshal__Rec_Arg_Traits_AMH_baseExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_unmarshal__Rec_Arg_Traits_AMH_baseExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_Rec_Arg_Traits::AMH_derivedExceptionHolder::~AMH_derivedExceptionHolder ()
{}

::CORBA::Boolean
OBV_Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_marshal__Rec_Arg_Traits_AMH_derivedExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_unmarshal__Rec_Arg_Traits_AMH_derivedExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_call_test::AMH_iTestExceptionHolder::~AMH_iTestExceptionHolder ()
{}

::CORBA::Boolean
OBV_call_test::AMH_iTestExceptionHolder::_tao_marshal__call_test_AMH_iTestExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_call_test::AMH_iTestExceptionHolder::_tao_unmarshal__call_test_AMH_iTestExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_call_attribute::AMH_iBarExceptionHolder::~AMH_iBarExceptionHolder ()
{}

::CORBA::Boolean
OBV_call_attribute::AMH_iBarExceptionHolder::_tao_marshal__call_attribute_AMH_iBarExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_call_attribute::AMH_iBarExceptionHolder::_tao_unmarshal__call_attribute_AMH_iBarExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Base>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Base_ptr _tao_elem)
{
  Base_ptr _tao_objptr =
    Base::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Base_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Base>::insert (
    _tao_any,
    Base::_tao_any_destructor,
    _tc_Base,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Base_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Base>::extract (
        _tao_any,
        Base::_tao_any_destructor,
        _tc_Base,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BaseExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BaseExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_BaseExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_BaseExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BaseExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_BaseExceptionHolder>::insert (
    _tao_any,
    AMH_BaseExceptionHolder::_tao_any_destructor,
    _tc_AMH_BaseExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_BaseExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_BaseExceptionHolder>::extract (
        _tao_any,
        AMH_BaseExceptionHolder::_tao_any_destructor,
        _tc_AMH_BaseExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BaseResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BaseResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BaseResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BaseResponseHandler_ptr _tao_elem)
{
  AMH_BaseResponseHandler_ptr _tao_objptr =
    AMH_BaseResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BaseResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_BaseResponseHandler>::insert (
    _tao_any,
    AMH_BaseResponseHandler::_tao_any_destructor,
    _tc_AMH_BaseResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_BaseResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_BaseResponseHandler>::extract (
        _tao_any,
        AMH_BaseResponseHandler::_tao_any_destructor,
        _tc_AMH_BaseResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_BaseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_BaseHandler_ptr _tao_elem)
{
  AMI_BaseHandler_ptr _tao_objptr =
    AMI_BaseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_BaseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_BaseHandler>::insert (
    _tao_any,
    AMI_BaseHandler::_tao_any_destructor,
    _tc_AMI_BaseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_BaseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_BaseHandler>::extract (
        _tao_any,
        AMI_BaseHandler::_tao_any_destructor,
        _tc_AMI_BaseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Derived>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Derived_ptr _tao_elem)
{
  Derived_ptr _tao_objptr =
    Derived::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Derived_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Derived>::insert (
    _tao_any,
    Derived::_tao_any_destructor,
    _tc_Derived,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Derived_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Derived>::extract (
        _tao_any,
        Derived::_tao_any_destructor,
        _tc_Derived,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_DerivedExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_DerivedExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_DerivedExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_DerivedExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_DerivedExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_DerivedExceptionHolder>::insert (
    _tao_any,
    AMH_DerivedExceptionHolder::_tao_any_destructor,
    _tc_AMH_DerivedExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_DerivedExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_DerivedExceptionHolder>::extract (
        _tao_any,
        AMH_DerivedExceptionHolder::_tao_any_destructor,
        _tc_AMH_DerivedExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_DerivedResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_DerivedResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_DerivedResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_DerivedResponseHandler_ptr _tao_elem)
{
  AMH_DerivedResponseHandler_ptr _tao_objptr =
    AMH_DerivedResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_DerivedResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_DerivedResponseHandler>::insert (
    _tao_any,
    AMH_DerivedResponseHandler::_tao_any_destructor,
    _tc_AMH_DerivedResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_DerivedResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_DerivedResponseHandler>::extract (
        _tao_any,
        AMH_DerivedResponseHandler::_tao_any_destructor,
        _tc_AMH_DerivedResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_DerivedHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_DerivedHandler_ptr _tao_elem)
{
  AMI_DerivedHandler_ptr _tao_objptr =
    AMI_DerivedHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_DerivedHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_DerivedHandler>::insert (
    _tao_any,
    AMI_DerivedHandler::_tao_any_destructor,
    _tc_AMI_DerivedHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_DerivedHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_DerivedHandler>::extract (
        _tao_any,
        AMI_DerivedHandler::_tao_any_destructor,
        _tc_AMI_DerivedHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::foo_mod::date &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::foo_mod::date>::insert_copy (
    _tao_any,
    ::foo_mod::date::_tao_any_destructor,
    foo_mod::_tc_date,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::foo_mod::date *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::foo_mod::date>::insert (
    _tao_any,
    ::foo_mod::date::_tao_any_destructor,
    foo_mod::_tc_date,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::foo_mod::date *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::foo_mod::date>::extract (
    _tao_any,
    ::foo_mod::date::_tao_any_destructor,
    foo_mod::_tc_date,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<foostep>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  foostep_ptr _tao_elem)
{
  foostep_ptr _tao_objptr =
    foostep::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  foostep_ptr *_tao_elem)
{
  TAO::Any_Impl_T<foostep>::insert (
    _tao_any,
    foostep::_tao_any_destructor,
    _tc_foostep,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    foostep_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<foostep>::extract (
        _tao_any,
        foostep::_tao_any_destructor,
        _tc_foostep,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_foostepExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_foostepExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_foostepExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_foostepExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_foostepExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_foostepExceptionHolder>::insert (
    _tao_any,
    AMH_foostepExceptionHolder::_tao_any_destructor,
    _tc_AMH_foostepExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_foostepExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_foostepExceptionHolder>::extract (
        _tao_any,
        AMH_foostepExceptionHolder::_tao_any_destructor,
        _tc_AMH_foostepExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_foostepResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_foostepResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_foostepResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_foostepResponseHandler_ptr _tao_elem)
{
  AMH_foostepResponseHandler_ptr _tao_objptr =
    AMH_foostepResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_foostepResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_foostepResponseHandler>::insert (
    _tao_any,
    AMH_foostepResponseHandler::_tao_any_destructor,
    _tc_AMH_foostepResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_foostepResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_foostepResponseHandler>::extract (
        _tao_any,
        AMH_foostepResponseHandler::_tao_any_destructor,
        _tc_AMH_foostepResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_foostepHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_foostepHandler_ptr _tao_elem)
{
  AMI_foostepHandler_ptr _tao_objptr =
    AMI_foostepHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_foostepHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_foostepHandler>::insert (
    _tao_any,
    AMI_foostepHandler::_tao_any_destructor,
    _tc_AMI_foostepHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_foostepHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_foostepHandler>::extract (
        _tao_any,
        AMI_foostepHandler::_tao_any_destructor,
        _tc_AMI_foostepHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mother>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mother_ptr _tao_elem)
{
  mother_ptr _tao_objptr =
    mother::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mother_ptr *_tao_elem)
{
  TAO::Any_Impl_T<mother>::insert (
    _tao_any,
    mother::_tao_any_destructor,
    _tc_mother,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mother_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<mother>::extract (
        _tao_any,
        mother::_tao_any_destructor,
        _tc_mother,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::mother::member &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::mother::member>::insert_copy (
    _tao_any,
    ::mother::member::_tao_any_destructor,
    mother::_tc_member,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::mother::member *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::mother::member>::insert (
    _tao_any,
    ::mother::member::_tao_any_destructor,
    mother::_tc_member,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::mother::member *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::mother::member>::extract (
    _tao_any,
    ::mother::member::_tao_any_destructor,
    mother::_tc_member,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_motherExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_motherExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_motherExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_motherExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_motherExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_motherExceptionHolder>::insert (
    _tao_any,
    AMH_motherExceptionHolder::_tao_any_destructor,
    _tc_AMH_motherExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_motherExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_motherExceptionHolder>::extract (
        _tao_any,
        AMH_motherExceptionHolder::_tao_any_destructor,
        _tc_AMH_motherExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_motherResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_motherResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_motherResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_motherResponseHandler_ptr _tao_elem)
{
  AMH_motherResponseHandler_ptr _tao_objptr =
    AMH_motherResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_motherResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_motherResponseHandler>::insert (
    _tao_any,
    AMH_motherResponseHandler::_tao_any_destructor,
    _tc_AMH_motherResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_motherResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_motherResponseHandler>::extract (
        _tao_any,
        AMH_motherResponseHandler::_tao_any_destructor,
        _tc_AMH_motherResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_motherHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_motherHandler_ptr _tao_elem)
{
  AMI_motherHandler_ptr _tao_objptr =
    AMI_motherHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_motherHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_motherHandler>::insert (
    _tao_any,
    AMI_motherHandler::_tao_any_destructor,
    _tc_AMI_motherHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_motherHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_motherHandler>::extract (
        _tao_any,
        AMI_motherHandler::_tao_any_destructor,
        _tc_AMI_motherHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<father>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  father_ptr _tao_elem)
{
  father_ptr _tao_objptr =
    father::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  father_ptr *_tao_elem)
{
  TAO::Any_Impl_T<father>::insert (
    _tao_any,
    father::_tao_any_destructor,
    _tc_father,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    father_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<father>::extract (
        _tao_any,
        father::_tao_any_destructor,
        _tc_father,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::father::member &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::father::member>::insert_copy (
    _tao_any,
    ::father::member::_tao_any_destructor,
    father::_tc_member,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::father::member *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::father::member>::insert (
    _tao_any,
    ::father::member::_tao_any_destructor,
    father::_tc_member,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::father::member *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::father::member>::extract (
    _tao_any,
    ::father::member::_tao_any_destructor,
    father::_tc_member,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_fatherExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_fatherExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_fatherExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_fatherExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_fatherExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_fatherExceptionHolder>::insert (
    _tao_any,
    AMH_fatherExceptionHolder::_tao_any_destructor,
    _tc_AMH_fatherExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_fatherExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_fatherExceptionHolder>::extract (
        _tao_any,
        AMH_fatherExceptionHolder::_tao_any_destructor,
        _tc_AMH_fatherExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_fatherResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_fatherResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_fatherResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_fatherResponseHandler_ptr _tao_elem)
{
  AMH_fatherResponseHandler_ptr _tao_objptr =
    AMH_fatherResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_fatherResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_fatherResponseHandler>::insert (
    _tao_any,
    AMH_fatherResponseHandler::_tao_any_destructor,
    _tc_AMH_fatherResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_fatherResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_fatherResponseHandler>::extract (
        _tao_any,
        AMH_fatherResponseHandler::_tao_any_destructor,
        _tc_AMH_fatherResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_fatherHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_fatherHandler_ptr _tao_elem)
{
  AMI_fatherHandler_ptr _tao_objptr =
    AMI_fatherHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_fatherHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_fatherHandler>::insert (
    _tao_any,
    AMI_fatherHandler::_tao_any_destructor,
    _tc_AMI_fatherHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_fatherHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_fatherHandler>::extract (
        _tao_any,
        AMI_fatherHandler::_tao_any_destructor,
        _tc_AMI_fatherHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<child>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  child_ptr _tao_elem)
{
  child_ptr _tao_objptr =
    child::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  child_ptr *_tao_elem)
{
  TAO::Any_Impl_T<child>::insert (
    _tao_any,
    child::_tao_any_destructor,
    _tc_child,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    child_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<child>::extract (
        _tao_any,
        child::_tao_any_destructor,
        _tc_child,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_childExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_childExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_childExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_childExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_childExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_childExceptionHolder>::insert (
    _tao_any,
    AMH_childExceptionHolder::_tao_any_destructor,
    _tc_AMH_childExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_childExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_childExceptionHolder>::extract (
        _tao_any,
        AMH_childExceptionHolder::_tao_any_destructor,
        _tc_AMH_childExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_childResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_childResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_childResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_childResponseHandler_ptr _tao_elem)
{
  AMH_childResponseHandler_ptr _tao_objptr =
    AMH_childResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_childResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_childResponseHandler>::insert (
    _tao_any,
    AMH_childResponseHandler::_tao_any_destructor,
    _tc_AMH_childResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_childResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_childResponseHandler>::extract (
        _tao_any,
        AMH_childResponseHandler::_tao_any_destructor,
        _tc_AMH_childResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_childHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_childHandler_ptr _tao_elem)
{
  AMI_childHandler_ptr _tao_objptr =
    AMI_childHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_childHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_childHandler>::insert (
    _tao_any,
    AMI_childHandler::_tao_any_destructor,
    _tc_AMI_childHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_childHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_childHandler>::extract (
        _tao_any,
        AMI_childHandler::_tao_any_destructor,
        _tc_AMI_childHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<_cxx_try>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  _cxx_try_ptr _tao_elem)
{
  _cxx_try_ptr _tao_objptr =
    _cxx_try::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  _cxx_try_ptr *_tao_elem)
{
  TAO::Any_Impl_T<_cxx_try>::insert (
    _tao_any,
    _cxx_try::_tao_any_destructor,
    _tc__cxx_try,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    _cxx_try_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<_cxx_try>::extract (
        _tao_any,
        _cxx_try::_tao_any_destructor,
        _tc__cxx_try,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH__cxx_tryExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH__cxx_tryExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH__cxx_tryExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH__cxx_tryExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH__cxx_tryExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH__cxx_tryExceptionHolder>::insert (
    _tao_any,
    AMH__cxx_tryExceptionHolder::_tao_any_destructor,
    _tc_AMH__cxx_tryExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH__cxx_tryExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH__cxx_tryExceptionHolder>::extract (
        _tao_any,
        AMH__cxx_tryExceptionHolder::_tao_any_destructor,
        _tc_AMH__cxx_tryExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH__cxx_tryResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH__cxx_tryResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH__cxx_tryResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH__cxx_tryResponseHandler_ptr _tao_elem)
{
  AMH__cxx_tryResponseHandler_ptr _tao_objptr =
    AMH__cxx_tryResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH__cxx_tryResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH__cxx_tryResponseHandler>::insert (
    _tao_any,
    AMH__cxx_tryResponseHandler::_tao_any_destructor,
    _tc_AMH__cxx_tryResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH__cxx_tryResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH__cxx_tryResponseHandler>::extract (
        _tao_any,
        AMH__cxx_tryResponseHandler::_tao_any_destructor,
        _tc_AMH__cxx_tryResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI__cxx_tryHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI__cxx_tryHandler_ptr _tao_elem)
{
  AMI__cxx_tryHandler_ptr _tao_objptr =
    AMI__cxx_tryHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI__cxx_tryHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI__cxx_tryHandler>::insert (
    _tao_any,
    AMI__cxx_tryHandler::_tao_any_destructor,
    _tc_AMI__cxx_tryHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI__cxx_tryHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI__cxx_tryHandler>::extract (
        _tao_any,
        AMI__cxx_tryHandler::_tao_any_destructor,
        _tc_AMI__cxx_tryHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<later_user>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  later_user_ptr _tao_elem)
{
  later_user_ptr _tao_objptr =
    later_user::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  later_user_ptr *_tao_elem)
{
  TAO::Any_Impl_T<later_user>::insert (
    _tao_any,
    later_user::_tao_any_destructor,
    _tc_later_user,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    later_user_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<later_user>::extract (
        _tao_any,
        later_user::_tao_any_destructor,
        _tc_later_user,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_later_userExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_later_userExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_later_userExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_later_userExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_later_userExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_later_userExceptionHolder>::insert (
    _tao_any,
    AMH_later_userExceptionHolder::_tao_any_destructor,
    _tc_AMH_later_userExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_later_userExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_later_userExceptionHolder>::extract (
        _tao_any,
        AMH_later_userExceptionHolder::_tao_any_destructor,
        _tc_AMH_later_userExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_later_userResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_later_userResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_later_userResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_later_userResponseHandler_ptr _tao_elem)
{
  AMH_later_userResponseHandler_ptr _tao_objptr =
    AMH_later_userResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_later_userResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_later_userResponseHandler>::insert (
    _tao_any,
    AMH_later_userResponseHandler::_tao_any_destructor,
    _tc_AMH_later_userResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_later_userResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_later_userResponseHandler>::extract (
        _tao_any,
        AMH_later_userResponseHandler::_tao_any_destructor,
        _tc_AMH_later_userResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_later_userHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_later_userHandler_ptr _tao_elem)
{
  AMI_later_userHandler_ptr _tao_objptr =
    AMI_later_userHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_later_userHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_later_userHandler>::insert (
    _tao_any,
    AMI_later_userHandler::_tao_any_destructor,
    _tc_AMI_later_userHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_later_userHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_later_userHandler>::extract (
        _tao_any,
        AMI_later_userHandler::_tao_any_destructor,
        _tc_AMI_later_userHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::later_holder &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::later_holder>::insert_copy (
    _tao_any,
    ::later_holder::_tao_any_destructor,
    _tc_later_holder,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::later_holder *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::later_holder>::insert (
    _tao_any,
    ::later_holder::_tao_any_destructor,
    _tc_later_holder,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::later_holder *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::later_holder>::extract (
    _tao_any,
    ::later_holder::_tao_any_destructor,
    _tc_later_holder,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<later>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  later_ptr _tao_elem)
{
  later_ptr _tao_objptr =
    later::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  later_ptr *_tao_elem)
{
  TAO::Any_Impl_T<later>::insert (
    _tao_any,
    later::_tao_any_destructor,
    _tc_later,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    later_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<later>::extract (
        _tao_any,
        later::_tao_any_destructor,
        _tc_later,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_laterExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_laterExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_laterExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_laterExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_laterExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_laterExceptionHolder>::insert (
    _tao_any,
    AMH_laterExceptionHolder::_tao_any_destructor,
    _tc_AMH_laterExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_laterExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_laterExceptionHolder>::extract (
        _tao_any,
        AMH_laterExceptionHolder::_tao_any_destructor,
        _tc_AMH_laterExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_laterResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_laterResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_laterResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_laterResponseHandler_ptr _tao_elem)
{
  AMH_laterResponseHandler_ptr _tao_objptr =
    AMH_laterResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_laterResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_laterResponseHandler>::insert (
    _tao_any,
    AMH_laterResponseHandler::_tao_any_destructor,
    _tc_AMH_laterResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_laterResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_laterResponseHandler>::extract (
        _tao_any,
        AMH_laterResponseHandler::_tao_any_destructor,
        _tc_AMH_laterResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_laterHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_laterHandler_ptr _tao_elem)
{
  AMI_laterHandler_ptr _tao_objptr =
    AMI_laterHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_laterHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_laterHandler>::insert (
    _tao_any,
    AMI_laterHandler::_tao_any_destructor,
    _tc_AMI_laterHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_laterHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_laterHandler>::extract (
        _tao_any,
        AMI_laterHandler::_tao_any_destructor,
        _tc_AMI_laterHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Begin>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Begin_ptr _tao_elem)
{
  Begin_ptr _tao_objptr =
    Begin::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Begin_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Begin>::insert (
    _tao_any,
    Begin::_tao_any_destructor,
    _tc_Begin,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Begin_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Begin>::extract (
        _tao_any,
        Begin::_tao_any_destructor,
        _tc_Begin,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BeginExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BeginExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_BeginExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_BeginExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BeginExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_BeginExceptionHolder>::insert (
    _tao_any,
    AMH_BeginExceptionHolder::_tao_any_destructor,
    _tc_AMH_BeginExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_BeginExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_BeginExceptionHolder>::extract (
        _tao_any,
        AMH_BeginExceptionHolder::_tao_any_destructor,
        _tc_AMH_BeginExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BeginResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BeginResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BeginResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BeginResponseHandler_ptr _tao_elem)
{
  AMH_BeginResponseHandler_ptr _tao_objptr =
    AMH_BeginResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BeginResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_BeginResponseHandler>::insert (
    _tao_any,
    AMH_BeginResponseHandler::_tao_any_destructor,
    _tc_AMH_BeginResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_BeginResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_BeginResponseHandler>::extract (
        _tao_any,
        AMH_BeginResponseHandler::_tao_any_destructor,
        _tc_AMH_BeginResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_BeginHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_BeginHandler_ptr _tao_elem)
{
  AMI_BeginHandler_ptr _tao_objptr =
    AMI_BeginHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_BeginHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_BeginHandler>::insert (
    _tao_any,
    AMI_BeginHandler::_tao_any_destructor,
    _tc_AMI_BeginHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_BeginHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_BeginHandler>::extract (
        _tao_any,
        AMI_BeginHandler::_tao_any_destructor,
        _tc_AMI_BeginHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Middle>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Middle_ptr _tao_elem)
{
  Middle_ptr _tao_objptr =
    Middle::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Middle_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Middle>::insert (
    _tao_any,
    Middle::_tao_any_destructor,
    _tc_Middle,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Middle_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Middle>::extract (
        _tao_any,
        Middle::_tao_any_destructor,
        _tc_Middle,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_MiddleExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_MiddleExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_MiddleExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_MiddleExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_MiddleExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_MiddleExceptionHolder>::insert (
    _tao_any,
    AMH_MiddleExceptionHolder::_tao_any_destructor,
    _tc_AMH_MiddleExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_MiddleExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_MiddleExceptionHolder>::extract (
        _tao_any,
        AMH_MiddleExceptionHolder::_tao_any_destructor,
        _tc_AMH_MiddleExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_MiddleResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_MiddleResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_MiddleResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_MiddleResponseHandler_ptr _tao_elem)
{
  AMH_MiddleResponseHandler_ptr _tao_objptr =
    AMH_MiddleResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_MiddleResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_MiddleResponseHandler>::insert (
    _tao_any,
    AMH_MiddleResponseHandler::_tao_any_destructor,
    _tc_AMH_MiddleResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_MiddleResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_MiddleResponseHandler>::extract (
        _tao_any,
        AMH_MiddleResponseHandler::_tao_any_destructor,
        _tc_AMH_MiddleResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_MiddleHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_MiddleHandler_ptr _tao_elem)
{
  AMI_MiddleHandler_ptr _tao_objptr =
    AMI_MiddleHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_MiddleHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_MiddleHandler>::insert (
    _tao_any,
    AMI_MiddleHandler::_tao_any_destructor,
    _tc_AMI_MiddleHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_MiddleHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_MiddleHandler>::extract (
        _tao_any,
        AMI_MiddleHandler::_tao_any_destructor,
        _tc_AMI_MiddleHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<End>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  End_ptr _tao_elem)
{
  End_ptr _tao_objptr =
    End::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  End_ptr *_tao_elem)
{
  TAO::Any_Impl_T<End>::insert (
    _tao_any,
    End::_tao_any_destructor,
    _tc_End,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    End_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<End>::extract (
        _tao_any,
        End::_tao_any_destructor,
        _tc_End,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_EndExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_EndExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_EndExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_EndExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_EndExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_EndExceptionHolder>::insert (
    _tao_any,
    AMH_EndExceptionHolder::_tao_any_destructor,
    _tc_AMH_EndExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_EndExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_EndExceptionHolder>::extract (
        _tao_any,
        AMH_EndExceptionHolder::_tao_any_destructor,
        _tc_AMH_EndExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_EndResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_EndResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_EndResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_EndResponseHandler_ptr _tao_elem)
{
  AMH_EndResponseHandler_ptr _tao_objptr =
    AMH_EndResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_EndResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_EndResponseHandler>::insert (
    _tao_any,
    AMH_EndResponseHandler::_tao_any_destructor,
    _tc_AMH_EndResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_EndResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_EndResponseHandler>::extract (
        _tao_any,
        AMH_EndResponseHandler::_tao_any_destructor,
        _tc_AMH_EndResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_EndHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_EndHandler_ptr _tao_elem)
{
  AMI_EndHandler_ptr _tao_objptr =
    AMI_EndHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_EndHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_EndHandler>::insert (
    _tao_any,
    AMI_EndHandler::_tao_any_destructor,
    _tc_AMI_EndHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_EndHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_EndHandler>::extract (
        _tao_any,
        AMI_EndHandler::_tao_any_destructor,
        _tc_AMI_EndHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Client>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Client_ptr _tao_elem)
{
  Client_ptr _tao_objptr =
    Client::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Client_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Client>::insert (
    _tao_any,
    Client::_tao_any_destructor,
    _tc_Client,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Client_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Client>::extract (
        _tao_any,
        Client::_tao_any_destructor,
        _tc_Client,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_ClientExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_ClientExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_ClientExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_ClientExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_ClientExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_ClientExceptionHolder>::insert (
    _tao_any,
    AMH_ClientExceptionHolder::_tao_any_destructor,
    _tc_AMH_ClientExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_ClientExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_ClientExceptionHolder>::extract (
        _tao_any,
        AMH_ClientExceptionHolder::_tao_any_destructor,
        _tc_AMH_ClientExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_ClientResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_ClientResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_ClientResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_ClientResponseHandler_ptr _tao_elem)
{
  AMH_ClientResponseHandler_ptr _tao_objptr =
    AMH_ClientResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_ClientResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_ClientResponseHandler>::insert (
    _tao_any,
    AMH_ClientResponseHandler::_tao_any_destructor,
    _tc_AMH_ClientResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_ClientResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_ClientResponseHandler>::extract (
        _tao_any,
        AMH_ClientResponseHandler::_tao_any_destructor,
        _tc_AMH_ClientResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_ClientHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_ClientHandler_ptr _tao_elem)
{
  AMI_ClientHandler_ptr _tao_objptr =
    AMI_ClientHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_ClientHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_ClientHandler>::insert (
    _tao_any,
    AMI_ClientHandler::_tao_any_destructor,
    _tc_AMI_ClientHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_ClientHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_ClientHandler>::extract (
        _tao_any,
        AMI_ClientHandler::_tao_any_destructor,
        _tc_AMI_ClientHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AttributeTester>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AttributeTester_ptr _tao_elem)
{
  AttributeTester_ptr _tao_objptr =
    AttributeTester::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AttributeTester_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AttributeTester>::insert (
    _tao_any,
    AttributeTester::_tao_any_destructor,
    _tc_AttributeTester,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AttributeTester_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AttributeTester>::extract (
        _tao_any,
        AttributeTester::_tao_any_destructor,
        _tc_AttributeTester,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_array/any_op_cs.cpp:31


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

void operator<<= (
    ::CORBA::Any &_tao_any,
    const AttributeTester::string_1_forany &_tao_elem)
  
{
  TAO::Any_Array_Impl_T<
      AttributeTester::string_1_slice,
      AttributeTester::string_1_forany
    >::insert (
        _tao_any,
        AttributeTester::string_1_forany::_tao_any_destructor,
        AttributeTester::_tc_string_1,
        _tao_elem.nocopy ()
          ? _tao_elem.ptr ()
          : AttributeTester::string_1_dup (_tao_elem.in ())
      );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    AttributeTester::string_1_forany &_tao_elem)
  
{
  return
    TAO::Any_Array_Impl_T<
        AttributeTester::string_1_slice,
        AttributeTester::string_1_forany
      >::extract (
          _tao_any,
          AttributeTester::string_1_forany::_tao_any_destructor,
          AttributeTester::_tc_string_1,
          _tao_elem.out ());
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_AttributeTesterExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_AttributeTesterExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_AttributeTesterExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_AttributeTesterExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_AttributeTesterExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_AttributeTesterExceptionHolder>::insert (
    _tao_any,
    AMH_AttributeTesterExceptionHolder::_tao_any_destructor,
    _tc_AMH_AttributeTesterExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_AttributeTesterExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_AttributeTesterExceptionHolder>::extract (
        _tao_any,
        AMH_AttributeTesterExceptionHolder::_tao_any_destructor,
        _tc_AMH_AttributeTesterExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_AttributeTesterResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_AttributeTesterResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_AttributeTesterResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_AttributeTesterResponseHandler_ptr _tao_elem)
{
  AMH_AttributeTesterResponseHandler_ptr _tao_objptr =
    AMH_AttributeTesterResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_AttributeTesterResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_AttributeTesterResponseHandler>::insert (
    _tao_any,
    AMH_AttributeTesterResponseHandler::_tao_any_destructor,
    _tc_AMH_AttributeTesterResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_AttributeTesterResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_AttributeTesterResponseHandler>::extract (
        _tao_any,
        AMH_AttributeTesterResponseHandler::_tao_any_destructor,
        _tc_AMH_AttributeTesterResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_AttributeTesterHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_AttributeTesterHandler_ptr _tao_elem)
{
  AMI_AttributeTesterHandler_ptr _tao_objptr =
    AMI_AttributeTesterHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_AttributeTesterHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_AttributeTesterHandler>::insert (
    _tao_any,
    AMI_AttributeTesterHandler::_tao_any_destructor,
    _tc_AMI_AttributeTesterHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_AttributeTesterHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_AttributeTesterHandler>::extract (
        _tao_any,
        AMI_AttributeTesterHandler::_tao_any_destructor,
        _tc_AMI_AttributeTesterHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<ParamMod::ParameterTester>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ParamMod::ParameterTester_ptr _tao_elem)
{
  ParamMod::ParameterTester_ptr _tao_objptr =
    ParamMod::ParameterTester::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ParamMod::ParameterTester_ptr *_tao_elem)
{
  TAO::Any_Impl_T<ParamMod::ParameterTester>::insert (
    _tao_any,
    ParamMod::ParameterTester::_tao_any_destructor,
    ParamMod::_tc_ParameterTester,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    ParamMod::ParameterTester_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<ParamMod::ParameterTester>::extract (
        _tao_any,
        ParamMod::ParameterTester::_tao_any_destructor,
        ParamMod::_tc_ParameterTester,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<ParamMod::ParameterTester::object_excep_type>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ParamMod::ParameterTester::object_excep_type &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ParamMod::ParameterTester::object_excep_type>::insert_copy (
    _tao_any,
    ParamMod::ParameterTester::object_excep_type::_tao_any_destructor,
    ParamMod::ParameterTester::_tc_object_excep_type,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ParamMod::ParameterTester::object_excep_type *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ParamMod::ParameterTester::object_excep_type>::insert (
    _tao_any,
    ParamMod::ParameterTester::object_excep_type::_tao_any_destructor,
    ParamMod::ParameterTester::_tc_object_excep_type,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ParamMod::ParameterTester::object_excep_type *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<ParamMod::ParameterTester::object_excep_type>::extract (
    _tao_any,
    ParamMod::ParameterTester::object_excep_type::_tao_any_destructor,
    ParamMod::ParameterTester::_tc_object_excep_type,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/any_op_cs.cpp:43


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {


/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::ParamMod::ParameterTester::object_seq_type &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::ParamMod::ParameterTester::object_seq_type>::insert_copy (
    _tao_any,
    ::ParamMod::ParameterTester::object_seq_type::_tao_any_destructor,
    ::ParamMod::ParameterTester::_tc_object_seq_type,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::ParamMod::ParameterTester::object_seq_type *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::ParamMod::ParameterTester::object_seq_type>::insert (
    _tao_any,
    ::ParamMod::ParameterTester::object_seq_type::_tao_any_destructor,
    ::ParamMod::ParameterTester::_tc_object_seq_type,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::ParamMod::ParameterTester::object_seq_type *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::ParamMod::ParameterTester::object_seq_type>::extract (
    _tao_any,
    ::ParamMod::ParameterTester::object_seq_type::_tao_any_destructor,
    ::ParamMod::ParameterTester::_tc_object_seq_type,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_array/any_op_cs.cpp:31


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

void operator<<= (
    ::CORBA::Any &_tao_any,
    const ParamMod::ParameterTester::object_array_type_forany &_tao_elem)
  
{
  TAO::Any_Array_Impl_T<
      ParamMod::ParameterTester::object_array_type_slice,
      ParamMod::ParameterTester::object_array_type_forany
    >::insert (
        _tao_any,
        ParamMod::ParameterTester::object_array_type_forany::_tao_any_destructor,
        ParamMod::ParameterTester::_tc_object_array_type,
        _tao_elem.nocopy ()
          ? _tao_elem.ptr ()
          : ParamMod::ParameterTester::object_array_type_dup (_tao_elem.in ())
      );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ParamMod::ParameterTester::object_array_type_forany &_tao_elem)
  
{
  return
    TAO::Any_Array_Impl_T<
        ParamMod::ParameterTester::object_array_type_slice,
        ParamMod::ParameterTester::object_array_type_forany
      >::extract (
          _tao_any,
          ParamMod::ParameterTester::object_array_type_forany::_tao_any_destructor,
          ParamMod::ParameterTester::_tc_object_array_type,
          _tao_elem.out ());
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::ParamMod::ParameterTester::object_struct_type &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::ParamMod::ParameterTester::object_struct_type>::insert_copy (
    _tao_any,
    ::ParamMod::ParameterTester::object_struct_type::_tao_any_destructor,
    ParamMod::ParameterTester::_tc_object_struct_type,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::ParamMod::ParameterTester::object_struct_type *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::ParamMod::ParameterTester::object_struct_type>::insert (
    _tao_any,
    ::ParamMod::ParameterTester::object_struct_type::_tao_any_destructor,
    ParamMod::ParameterTester::_tc_object_struct_type,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::ParamMod::ParameterTester::object_struct_type *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::ParamMod::ParameterTester::object_struct_type>::extract (
    _tao_any,
    ::ParamMod::ParameterTester::object_struct_type::_tao_any_destructor,
    ParamMod::ParameterTester::_tc_object_struct_type,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/any_op_cs.cpp:35


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ParamMod::ParameterTester::object_union_type &_tao_elem)
{
  TAO::Any_Dual_Impl_T<ParamMod::ParameterTester::object_union_type>::insert_copy (
    _tao_any,
    ParamMod::ParameterTester::object_union_type::_tao_any_destructor,
    ParamMod::ParameterTester::_tc_object_union_type,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ParamMod::ParameterTester::object_union_type *_tao_elem)
{
  TAO::Any_Dual_Impl_T<ParamMod::ParameterTester::object_union_type>::insert (
    _tao_any,
    ParamMod::ParameterTester::object_union_type::_tao_any_destructor,
    ParamMod::ParameterTester::_tc_object_union_type,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ParamMod::ParameterTester::object_union_type *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<ParamMod::ParameterTester::object_union_type>::extract (
    _tao_any,
    ParamMod::ParameterTester::object_union_type::_tao_any_destructor,
    ParamMod::ParameterTester::_tc_object_union_type,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<ParamMod::AMH_ParameterTesterExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ParamMod::AMH_ParameterTesterExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    ParamMod::AMH_ParameterTesterExceptionHolder *_tao_copy =
      _tao_elem ?
        ParamMod::AMH_ParameterTesterExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ParamMod::AMH_ParameterTesterExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<ParamMod::AMH_ParameterTesterExceptionHolder>::insert (
    _tao_any,
    ParamMod::AMH_ParameterTesterExceptionHolder::_tao_any_destructor,
    ParamMod::_tc_AMH_ParameterTesterExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    ParamMod::AMH_ParameterTesterExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<ParamMod::AMH_ParameterTesterExceptionHolder>::extract (
        _tao_any,
        ParamMod::AMH_ParameterTesterExceptionHolder::_tao_any_destructor,
        ParamMod::_tc_AMH_ParameterTesterExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<ParamMod::AMH_ParameterTesterResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<ParamMod::AMH_ParameterTesterResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<ParamMod::AMH_ParameterTesterResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ParamMod::AMH_ParameterTesterResponseHandler_ptr _tao_elem)
{
  ParamMod::AMH_ParameterTesterResponseHandler_ptr _tao_objptr =
    ParamMod::AMH_ParameterTesterResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ParamMod::AMH_ParameterTesterResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<ParamMod::AMH_ParameterTesterResponseHandler>::insert (
    _tao_any,
    ParamMod::AMH_ParameterTesterResponseHandler::_tao_any_destructor,
    ParamMod::_tc_AMH_ParameterTesterResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    ParamMod::AMH_ParameterTesterResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<ParamMod::AMH_ParameterTesterResponseHandler>::extract (
        _tao_any,
        ParamMod::AMH_ParameterTesterResponseHandler::_tao_any_destructor,
        ParamMod::_tc_AMH_ParameterTesterResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<ParamMod::AMI_ParameterTesterHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ParamMod::AMI_ParameterTesterHandler_ptr _tao_elem)
{
  ParamMod::AMI_ParameterTesterHandler_ptr _tao_objptr =
    ParamMod::AMI_ParameterTesterHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  ParamMod::AMI_ParameterTesterHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<ParamMod::AMI_ParameterTesterHandler>::insert (
    _tao_any,
    ParamMod::AMI_ParameterTesterHandler::_tao_any_destructor,
    ParamMod::_tc_AMI_ParameterTesterHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    ParamMod::AMI_ParameterTesterHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<ParamMod::AMI_ParameterTesterHandler>::extract (
        _tao_any,
        ParamMod::AMI_ParameterTesterHandler::_tao_any_destructor,
        ParamMod::_tc_AMI_ParameterTesterHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<testlocal>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<testlocal>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<testlocal>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  testlocal_ptr _tao_elem)
{
  testlocal_ptr _tao_objptr =
    testlocal::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  testlocal_ptr *_tao_elem)
{
  TAO::Any_Impl_T<testlocal>::insert (
    _tao_any,
    testlocal::_tao_any_destructor,
    _tc_testlocal,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    testlocal_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<testlocal>::extract (
        _tao_any,
        testlocal::_tao_any_destructor,
        _tc_testlocal,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_ptr _tao_elem)
{
  A_ptr _tao_objptr =
    A::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_ptr *_tao_elem)
{
  TAO::Any_Impl_T<A>::insert (
    _tao_any,
    A::_tao_any_destructor,
    _tc_A,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<A>::extract (
        _tao_any,
        A::_tao_any_destructor,
        _tc_A,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/any_op_cs.cpp:35


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const A::U &_tao_elem)
{
  TAO::Any_Dual_Impl_T<A::U>::insert_copy (
    _tao_any,
    A::U::_tao_any_destructor,
    A::_tc_U,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  A::U *_tao_elem)
{
  TAO::Any_Dual_Impl_T<A::U>::insert (
    _tao_any,
    A::U::_tao_any_destructor,
    A::_tc_U,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const A::U *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<A::U>::extract (
    _tao_any,
    A::U::_tao_any_destructor,
    A::_tc_U,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_AExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_AExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_AExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_AExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_AExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_AExceptionHolder>::insert (
    _tao_any,
    AMH_AExceptionHolder::_tao_any_destructor,
    _tc_AMH_AExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_AExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_AExceptionHolder>::extract (
        _tao_any,
        AMH_AExceptionHolder::_tao_any_destructor,
        _tc_AMH_AExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_AResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_AResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_AResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_AResponseHandler_ptr _tao_elem)
{
  AMH_AResponseHandler_ptr _tao_objptr =
    AMH_AResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_AResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_AResponseHandler>::insert (
    _tao_any,
    AMH_AResponseHandler::_tao_any_destructor,
    _tc_AMH_AResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_AResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_AResponseHandler>::extract (
        _tao_any,
        AMH_AResponseHandler::_tao_any_destructor,
        _tc_AMH_AResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_AHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_AHandler_ptr _tao_elem)
{
  AMI_AHandler_ptr _tao_objptr =
    AMI_AHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_AHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_AHandler>::insert (
    _tao_any,
    AMI_AHandler::_tao_any_destructor,
    _tc_AMI_AHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_AHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_AHandler>::extract (
        _tao_any,
        AMI_AHandler::_tao_any_destructor,
        _tc_AMI_AHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M::A>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M::A_ptr _tao_elem)
{
  M::A_ptr _tao_objptr =
    M::A::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M::A_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M::A>::insert (
    _tao_any,
    M::A::_tao_any_destructor,
    M::_tc_A,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M::A_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M::A>::extract (
        _tao_any,
        M::A::_tao_any_destructor,
        M::_tc_A,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M::AMH_AExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M::AMH_AExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    M::AMH_AExceptionHolder *_tao_copy =
      _tao_elem ?
        M::AMH_AExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M::AMH_AExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<M::AMH_AExceptionHolder>::insert (
    _tao_any,
    M::AMH_AExceptionHolder::_tao_any_destructor,
    M::_tc_AMH_AExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M::AMH_AExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<M::AMH_AExceptionHolder>::extract (
        _tao_any,
        M::AMH_AExceptionHolder::_tao_any_destructor,
        M::_tc_AMH_AExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M::AMH_AResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M::AMH_AResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<M::AMH_AResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M::AMH_AResponseHandler_ptr _tao_elem)
{
  M::AMH_AResponseHandler_ptr _tao_objptr =
    M::AMH_AResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M::AMH_AResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M::AMH_AResponseHandler>::insert (
    _tao_any,
    M::AMH_AResponseHandler::_tao_any_destructor,
    M::_tc_AMH_AResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M::AMH_AResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M::AMH_AResponseHandler>::extract (
        _tao_any,
        M::AMH_AResponseHandler::_tao_any_destructor,
        M::_tc_AMH_AResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<M::AMI_AHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M::AMI_AHandler_ptr _tao_elem)
{
  M::AMI_AHandler_ptr _tao_objptr =
    M::AMI_AHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  M::AMI_AHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<M::AMI_AHandler>::insert (
    _tao_any,
    M::AMI_AHandler::_tao_any_destructor,
    M::_tc_AMI_AHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    M::AMI_AHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<M::AMI_AHandler>::extract (
        _tao_any,
        M::AMI_AHandler::_tao_any_destructor,
        M::_tc_AMI_AHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i1::if1>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i1::if1_ptr _tao_elem)
{
  i1::if1_ptr _tao_objptr =
    i1::if1::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i1::if1_ptr *_tao_elem)
{
  TAO::Any_Impl_T<i1::if1>::insert (
    _tao_any,
    i1::if1::_tao_any_destructor,
    i1::_tc_if1,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i1::if1_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<i1::if1>::extract (
        _tao_any,
        i1::if1::_tao_any_destructor,
        i1::_tc_if1,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i1::AMH_if1ExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i1::AMH_if1ExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    i1::AMH_if1ExceptionHolder *_tao_copy =
      _tao_elem ?
        i1::AMH_if1ExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i1::AMH_if1ExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<i1::AMH_if1ExceptionHolder>::insert (
    _tao_any,
    i1::AMH_if1ExceptionHolder::_tao_any_destructor,
    i1::_tc_AMH_if1ExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i1::AMH_if1ExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<i1::AMH_if1ExceptionHolder>::extract (
        _tao_any,
        i1::AMH_if1ExceptionHolder::_tao_any_destructor,
        i1::_tc_AMH_if1ExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i1::AMH_if1ResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i1::AMH_if1ResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<i1::AMH_if1ResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i1::AMH_if1ResponseHandler_ptr _tao_elem)
{
  i1::AMH_if1ResponseHandler_ptr _tao_objptr =
    i1::AMH_if1ResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i1::AMH_if1ResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<i1::AMH_if1ResponseHandler>::insert (
    _tao_any,
    i1::AMH_if1ResponseHandler::_tao_any_destructor,
    i1::_tc_AMH_if1ResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i1::AMH_if1ResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<i1::AMH_if1ResponseHandler>::extract (
        _tao_any,
        i1::AMH_if1ResponseHandler::_tao_any_destructor,
        i1::_tc_AMH_if1ResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i1::AMI_if1Handler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i1::AMI_if1Handler_ptr _tao_elem)
{
  i1::AMI_if1Handler_ptr _tao_objptr =
    i1::AMI_if1Handler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i1::AMI_if1Handler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<i1::AMI_if1Handler>::insert (
    _tao_any,
    i1::AMI_if1Handler::_tao_any_destructor,
    i1::_tc_AMI_if1Handler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i1::AMI_if1Handler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<i1::AMI_if1Handler>::extract (
        _tao_any,
        i1::AMI_if1Handler::_tao_any_destructor,
        i1::_tc_AMI_if1Handler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::if2>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::if2_ptr _tao_elem)
{
  i2::if2_ptr _tao_objptr =
    i2::if2::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::if2_ptr *_tao_elem)
{
  TAO::Any_Impl_T<i2::if2>::insert (
    _tao_any,
    i2::if2::_tao_any_destructor,
    i2::_tc_if2,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i2::if2_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<i2::if2>::extract (
        _tao_any,
        i2::if2::_tao_any_destructor,
        i2::_tc_if2,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::AMH_if2ExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMH_if2ExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    i2::AMH_if2ExceptionHolder *_tao_copy =
      _tao_elem ?
        i2::AMH_if2ExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMH_if2ExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<i2::AMH_if2ExceptionHolder>::insert (
    _tao_any,
    i2::AMH_if2ExceptionHolder::_tao_any_destructor,
    i2::_tc_AMH_if2ExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i2::AMH_if2ExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<i2::AMH_if2ExceptionHolder>::extract (
        _tao_any,
        i2::AMH_if2ExceptionHolder::_tao_any_destructor,
        i2::_tc_AMH_if2ExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::AMH_if2ResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::AMH_if2ResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::AMH_if2ResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMH_if2ResponseHandler_ptr _tao_elem)
{
  i2::AMH_if2ResponseHandler_ptr _tao_objptr =
    i2::AMH_if2ResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMH_if2ResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<i2::AMH_if2ResponseHandler>::insert (
    _tao_any,
    i2::AMH_if2ResponseHandler::_tao_any_destructor,
    i2::_tc_AMH_if2ResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i2::AMH_if2ResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<i2::AMH_if2ResponseHandler>::extract (
        _tao_any,
        i2::AMH_if2ResponseHandler::_tao_any_destructor,
        i2::_tc_AMH_if2ResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::AMI_if2Handler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMI_if2Handler_ptr _tao_elem)
{
  i2::AMI_if2Handler_ptr _tao_objptr =
    i2::AMI_if2Handler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMI_if2Handler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<i2::AMI_if2Handler>::insert (
    _tao_any,
    i2::AMI_if2Handler::_tao_any_destructor,
    i2::_tc_AMI_if2Handler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i2::AMI_if2Handler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<i2::AMI_if2Handler>::extract (
        _tao_any,
        i2::AMI_if2Handler::_tao_any_destructor,
        i2::_tc_AMI_if2Handler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::if3>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::if3_ptr _tao_elem)
{
  i2::if3_ptr _tao_objptr =
    i2::if3::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::if3_ptr *_tao_elem)
{
  TAO::Any_Impl_T<i2::if3>::insert (
    _tao_any,
    i2::if3::_tao_any_destructor,
    i2::_tc_if3,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i2::if3_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<i2::if3>::extract (
        _tao_any,
        i2::if3::_tao_any_destructor,
        i2::_tc_if3,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::AMH_if3ExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMH_if3ExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    i2::AMH_if3ExceptionHolder *_tao_copy =
      _tao_elem ?
        i2::AMH_if3ExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMH_if3ExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<i2::AMH_if3ExceptionHolder>::insert (
    _tao_any,
    i2::AMH_if3ExceptionHolder::_tao_any_destructor,
    i2::_tc_AMH_if3ExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i2::AMH_if3ExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<i2::AMH_if3ExceptionHolder>::extract (
        _tao_any,
        i2::AMH_if3ExceptionHolder::_tao_any_destructor,
        i2::_tc_AMH_if3ExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::AMH_if3ResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::AMH_if3ResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::AMH_if3ResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMH_if3ResponseHandler_ptr _tao_elem)
{
  i2::AMH_if3ResponseHandler_ptr _tao_objptr =
    i2::AMH_if3ResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMH_if3ResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<i2::AMH_if3ResponseHandler>::insert (
    _tao_any,
    i2::AMH_if3ResponseHandler::_tao_any_destructor,
    i2::_tc_AMH_if3ResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i2::AMH_if3ResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<i2::AMH_if3ResponseHandler>::extract (
        _tao_any,
        i2::AMH_if3ResponseHandler::_tao_any_destructor,
        i2::_tc_AMH_if3ResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<i2::AMI_if3Handler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMI_if3Handler_ptr _tao_elem)
{
  i2::AMI_if3Handler_ptr _tao_objptr =
    i2::AMI_if3Handler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  i2::AMI_if3Handler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<i2::AMI_if3Handler>::insert (
    _tao_any,
    i2::AMI_if3Handler::_tao_any_destructor,
    i2::_tc_AMI_if3Handler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    i2::AMI_if3Handler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<i2::AMI_if3Handler>::extract (
        _tao_any,
        i2::AMI_if3Handler::_tao_any_destructor,
        i2::_tc_AMI_if3Handler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::base>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::base_ptr _tao_elem)
{
  redefs::base_ptr _tao_objptr =
    redefs::base::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::base_ptr *_tao_elem)
{
  TAO::Any_Impl_T<redefs::base>::insert (
    _tao_any,
    redefs::base::_tao_any_destructor,
    redefs::_tc_base,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    redefs::base_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<redefs::base>::extract (
        _tao_any,
        redefs::base::_tao_any_destructor,
        redefs::_tc_base,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<redefs::base::ex>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const redefs::base::ex &_tao_elem)
{
  TAO::Any_Dual_Impl_T<redefs::base::ex>::insert_copy (
    _tao_any,
    redefs::base::ex::_tao_any_destructor,
    redefs::base::_tc_ex,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::base::ex *_tao_elem)
{
  TAO::Any_Dual_Impl_T<redefs::base::ex>::insert (
    _tao_any,
    redefs::base::ex::_tao_any_destructor,
    redefs::base::_tc_ex,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const redefs::base::ex *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<redefs::base::ex>::extract (
    _tao_any,
    redefs::base::ex::_tao_any_destructor,
    redefs::base::_tc_ex,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::redefs::base::foo &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::redefs::base::foo>::insert_copy (
    _tao_any,
    ::redefs::base::foo::_tao_any_destructor,
    redefs::base::_tc_foo,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::redefs::base::foo *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::redefs::base::foo>::insert (
    _tao_any,
    ::redefs::base::foo::_tao_any_destructor,
    redefs::base::_tc_foo,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::redefs::base::foo *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::redefs::base::foo>::extract (
    _tao_any,
    ::redefs::base::foo::_tao_any_destructor,
    redefs::base::_tc_foo,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::AMH_baseExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMH_baseExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    redefs::AMH_baseExceptionHolder *_tao_copy =
      _tao_elem ?
        redefs::AMH_baseExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMH_baseExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<redefs::AMH_baseExceptionHolder>::insert (
    _tao_any,
    redefs::AMH_baseExceptionHolder::_tao_any_destructor,
    redefs::_tc_AMH_baseExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    redefs::AMH_baseExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<redefs::AMH_baseExceptionHolder>::extract (
        _tao_any,
        redefs::AMH_baseExceptionHolder::_tao_any_destructor,
        redefs::_tc_AMH_baseExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::AMH_baseResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::AMH_baseResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::AMH_baseResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMH_baseResponseHandler_ptr _tao_elem)
{
  redefs::AMH_baseResponseHandler_ptr _tao_objptr =
    redefs::AMH_baseResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMH_baseResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<redefs::AMH_baseResponseHandler>::insert (
    _tao_any,
    redefs::AMH_baseResponseHandler::_tao_any_destructor,
    redefs::_tc_AMH_baseResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    redefs::AMH_baseResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<redefs::AMH_baseResponseHandler>::extract (
        _tao_any,
        redefs::AMH_baseResponseHandler::_tao_any_destructor,
        redefs::_tc_AMH_baseResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::AMI_baseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMI_baseHandler_ptr _tao_elem)
{
  redefs::AMI_baseHandler_ptr _tao_objptr =
    redefs::AMI_baseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMI_baseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<redefs::AMI_baseHandler>::insert (
    _tao_any,
    redefs::AMI_baseHandler::_tao_any_destructor,
    redefs::_tc_AMI_baseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    redefs::AMI_baseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<redefs::AMI_baseHandler>::extract (
        _tao_any,
        redefs::AMI_baseHandler::_tao_any_destructor,
        redefs::_tc_AMI_baseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::derived>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::derived_ptr _tao_elem)
{
  redefs::derived_ptr _tao_objptr =
    redefs::derived::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::derived_ptr *_tao_elem)
{
  TAO::Any_Impl_T<redefs::derived>::insert (
    _tao_any,
    redefs::derived::_tao_any_destructor,
    redefs::_tc_derived,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    redefs::derived_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<redefs::derived>::extract (
        _tao_any,
        redefs::derived::_tao_any_destructor,
        redefs::_tc_derived,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<redefs::derived::ex>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const redefs::derived::ex &_tao_elem)
{
  TAO::Any_Dual_Impl_T<redefs::derived::ex>::insert_copy (
    _tao_any,
    redefs::derived::ex::_tao_any_destructor,
    redefs::derived::_tc_ex,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::derived::ex *_tao_elem)
{
  TAO::Any_Dual_Impl_T<redefs::derived::ex>::insert (
    _tao_any,
    redefs::derived::ex::_tao_any_destructor,
    redefs::derived::_tc_ex,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const redefs::derived::ex *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<redefs::derived::ex>::extract (
    _tao_any,
    redefs::derived::ex::_tao_any_destructor,
    redefs::derived::_tc_ex,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::redefs::derived::foo &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::redefs::derived::foo>::insert_copy (
    _tao_any,
    ::redefs::derived::foo::_tao_any_destructor,
    redefs::derived::_tc_foo,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::redefs::derived::foo *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::redefs::derived::foo>::insert (
    _tao_any,
    ::redefs::derived::foo::_tao_any_destructor,
    redefs::derived::_tc_foo,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::redefs::derived::foo *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::redefs::derived::foo>::extract (
    _tao_any,
    ::redefs::derived::foo::_tao_any_destructor,
    redefs::derived::_tc_foo,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::AMH_derivedExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMH_derivedExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    redefs::AMH_derivedExceptionHolder *_tao_copy =
      _tao_elem ?
        redefs::AMH_derivedExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMH_derivedExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<redefs::AMH_derivedExceptionHolder>::insert (
    _tao_any,
    redefs::AMH_derivedExceptionHolder::_tao_any_destructor,
    redefs::_tc_AMH_derivedExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    redefs::AMH_derivedExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<redefs::AMH_derivedExceptionHolder>::extract (
        _tao_any,
        redefs::AMH_derivedExceptionHolder::_tao_any_destructor,
        redefs::_tc_AMH_derivedExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::AMH_derivedResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::AMH_derivedResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::AMH_derivedResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMH_derivedResponseHandler_ptr _tao_elem)
{
  redefs::AMH_derivedResponseHandler_ptr _tao_objptr =
    redefs::AMH_derivedResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMH_derivedResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<redefs::AMH_derivedResponseHandler>::insert (
    _tao_any,
    redefs::AMH_derivedResponseHandler::_tao_any_destructor,
    redefs::_tc_AMH_derivedResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    redefs::AMH_derivedResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<redefs::AMH_derivedResponseHandler>::extract (
        _tao_any,
        redefs::AMH_derivedResponseHandler::_tao_any_destructor,
        redefs::_tc_AMH_derivedResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<redefs::AMI_derivedHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMI_derivedHandler_ptr _tao_elem)
{
  redefs::AMI_derivedHandler_ptr _tao_objptr =
    redefs::AMI_derivedHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  redefs::AMI_derivedHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<redefs::AMI_derivedHandler>::insert (
    _tao_any,
    redefs::AMI_derivedHandler::_tao_any_destructor,
    redefs::_tc_AMI_derivedHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    redefs::AMI_derivedHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<redefs::AMI_derivedHandler>::extract (
        _tao_any,
        redefs::AMI_derivedHandler::_tao_any_destructor,
        redefs::_tc_AMI_derivedHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::base>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::base_ptr _tao_elem)
{
  Rec_Arg_Traits::base_ptr _tao_objptr =
    Rec_Arg_Traits::base::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::base_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Rec_Arg_Traits::base>::insert (
    _tao_any,
    Rec_Arg_Traits::base::_tao_any_destructor,
    Rec_Arg_Traits::_tc_base,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Rec_Arg_Traits::base_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Rec_Arg_Traits::base>::extract (
        _tao_any,
        Rec_Arg_Traits::base::_tao_any_destructor,
        Rec_Arg_Traits::_tc_base,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::AMH_baseExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMH_baseExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Rec_Arg_Traits::AMH_baseExceptionHolder *_tao_copy =
      _tao_elem ?
        Rec_Arg_Traits::AMH_baseExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMH_baseExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<Rec_Arg_Traits::AMH_baseExceptionHolder>::insert (
    _tao_any,
    Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_any_destructor,
    Rec_Arg_Traits::_tc_AMH_baseExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Rec_Arg_Traits::AMH_baseExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<Rec_Arg_Traits::AMH_baseExceptionHolder>::extract (
        _tao_any,
        Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_any_destructor,
        Rec_Arg_Traits::_tc_AMH_baseExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::AMH_baseResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::AMH_baseResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::AMH_baseResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMH_baseResponseHandler_ptr _tao_elem)
{
  Rec_Arg_Traits::AMH_baseResponseHandler_ptr _tao_objptr =
    Rec_Arg_Traits::AMH_baseResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMH_baseResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Rec_Arg_Traits::AMH_baseResponseHandler>::insert (
    _tao_any,
    Rec_Arg_Traits::AMH_baseResponseHandler::_tao_any_destructor,
    Rec_Arg_Traits::_tc_AMH_baseResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Rec_Arg_Traits::AMH_baseResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Rec_Arg_Traits::AMH_baseResponseHandler>::extract (
        _tao_any,
        Rec_Arg_Traits::AMH_baseResponseHandler::_tao_any_destructor,
        Rec_Arg_Traits::_tc_AMH_baseResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::AMI_baseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMI_baseHandler_ptr _tao_elem)
{
  Rec_Arg_Traits::AMI_baseHandler_ptr _tao_objptr =
    Rec_Arg_Traits::AMI_baseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMI_baseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Rec_Arg_Traits::AMI_baseHandler>::insert (
    _tao_any,
    Rec_Arg_Traits::AMI_baseHandler::_tao_any_destructor,
    Rec_Arg_Traits::_tc_AMI_baseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Rec_Arg_Traits::AMI_baseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Rec_Arg_Traits::AMI_baseHandler>::extract (
        _tao_any,
        Rec_Arg_Traits::AMI_baseHandler::_tao_any_destructor,
        Rec_Arg_Traits::_tc_AMI_baseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::derived>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::derived_ptr _tao_elem)
{
  Rec_Arg_Traits::derived_ptr _tao_objptr =
    Rec_Arg_Traits::derived::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::derived_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Rec_Arg_Traits::derived>::insert (
    _tao_any,
    Rec_Arg_Traits::derived::_tao_any_destructor,
    Rec_Arg_Traits::_tc_derived,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Rec_Arg_Traits::derived_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Rec_Arg_Traits::derived>::extract (
        _tao_any,
        Rec_Arg_Traits::derived::_tao_any_destructor,
        Rec_Arg_Traits::_tc_derived,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::AMH_derivedExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMH_derivedExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Rec_Arg_Traits::AMH_derivedExceptionHolder *_tao_copy =
      _tao_elem ?
        Rec_Arg_Traits::AMH_derivedExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMH_derivedExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<Rec_Arg_Traits::AMH_derivedExceptionHolder>::insert (
    _tao_any,
    Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_any_destructor,
    Rec_Arg_Traits::_tc_AMH_derivedExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Rec_Arg_Traits::AMH_derivedExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<Rec_Arg_Traits::AMH_derivedExceptionHolder>::extract (
        _tao_any,
        Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_any_destructor,
        Rec_Arg_Traits::_tc_AMH_derivedExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::AMH_derivedResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::AMH_derivedResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::AMH_derivedResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMH_derivedResponseHandler_ptr _tao_elem)
{
  Rec_Arg_Traits::AMH_derivedResponseHandler_ptr _tao_objptr =
    Rec_Arg_Traits::AMH_derivedResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMH_derivedResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Rec_Arg_Traits::AMH_derivedResponseHandler>::insert (
    _tao_any,
    Rec_Arg_Traits::AMH_derivedResponseHandler::_tao_any_destructor,
    Rec_Arg_Traits::_tc_AMH_derivedResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Rec_Arg_Traits::AMH_derivedResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Rec_Arg_Traits::AMH_derivedResponseHandler>::extract (
        _tao_any,
        Rec_Arg_Traits::AMH_derivedResponseHandler::_tao_any_destructor,
        Rec_Arg_Traits::_tc_AMH_derivedResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Rec_Arg_Traits::AMI_derivedHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMI_derivedHandler_ptr _tao_elem)
{
  Rec_Arg_Traits::AMI_derivedHandler_ptr _tao_objptr =
    Rec_Arg_Traits::AMI_derivedHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Rec_Arg_Traits::AMI_derivedHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Rec_Arg_Traits::AMI_derivedHandler>::insert (
    _tao_any,
    Rec_Arg_Traits::AMI_derivedHandler::_tao_any_destructor,
    Rec_Arg_Traits::_tc_AMI_derivedHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Rec_Arg_Traits::AMI_derivedHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Rec_Arg_Traits::AMI_derivedHandler>::extract (
        _tao_any,
        Rec_Arg_Traits::AMI_derivedHandler::_tao_any_destructor,
        Rec_Arg_Traits::_tc_AMI_derivedHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_test::iTest>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_test::iTest_ptr _tao_elem)
{
  call_test::iTest_ptr _tao_objptr =
    call_test::iTest::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_test::iTest_ptr *_tao_elem)
{
  TAO::Any_Impl_T<call_test::iTest>::insert (
    _tao_any,
    call_test::iTest::_tao_any_destructor,
    call_test::_tc_iTest,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    call_test::iTest_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<call_test::iTest>::extract (
        _tao_any,
        call_test::iTest::_tao_any_destructor,
        call_test::_tc_iTest,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_test::AMH_iTestExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_test::AMH_iTestExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    call_test::AMH_iTestExceptionHolder *_tao_copy =
      _tao_elem ?
        call_test::AMH_iTestExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_test::AMH_iTestExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<call_test::AMH_iTestExceptionHolder>::insert (
    _tao_any,
    call_test::AMH_iTestExceptionHolder::_tao_any_destructor,
    call_test::_tc_AMH_iTestExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    call_test::AMH_iTestExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<call_test::AMH_iTestExceptionHolder>::extract (
        _tao_any,
        call_test::AMH_iTestExceptionHolder::_tao_any_destructor,
        call_test::_tc_AMH_iTestExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_test::AMH_iTestResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_test::AMH_iTestResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_test::AMH_iTestResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_test::AMH_iTestResponseHandler_ptr _tao_elem)
{
  call_test::AMH_iTestResponseHandler_ptr _tao_objptr =
    call_test::AMH_iTestResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_test::AMH_iTestResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<call_test::AMH_iTestResponseHandler>::insert (
    _tao_any,
    call_test::AMH_iTestResponseHandler::_tao_any_destructor,
    call_test::_tc_AMH_iTestResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    call_test::AMH_iTestResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<call_test::AMH_iTestResponseHandler>::extract (
        _tao_any,
        call_test::AMH_iTestResponseHandler::_tao_any_destructor,
        call_test::_tc_AMH_iTestResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_test::AMI_iTestHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_test::AMI_iTestHandler_ptr _tao_elem)
{
  call_test::AMI_iTestHandler_ptr _tao_objptr =
    call_test::AMI_iTestHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_test::AMI_iTestHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<call_test::AMI_iTestHandler>::insert (
    _tao_any,
    call_test::AMI_iTestHandler::_tao_any_destructor,
    call_test::_tc_AMI_iTestHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    call_test::AMI_iTestHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<call_test::AMI_iTestHandler>::extract (
        _tao_any,
        call_test::AMI_iTestHandler::_tao_any_destructor,
        call_test::_tc_AMI_iTestHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_attribute::iBar>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_attribute::iBar_ptr _tao_elem)
{
  call_attribute::iBar_ptr _tao_objptr =
    call_attribute::iBar::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_attribute::iBar_ptr *_tao_elem)
{
  TAO::Any_Impl_T<call_attribute::iBar>::insert (
    _tao_any,
    call_attribute::iBar::_tao_any_destructor,
    call_attribute::_tc_iBar,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    call_attribute::iBar_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<call_attribute::iBar>::extract (
        _tao_any,
        call_attribute::iBar::_tao_any_destructor,
        call_attribute::_tc_iBar,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_attribute::AMH_iBarExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_attribute::AMH_iBarExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    call_attribute::AMH_iBarExceptionHolder *_tao_copy =
      _tao_elem ?
        call_attribute::AMH_iBarExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_attribute::AMH_iBarExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<call_attribute::AMH_iBarExceptionHolder>::insert (
    _tao_any,
    call_attribute::AMH_iBarExceptionHolder::_tao_any_destructor,
    call_attribute::_tc_AMH_iBarExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    call_attribute::AMH_iBarExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<call_attribute::AMH_iBarExceptionHolder>::extract (
        _tao_any,
        call_attribute::AMH_iBarExceptionHolder::_tao_any_destructor,
        call_attribute::_tc_AMH_iBarExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_attribute::AMH_iBarResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_attribute::AMH_iBarResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_attribute::AMH_iBarResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_attribute::AMH_iBarResponseHandler_ptr _tao_elem)
{
  call_attribute::AMH_iBarResponseHandler_ptr _tao_objptr =
    call_attribute::AMH_iBarResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_attribute::AMH_iBarResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<call_attribute::AMH_iBarResponseHandler>::insert (
    _tao_any,
    call_attribute::AMH_iBarResponseHandler::_tao_any_destructor,
    call_attribute::_tc_AMH_iBarResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    call_attribute::AMH_iBarResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<call_attribute::AMH_iBarResponseHandler>::extract (
        _tao_any,
        call_attribute::AMH_iBarResponseHandler::_tao_any_destructor,
        call_attribute::_tc_AMH_iBarResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<call_attribute::AMI_iBarHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_attribute::AMI_iBarHandler_ptr _tao_elem)
{
  call_attribute::AMI_iBarHandler_ptr _tao_objptr =
    call_attribute::AMI_iBarHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  call_attribute::AMI_iBarHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<call_attribute::AMI_iBarHandler>::insert (
    _tao_any,
    call_attribute::AMI_iBarHandler::_tao_any_destructor,
    call_attribute::_tc_AMI_iBarHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    call_attribute::AMI_iBarHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<call_attribute::AMI_iBarHandler>::extract (
        _tao_any,
        call_attribute::AMI_iBarHandler::_tao_any_destructor,
        call_attribute::_tc_AMI_iBarHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Base_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Base_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Base>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_BaseExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_BaseExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_BaseExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_BaseExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_BaseExceptionHolder *&_tao_valuetype)
{
  return AMH_BaseExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_BaseExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_BaseExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_BaseExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_BaseHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_BaseHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_BaseHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Derived_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Derived_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Derived>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_DerivedExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_DerivedExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_DerivedExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_DerivedExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_DerivedExceptionHolder *&_tao_valuetype)
{
  return AMH_DerivedExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_DerivedExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_DerivedExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_DerivedExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_DerivedHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_DerivedHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_DerivedHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const foo_mod::date &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.month) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    foo_mod::date &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.month) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const foostep_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    foostep_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::foostep>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_foostepExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_foostepExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_foostepExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_foostepExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_foostepExceptionHolder *&_tao_valuetype)
{
  return AMH_foostepExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_foostepExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_foostepExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_foostepExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_foostepHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_foostepHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_foostepHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const mother::member &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.val) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    mother::member &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.val) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const mother_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    mother_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::mother>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_motherExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_motherExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_motherExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_motherExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_motherExceptionHolder *&_tao_valuetype)
{
  return AMH_motherExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_motherExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_motherExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_motherExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_motherHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_motherHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_motherHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const father::member &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.ident) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    father::member &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.ident) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const father_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    father_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::father>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_fatherExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_fatherExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_fatherExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_fatherExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_fatherExceptionHolder *&_tao_valuetype)
{
  return AMH_fatherExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_fatherExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_fatherExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_fatherExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_fatherHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_fatherHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_fatherHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const child_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    child_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::child>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_childExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_childExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_childExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_childExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_childExceptionHolder *&_tao_valuetype)
{
  return AMH_childExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_childExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_childExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_childExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_childHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_childHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_childHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const _cxx_try_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    _cxx_try_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::_cxx_try>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH__cxx_tryExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH__cxx_tryExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH__cxx_tryExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH__cxx_tryExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH__cxx_tryExceptionHolder *&_tao_valuetype)
{
  return AMH__cxx_tryExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH__cxx_tryExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH__cxx_tryExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH__cxx_tryExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI__cxx_tryHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI__cxx_tryHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI__cxx_tryHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const later_user_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    later_user_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::later_user>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_later_userExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_later_userExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_later_userExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_later_userExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_later_userExceptionHolder *&_tao_valuetype)
{
  return AMH_later_userExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_later_userExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_later_userExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_later_userExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_later_userHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_later_userHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_later_userHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const later_holder &_tao_aggregate)
{
  return
    ::CORBA::Object::marshal (
        _tao_aggregate.member.in (),
        strm
      ) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    later_holder &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.member.out ()) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const later_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    later_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::later>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_laterExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_laterExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_laterExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_laterExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_laterExceptionHolder *&_tao_valuetype)
{
  return AMH_laterExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_laterExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_laterExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_laterExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_laterHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_laterHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_laterHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Begin_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Begin_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Begin>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_BeginExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_BeginExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_BeginExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_BeginExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_BeginExceptionHolder *&_tao_valuetype)
{
  return AMH_BeginExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_BeginExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_BeginExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_BeginExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_BeginHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_BeginHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_BeginHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Middle_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Middle_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Middle>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_MiddleExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_MiddleExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_MiddleExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_MiddleExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_MiddleExceptionHolder *&_tao_valuetype)
{
  return AMH_MiddleExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_MiddleExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_MiddleExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_MiddleExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_MiddleHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_MiddleHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_MiddleHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const End_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    End_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::End>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_EndExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_EndExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_EndExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_EndExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_EndExceptionHolder *&_tao_valuetype)
{
  return AMH_EndExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_EndExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_EndExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_EndExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_EndHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_EndHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_EndHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Client_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Client_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Client>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_ClientExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_ClientExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_ClientExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_ClientExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_ClientExceptionHolder *&_tao_valuetype)
{
  return AMH_ClientExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_ClientExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_ClientExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_ClientExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_ClientHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_ClientHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_ClientHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_array/cdr_op_cs.cpp:162


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AttributeTester::string_1_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for (::CORBA::ULong i0 = 0; i0 < 1 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0].in ());
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AttributeTester::string_1_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for (::CORBA::ULong i0 = 0; i0 < 1 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0].out ());
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AttributeTester_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AttributeTester_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AttributeTester>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_AttributeTesterExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_AttributeTesterExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_AttributeTesterExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_AttributeTesterExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_AttributeTesterExceptionHolder *&_tao_valuetype)
{
  return AMH_AttributeTesterExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_AttributeTesterExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_AttributeTesterExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_AttributeTesterExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_AttributeTesterHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_AttributeTesterHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_AttributeTesterHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ParamMod::ParameterTester::object_excep_type &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        ::CORBA::Object::marshal (
            _tao_aggregate.objref.in (),
            strm
          )
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ParamMod::ParameterTester::object_excep_type &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.objref.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/cdr_op_cs.cpp:92

#if !defined _TAO_CDR_OP_ParamMod_ParameterTester_object_seq_type_CPP_
#define _TAO_CDR_OP_ParamMod_ParameterTester_object_seq_type_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ParamMod::ParameterTester::object_seq_type &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ParamMod::ParameterTester::object_seq_type &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_ParamMod_ParameterTester_object_seq_type_CPP_ */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_array/cdr_op_cs.cpp:162


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ParamMod::ParameterTester::object_array_type_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for (::CORBA::ULong i0 = 0; i0 < 5 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = 
        TAO::Objref_Traits<ParamMod::ParameterTester>::marshal (_tao_array[i0].in (), strm);
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ParamMod::ParameterTester::object_array_type_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for (::CORBA::ULong i0 = 0; i0 < 5 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ParamMod::ParameterTester::object_struct_type &_tao_aggregate)
{
  return
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.o1)) &&
    ::CORBA::Object::marshal (
        _tao_aggregate.p1.in (),
        strm
      ) &&
    (strm << _tao_aggregate.l1) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ParamMod::ParameterTester::object_struct_type &_tao_aggregate)
{
  return
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.o1)) &&
    (strm >> _tao_aggregate.p1.out ()) &&
    (strm >> _tao_aggregate.l1) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/cdr_op_cs.cpp:119


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ParamMod::ParameterTester::object_union_type &_tao_union)
{
  if (!(strm << _tao_union._d ()))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.str ();
      }
      break;
    case 1:
      {
        result =
          TAO::Objref_Traits<ParamMod::ParameterTester>::marshal (
              _tao_union.pt (),
              strm
            );
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ParamMod::ParameterTester::object_union_type &_tao_union)
{
  CORBA::Long _tao_discriminant;
  if (!(strm >> _tao_discriminant))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 0:
      {
        ::CORBA::String_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.out ();
        if (result)
          {
            _tao_union.str (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        ParamMod::ParameterTester_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.inout ();
        if (result)
          {
            _tao_union.pt (_tao_union_tmp.in ());
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ParamMod::ParameterTester_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ParamMod::ParameterTester_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::ParamMod::ParameterTester>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (ParamMod::AMH_ParameterTesterExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (ParamMod::AMH_ParameterTesterExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const ParamMod::AMH_ParameterTesterExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&ParamMod::AMH_ParameterTesterExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    ParamMod::AMH_ParameterTesterExceptionHolder *&_tao_valuetype)
{
  return ParamMod::AMH_ParameterTesterExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_ParamMod::AMH_ParameterTesterExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_ParamMod::AMH_ParameterTesterExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_ParamMod::AMH_ParameterTesterExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ParamMod::AMI_ParameterTesterHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ParamMod::AMI_ParameterTesterHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::ParamMod::AMI_ParameterTesterHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/cdr_op_cs.cpp:119


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const A::U &_tao_union)
{
  ::ACE_OutputCDR::from_boolean tmp (_tao_union._d ());
  if (!(strm << tmp))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  if (_tao_union._d ())
    {
      result =
        TAO::Objref_Traits<A>::marshal (
            _tao_union.aa (),
            strm
          );
    }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    A::U &_tao_union)
{
  CORBA::Boolean _tao_discriminant;
  ::ACE_InputCDR::to_boolean tmp (_tao_discriminant);
  if (!(strm >> tmp))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  _tao_union._default ();
  _tao_union._d (_tao_discriminant);
  if (_tao_discriminant)
    {
      A_var _tao_union_tmp;
      result = strm >> _tao_union_tmp.inout ();
      if (result)
        {
          _tao_union.aa (_tao_union_tmp.in ());
          _tao_union._d (_tao_discriminant);
        }
    }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const A_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    A_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::A>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_AExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_AExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_AExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_AExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_AExceptionHolder *&_tao_valuetype)
{
  return AMH_AExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_AExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_AExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_AExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_AHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_AHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_AHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M::A_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M::A_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::M::A>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (M::AMH_AExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (M::AMH_AExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const M::AMH_AExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&M::AMH_AExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    M::AMH_AExceptionHolder *&_tao_valuetype)
{
  return M::AMH_AExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_M::AMH_AExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_M::AMH_AExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_M::AMH_AExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const M::AMI_AHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    M::AMI_AHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::M::AMI_AHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const i1::if1_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    i1::if1_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::i1::if1>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (i1::AMH_if1ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (i1::AMH_if1ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const i1::AMH_if1ExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&i1::AMH_if1ExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    i1::AMH_if1ExceptionHolder *&_tao_valuetype)
{
  return i1::AMH_if1ExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_i1::AMH_if1ExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_i1::AMH_if1ExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_i1::AMH_if1ExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const i1::AMI_if1Handler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    i1::AMI_if1Handler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::i1::AMI_if1Handler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const i2::if2_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    i2::if2_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::i2::if2>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (i2::AMH_if2ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (i2::AMH_if2ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const i2::AMH_if2ExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&i2::AMH_if2ExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    i2::AMH_if2ExceptionHolder *&_tao_valuetype)
{
  return i2::AMH_if2ExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_i2::AMH_if2ExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_i2::AMH_if2ExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_i2::AMH_if2ExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const i2::AMI_if2Handler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    i2::AMI_if2Handler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::i2::AMI_if2Handler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const i2::if3_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    i2::if3_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::i2::if3>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (i2::AMH_if3ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (i2::AMH_if3ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const i2::AMH_if3ExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&i2::AMH_if3ExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    i2::AMH_if3ExceptionHolder *&_tao_valuetype)
{
  return i2::AMH_if3ExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_i2::AMH_if3ExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_i2::AMH_if3ExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_i2::AMH_if3ExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const i2::AMI_if3Handler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    i2::AMI_if3Handler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::i2::AMI_if3Handler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const redefs::base::ex &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.info.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    redefs::base::ex &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.info.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const redefs::base::foo &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.index) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    redefs::base::foo &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.index) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const redefs::base_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    redefs::base_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::redefs::base>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (redefs::AMH_baseExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (redefs::AMH_baseExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const redefs::AMH_baseExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&redefs::AMH_baseExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    redefs::AMH_baseExceptionHolder *&_tao_valuetype)
{
  return redefs::AMH_baseExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_redefs::AMH_baseExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_redefs::AMH_baseExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_redefs::AMH_baseExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const redefs::AMI_baseHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    redefs::AMI_baseHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::redefs::AMI_baseHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const redefs::derived::ex &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.serial)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    redefs::derived::ex &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.serial)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const redefs::derived::foo &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.str.in ()) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    redefs::derived::foo &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.str.out ()) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const redefs::derived_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    redefs::derived_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::redefs::derived>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (redefs::AMH_derivedExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (redefs::AMH_derivedExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const redefs::AMH_derivedExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&redefs::AMH_derivedExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    redefs::AMH_derivedExceptionHolder *&_tao_valuetype)
{
  return redefs::AMH_derivedExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_redefs::AMH_derivedExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_redefs::AMH_derivedExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_redefs::AMH_derivedExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const redefs::AMI_derivedHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    redefs::AMI_derivedHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::redefs::AMI_derivedHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Rec_Arg_Traits::base_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Rec_Arg_Traits::base_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Rec_Arg_Traits::base>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (Rec_Arg_Traits::AMH_baseExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Rec_Arg_Traits::AMH_baseExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Rec_Arg_Traits::AMH_baseExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Rec_Arg_Traits::AMH_baseExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Rec_Arg_Traits::AMH_baseExceptionHolder *&_tao_valuetype)
{
  return Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_Rec_Arg_Traits::AMH_baseExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_Rec_Arg_Traits::AMH_baseExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Rec_Arg_Traits::AMI_baseHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Rec_Arg_Traits::AMI_baseHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Rec_Arg_Traits::AMI_baseHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Rec_Arg_Traits::derived_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Rec_Arg_Traits::derived_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Rec_Arg_Traits::derived>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (Rec_Arg_Traits::AMH_derivedExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Rec_Arg_Traits::AMH_derivedExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Rec_Arg_Traits::AMH_derivedExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Rec_Arg_Traits::AMH_derivedExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Rec_Arg_Traits::AMH_derivedExceptionHolder *&_tao_valuetype)
{
  return Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_Rec_Arg_Traits::AMH_derivedExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_Rec_Arg_Traits::AMH_derivedExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Rec_Arg_Traits::AMI_derivedHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Rec_Arg_Traits::AMI_derivedHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Rec_Arg_Traits::AMI_derivedHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const call_test::iTest_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    call_test::iTest_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::call_test::iTest>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (call_test::AMH_iTestExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (call_test::AMH_iTestExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const call_test::AMH_iTestExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&call_test::AMH_iTestExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    call_test::AMH_iTestExceptionHolder *&_tao_valuetype)
{
  return call_test::AMH_iTestExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_call_test::AMH_iTestExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_call_test::AMH_iTestExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_call_test::AMH_iTestExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const call_test::AMI_iTestHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    call_test::AMI_iTestHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::call_test::AMI_iTestHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const call_attribute::iBar_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    call_attribute::iBar_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::call_attribute::iBar>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (call_attribute::AMH_iBarExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (call_attribute::AMH_iBarExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const call_attribute::AMH_iBarExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&call_attribute::AMH_iBarExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    call_attribute::AMH_iBarExceptionHolder *&_tao_valuetype)
{
  return call_attribute::AMH_iBarExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_call_attribute::AMH_iBarExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_call_attribute::AMH_iBarExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_call_attribute::AMH_iBarExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const call_attribute::AMI_iBarHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    call_attribute::AMI_iBarHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::call_attribute::AMI_iBarHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



