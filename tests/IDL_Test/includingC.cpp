// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v4.0.2
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       https://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     https://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_codegen.cpp:372


#include "includingC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Messaging/Asynch_Invocation_Adapter.h"
#include "tao/Messaging/ExceptionHolder_i.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "cstring"
#include "memory"

#if !defined (__ACE_INLINE__)
#include "includingC.inl"
#endif /* !defined INLINE */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/enum_typecode.cpp:27

static char const * const _tao_enumerators_choice[] =
  {
    "dog"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_choice (
    "IDL:choice:1.0",
    "choice",
    _tao_enumerators_choice,
    1);
  
::CORBA::TypeCode_ptr const _tc_choice =
  &_tao_tc_choice;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/union_cs.cpp:75



myUnion::myUnion ()
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = (choice) -1;
}

myUnion::myUnion (const ::myUnion &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case ::dog:
    {
      if (!u.u_.cat_)
        {
          this->u_.cat_ = nullptr;
        }
      else
        {
          ACE_NEW (
              this->u_.cat_,
              Aok::Seq1Type (*u.u_.cat_)
            );
        }
    }
    break;
    default:
    break;
  }
}

myUnion::~myUnion ()
{
  // Finalize.
  this->_reset ();
}

void myUnion::_tao_any_destructor (void *_tao_void_pointer)
{
  myUnion *tmp =
    static_cast<myUnion *> (_tao_void_pointer);
  delete tmp;
}

myUnion &
myUnion::operator= (const ::myUnion &u)
{
  if (std::addressof(u) == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case ::dog:
    {
      if (!u.u_.cat_)
        {
          this->u_.cat_ = nullptr;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.cat_,
              Aok::Seq1Type (*u.u_.cat_),
              *this);
        }
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void myUnion::_reset ()
{
  switch (this->disc_)
  {
    
    case ::dog:
      delete this->u_.cat_;
      this->u_.cat_ = nullptr;
      
    break;
    
    default:
    break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/union_typecode.cpp:63


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:457

static TAO::TypeCode::Case_T<choice, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_myUnion__0 (::dog, "cat", &Aok::_tc_Seq1Type);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_myUnion[] =
  {
    &_tao_cases_myUnion__0
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_myUnion (
    "IDL:myUnion:1.0",
    "myUnion",
    &_tc_choice,
    _tao_cases_myUnion,
    sizeof (_tao_cases_myUnion)/sizeof (_tao_cases_myUnion[0]),
    -1);
  
::CORBA::TypeCode_ptr const _tc_myUnion =
  &_tao_tc_myUnion;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/union_cs.cpp:75



Bog::Bog ()
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = (Agog) -1;
}

Bog::Bog (const ::Bog &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case ::Agog1:
    {
      this->u_.bog1_ = u.u_.bog1_;
    }
    break;
    case ::Agog2:
    {
      this->u_.bog2_ = u.u_.bog2_;
    }
    break;
    case ::Agog3:
    {
      this->u_.bog3_ = u.u_.bog3_;
    }
    break;
    default:
    break;
  }
}

Bog::~Bog ()
{
  // Finalize.
  this->_reset ();
}

void Bog::_tao_any_destructor (void *_tao_void_pointer)
{
  Bog *tmp =
    static_cast<Bog *> (_tao_void_pointer);
  delete tmp;
}

Bog &
Bog::operator= (const ::Bog &u)
{
  if (std::addressof(u) == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case ::Agog1:
    {
      this->u_.bog1_ = u.u_.bog1_;
    }
    break;
    case ::Agog2:
    {
      this->u_.bog2_ = u.u_.bog2_;
    }
    break;
    case ::Agog3:
    {
      this->u_.bog3_ = u.u_.bog3_;
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void Bog::_reset ()
{
  switch (this->disc_)
  {
    
    case ::Agog1:
      
    break;
    
    case ::Agog2:
      
    break;
    
    case ::Agog3:
      
    break;
    
    default:
    break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/union_typecode.cpp:63

static TAO::TypeCode::Case_T<Agog, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Bog__0 (::Agog1, "bog1", &CORBA::_tc_long);
static TAO::TypeCode::Case_T<Agog, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Bog__1 (::Agog2, "bog2", &CORBA::_tc_long);
static TAO::TypeCode::Case_T<Agog, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Bog__2 (::Agog3, "bog3", &CORBA::_tc_long);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Bog[] =
  {
    &_tao_cases_Bog__0,
    &_tao_cases_Bog__1,
    &_tao_cases_Bog__2
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Bog (
    "IDL:Bog:1.0",
    "Bog",
    &_tc_Agog,
    _tao_cases_Bog,
    sizeof (_tao_cases_Bog)/sizeof (_tao_cases_Bog[0]),
    -1);
  
::CORBA::TypeCode_ptr const _tc_Bog =
  &_tao_tc_Bog;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for iface.

iface_ptr
TAO::Objref_Traits<iface>::duplicate (iface_ptr p)
{
  return iface::_duplicate (p);
}

void
TAO::Objref_Traits<iface>::release (iface_ptr p)
{
  ::CORBA::release (p);
}

iface_ptr
TAO::Objref_Traits<iface>::nil ()
{
  return iface::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<iface>::marshal (const iface_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/enum_typecode.cpp:27

static char const * const _tao_enumerators_iface_postal[] =
  {
    "ME",
    "TAO_FE"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_iface_postal (
    "IDL:iface/postal:1.0",
    "postal",
    _tao_enumerators_iface_postal,
    2);
  
::CORBA::TypeCode_ptr const iface::_tc_postal =
  &_tao_tc_iface_postal;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_iface_using_incl[] =
      {
        { "field1", &Aok::_tc_Me }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_iface_using_incl (
  ::CORBA::tk_struct,
  "IDL:iface/using_incl:1.0",
  "using_incl",
  _tao_fields_iface_using_incl,
  1);

::CORBA::TypeCode_ptr const iface::_tc_using_incl =
  &_tao_tc_iface_using_incl;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
iface::using_incl::_tao_any_destructor (
    void *_tao_void_pointer)
{
  using_incl *_tao_tmp_pointer =
    static_cast<using_incl *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

iface::iface ()
{
}
void
iface::_tao_any_destructor (void *_tao_void_pointer)
{
  iface *_tao_tmp_pointer =
    static_cast<iface *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

iface_ptr
iface::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<iface>::narrow (_tao_objref, "IDL:iface:1.0");
}

iface_ptr
iface::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<iface>::unchecked_narrow (_tao_objref);
}

iface_ptr
iface::_nil ()
{
  return nullptr;
}

iface_ptr
iface::_duplicate (iface_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
iface::_tao_release (iface_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
iface::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:iface:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* iface::_interface_repository_id () const
{
  return "IDL:iface:1.0";
}

const char* iface::_desc_repository_id ()
{
  return "IDL:iface:1.0";
}

const char* iface::_desc_interface_name ()
{
  return "iface";
}

::CORBA::Boolean
iface::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_iface (
    ::CORBA::tk_objref,
    "IDL:iface:1.0",
    "iface");
  
::CORBA::TypeCode_ptr const _tc_iface =
  &_tao_tc_iface;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_ifaceExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_ifaceExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_ifaceExceptionHolder:1.0",
    "AMH_ifaceExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_ifaceExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_ifaceExceptionHolder =
  &_tao_tc_AMH_ifaceExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_ifaceExceptionHolder>::add_ref (AMH_ifaceExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_ifaceExceptionHolder>::remove_ref (AMH_ifaceExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_ifaceExceptionHolder>::release (AMH_ifaceExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_ifaceExceptionHolder *
AMH_ifaceExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_ifaceExceptionHolder *> (v);
}

const char *
AMH_ifaceExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_ifaceExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_ifaceExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_ifaceExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_ifaceExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_ifaceExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_ifaceExceptionHolder;
}

AMH_ifaceExceptionHolder::~AMH_ifaceExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_ifaceExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_ifaceExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_ifaceExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_ifaceExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_ifaceExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_ifaceExceptionHolder::_tao_marshal__AMH_ifaceExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_ifaceExceptionHolder::_tao_unmarshal__AMH_ifaceExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_ifaceExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_ifaceExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_ifaceExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_ifaceExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_ifaceExceptionHolder_init::AMH_ifaceExceptionHolder_init ()
{
}

AMH_ifaceExceptionHolder_init::~AMH_ifaceExceptionHolder_init ()
{
}

AMH_ifaceExceptionHolder_init *
AMH_ifaceExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_ifaceExceptionHolder_init *> (v);
}

const char*
AMH_ifaceExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_ifaceExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_ifaceExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_ifaceExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_ifaceResponseHandler.

AMH_ifaceResponseHandler_ptr
TAO::Objref_Traits<AMH_ifaceResponseHandler>::duplicate (AMH_ifaceResponseHandler_ptr p)
{
  return AMH_ifaceResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_ifaceResponseHandler>::release (AMH_ifaceResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_ifaceResponseHandler_ptr
TAO::Objref_Traits<AMH_ifaceResponseHandler>::nil ()
{
  return AMH_ifaceResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_ifaceResponseHandler>::marshal (const AMH_ifaceResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_ifaceResponseHandler::AMH_ifaceResponseHandler ()
{}void
AMH_ifaceResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_ifaceResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_ifaceResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_ifaceResponseHandler_ptr
AMH_ifaceResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_ifaceResponseHandler::_duplicate (
      dynamic_cast<AMH_ifaceResponseHandler_ptr> (_tao_objref));
}

AMH_ifaceResponseHandler_ptr
AMH_ifaceResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_ifaceResponseHandler::_duplicate (
      dynamic_cast<AMH_ifaceResponseHandler_ptr> (_tao_objref));
}

AMH_ifaceResponseHandler_ptr
AMH_ifaceResponseHandler::_nil ()
{
  return nullptr;
}

AMH_ifaceResponseHandler_ptr
AMH_ifaceResponseHandler::_duplicate (AMH_ifaceResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_ifaceResponseHandler::_tao_release (AMH_ifaceResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_ifaceResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_ifaceResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_ifaceResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_ifaceResponseHandler:1.0";
}

const char* AMH_ifaceResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_ifaceResponseHandler:1.0";
}

const char* AMH_ifaceResponseHandler::_desc_interface_name ()
{
  return "AMH_ifaceResponseHandler";
}

::CORBA::Boolean
AMH_ifaceResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_ifaceResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_ifaceResponseHandler:1.0",
    "AMH_ifaceResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_ifaceResponseHandler =
  &_tao_tc_AMH_ifaceResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_ifaceHandler.

AMI_ifaceHandler_ptr
TAO::Objref_Traits<AMI_ifaceHandler>::duplicate (AMI_ifaceHandler_ptr p)
{
  return AMI_ifaceHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_ifaceHandler>::release (AMI_ifaceHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_ifaceHandler_ptr
TAO::Objref_Traits<AMI_ifaceHandler>::nil ()
{
  return AMI_ifaceHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_ifaceHandler>::marshal (const AMI_ifaceHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_ifaceHandler::AMI_ifaceHandler ()
{
}
void
AMI_ifaceHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_ifaceHandler *_tao_tmp_pointer =
    static_cast<AMI_ifaceHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_ifaceHandler_ptr
AMI_ifaceHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_ifaceHandler>::narrow (_tao_objref, "IDL:AMI_ifaceHandler:1.0");
}

AMI_ifaceHandler_ptr
AMI_ifaceHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_ifaceHandler>::unchecked_narrow (_tao_objref);
}

AMI_ifaceHandler_ptr
AMI_ifaceHandler::_nil ()
{
  return nullptr;
}

AMI_ifaceHandler_ptr
AMI_ifaceHandler::_duplicate (AMI_ifaceHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_ifaceHandler::_tao_release (AMI_ifaceHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_ifaceHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_ifaceHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_ifaceHandler::_interface_repository_id () const
{
  return "IDL:AMI_ifaceHandler:1.0";
}

const char* AMI_ifaceHandler::_desc_repository_id ()
{
  return "IDL:AMI_ifaceHandler:1.0";
}

const char* AMI_ifaceHandler::_desc_interface_name ()
{
  return "AMI_ifaceHandler";
}

::CORBA::Boolean
AMI_ifaceHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_ifaceHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_ifaceHandler:1.0",
    "AMI_ifaceHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_ifaceHandler =
  &_tao_tc_AMI_ifaceHandler;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/sequence_cs.cpp:104



#if !defined (_VT_TEST_VTSEQ_CS_)
#define _VT_TEST_VTSEQ_CS_

VT_Test::VTSeq::VTSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_valuetype_sequence<
        VT_Def::VT,
        VT_Def::VT_var
      > (max)
{}

VT_Test::VTSeq::VTSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    VT_Def::VT * * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_valuetype_sequence<
        VT_Def::VT,
        VT_Def::VT_var
      >
    (max, length, buffer, release)
{}

void VT_Test::VTSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  VTSeq * _tao_tmp_pointer =
    static_cast<VTSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:457


#ifndef _TAO_TYPECODE_VT_Test_VTSeq_GUARD
#define _TAO_TYPECODE_VT_Test_VTSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        VT_Test_VTSeq_0 (
          ::CORBA::tk_sequence,
          &VT_Def::_tc_VT,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_VT_Test_VTSeq_0 =
        &VT_Test_VTSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_VT_Test_VTSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_VT_Test_VTSeq (
    ::CORBA::tk_alias,
    "IDL:VT_Test/VTSeq:1.0",
    "VTSeq",
    &TAO::TypeCode::tc_VT_Test_VTSeq_0);
  

namespace VT_Test
{
  ::CORBA::TypeCode_ptr const _tc_VTSeq =
    &_tao_tc_VT_Test_VTSeq;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_ctor.cpp:50



MyException::MyException (
    const A::MyStructA & _tao_exField)
  : ::CORBA::UserException (
        "IDL:MyException:1.0",
        "MyException")
{
  this->exField = _tao_exField;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

MyException::MyException ()
  : ::CORBA::UserException (
        "IDL:MyException:1.0",
        "MyException")
{
}

MyException::MyException (const ::MyException &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
  this->exField = _tao_excp.exField;
}

MyException&
MyException::operator= (const ::MyException &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->exField = _tao_excp.exField;
  return *this;
}

void MyException::_tao_any_destructor (void *_tao_void_pointer)
{
  MyException *_tao_tmp_pointer =
    static_cast<MyException *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

MyException *
MyException::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<MyException *> (_tao_excp);
}

const MyException *
MyException::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const MyException *> (_tao_excp);
}

::CORBA::Exception *MyException::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::MyException, nullptr);
  return retval;
}

::CORBA::Exception *
MyException::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::MyException (*this), nullptr);
  return result;
}

void MyException::_raise () const
{
  throw *this;
}

void MyException::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void MyException::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr MyException::_tao_type () const
{
  return ::_tc_MyException;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_MyException[] =
      {
        { "exField", &A::_tc_MyStructA }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_MyException (
  ::CORBA::tk_except,
  "IDL:MyException:1.0",
  "MyException",
  _tao_fields_MyException,
  1);

::CORBA::TypeCode_ptr const _tc_MyException =
  &_tao_tc_MyException;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_TestStr[] =
      {
        { "field", &A::_tc_MyStructA }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_TestStr (
  ::CORBA::tk_struct,
  "IDL:TestStr:1.0",
  "TestStr",
  _tao_fields_TestStr,
  1);

::CORBA::TypeCode_ptr const _tc_TestStr =
  &_tao_tc_TestStr;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
TestStr::_tao_any_destructor (
    void *_tao_void_pointer)
{
  TestStr *_tao_tmp_pointer =
    static_cast<TestStr *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/union_cs.cpp:75



TestUn::TestUn ()
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -2147483647;
}

TestUn::TestUn (const ::TestUn &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      if (!u.u_.value1_)
        {
          this->u_.value1_ = nullptr;
        }
      else
        {
          ACE_NEW (
              this->u_.value1_,
              A::MyStructA (*u.u_.value1_)
            );
        }
    }
    break;
    case 1:
    {
      this->u_.value2_ = ::CORBA::string_dup (u.u_.value2_);
    }
    break;
    default:
    break;
  }
}

TestUn::~TestUn ()
{
  // Finalize.
  this->_reset ();
}

void TestUn::_tao_any_destructor (void *_tao_void_pointer)
{
  TestUn *tmp =
    static_cast<TestUn *> (_tao_void_pointer);
  delete tmp;
}

TestUn &
TestUn::operator= (const ::TestUn &u)
{
  if (std::addressof(u) == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 0:
    {
      if (!u.u_.value1_)
        {
          this->u_.value1_ = nullptr;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.value1_,
              A::MyStructA (*u.u_.value1_),
              *this);
        }
    }
    break;
    case 1:
    {
      this->u_.value2_ = ::CORBA::string_dup (u.u_.value2_);
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void TestUn::_reset ()
{
  switch (this->disc_)
  {
    
    case 0:
      delete this->u_.value1_;
      this->u_.value1_ = nullptr;
      
    break;
    
    case 1:
      ::CORBA::string_free (this->u_.value2_);
      this->u_.value2_ = nullptr;
      
    break;
    
    default:
    break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/union_typecode.cpp:63

static TAO::TypeCode::Case_T<CORBA::Long, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_TestUn__0 (0, "value1", &A::_tc_MyStructA);
static TAO::TypeCode::Case_T<CORBA::Long, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_TestUn__1 (1, "value2", &CORBA::_tc_string);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_TestUn[] =
  {
    &_tao_cases_TestUn__0,
    &_tao_cases_TestUn__1
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_TestUn (
    "IDL:TestUn:1.0",
    "TestUn",
    &CORBA::_tc_long,
    _tao_cases_TestUn,
    sizeof (_tao_cases_TestUn)/sizeof (_tao_cases_TestUn[0]),
    -1);
  
::CORBA::TypeCode_ptr const _tc_TestUn =
  &_tao_tc_TestUn;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for MyInt.

MyInt_ptr
TAO::Objref_Traits<MyInt>::duplicate (MyInt_ptr p)
{
  return MyInt::_duplicate (p);
}

void
TAO::Objref_Traits<MyInt>::release (MyInt_ptr p)
{
  ::CORBA::release (p);
}

MyInt_ptr
TAO::Objref_Traits<MyInt>::nil ()
{
  return MyInt::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<MyInt>::marshal (const MyInt_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::A::MyStructA *
MyInt::op (
  const ::A::MyStructA & ab)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::A::MyStructA>::ret_val _tao_retval;
  TAO::Arg_Traits< ::A::MyStructA>::in_arg_val _tao_ab (ab);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ab)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
MyInt::sendc_op (
  ::AMI_MyIntHandler_ptr ami_handler,
  const ::A::MyStructA & ab)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::A::MyStructA>::in_arg_val _tao_ab (ab);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ab)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_MyIntHandler::op_reply_stub
    );
}

MyInt::MyInt ()
{
}
void
MyInt::_tao_any_destructor (void *_tao_void_pointer)
{
  MyInt *_tao_tmp_pointer =
    static_cast<MyInt *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

MyInt_ptr
MyInt::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<MyInt>::narrow (_tao_objref, "IDL:MyInt:1.0");
}

MyInt_ptr
MyInt::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<MyInt>::unchecked_narrow (_tao_objref);
}

MyInt_ptr
MyInt::_nil ()
{
  return nullptr;
}

MyInt_ptr
MyInt::_duplicate (MyInt_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
MyInt::_tao_release (MyInt_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
MyInt::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:MyInt:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* MyInt::_interface_repository_id () const
{
  return "IDL:MyInt:1.0";
}

const char* MyInt::_desc_repository_id ()
{
  return "IDL:MyInt:1.0";
}

const char* MyInt::_desc_interface_name ()
{
  return "MyInt";
}

::CORBA::Boolean
MyInt::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_MyInt (
    ::CORBA::tk_objref,
    "IDL:MyInt:1.0",
    "MyInt");
  
::CORBA::TypeCode_ptr const _tc_MyInt =
  &_tao_tc_MyInt;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_MyIntExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_MyIntExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_MyIntExceptionHolder:1.0",
    "AMH_MyIntExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_MyIntExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_MyIntExceptionHolder =
  &_tao_tc_AMH_MyIntExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_MyIntExceptionHolder>::add_ref (AMH_MyIntExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_MyIntExceptionHolder>::remove_ref (AMH_MyIntExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_MyIntExceptionHolder>::release (AMH_MyIntExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_MyIntExceptionHolder *
AMH_MyIntExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_MyIntExceptionHolder *> (v);
}

const char *
AMH_MyIntExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_MyIntExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_MyIntExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_MyIntExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_MyIntExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_MyIntExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_MyIntExceptionHolder;
}

AMH_MyIntExceptionHolder::~AMH_MyIntExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_MyIntExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_MyIntExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_MyIntExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_MyIntExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_MyIntExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_MyIntExceptionHolder::_tao_marshal__AMH_MyIntExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_MyIntExceptionHolder::_tao_unmarshal__AMH_MyIntExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_MyIntExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_MyIntExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_MyIntExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_MyIntExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_MyIntExceptionHolder::raise_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_MyIntExceptionHolder::raise_sendc_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_MyIntResponseHandler.

AMH_MyIntResponseHandler_ptr
TAO::Objref_Traits<AMH_MyIntResponseHandler>::duplicate (AMH_MyIntResponseHandler_ptr p)
{
  return AMH_MyIntResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_MyIntResponseHandler>::release (AMH_MyIntResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_MyIntResponseHandler_ptr
TAO::Objref_Traits<AMH_MyIntResponseHandler>::nil ()
{
  return AMH_MyIntResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_MyIntResponseHandler>::marshal (const AMH_MyIntResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_MyIntResponseHandler::AMH_MyIntResponseHandler ()
{}void
AMH_MyIntResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_MyIntResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_MyIntResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_MyIntResponseHandler_ptr
AMH_MyIntResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_MyIntResponseHandler::_duplicate (
      dynamic_cast<AMH_MyIntResponseHandler_ptr> (_tao_objref));
}

AMH_MyIntResponseHandler_ptr
AMH_MyIntResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_MyIntResponseHandler::_duplicate (
      dynamic_cast<AMH_MyIntResponseHandler_ptr> (_tao_objref));
}

AMH_MyIntResponseHandler_ptr
AMH_MyIntResponseHandler::_nil ()
{
  return nullptr;
}

AMH_MyIntResponseHandler_ptr
AMH_MyIntResponseHandler::_duplicate (AMH_MyIntResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_MyIntResponseHandler::_tao_release (AMH_MyIntResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_MyIntResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_MyIntResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_MyIntResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_MyIntResponseHandler:1.0";
}

const char* AMH_MyIntResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_MyIntResponseHandler:1.0";
}

const char* AMH_MyIntResponseHandler::_desc_interface_name ()
{
  return "AMH_MyIntResponseHandler";
}

::CORBA::Boolean
AMH_MyIntResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_MyIntResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_MyIntResponseHandler:1.0",
    "AMH_MyIntResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_MyIntResponseHandler =
  &_tao_tc_AMH_MyIntResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_MyIntHandler.

AMI_MyIntHandler_ptr
TAO::Objref_Traits<AMI_MyIntHandler>::duplicate (AMI_MyIntHandler_ptr p)
{
  return AMI_MyIntHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_MyIntHandler>::release (AMI_MyIntHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_MyIntHandler_ptr
TAO::Objref_Traits<AMI_MyIntHandler>::nil ()
{
  return AMI_MyIntHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_MyIntHandler>::marshal (const AMI_MyIntHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_MyIntHandler::op (
  const ::A::MyStructA & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::A::MyStructA>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_MyIntHandler::op_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_MyIntHandler_var _tao_reply_handler_object =
    AMI_MyIntHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::A::MyStructA ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->op (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->op_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_MyIntHandler::op_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op_excep",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

AMI_MyIntHandler::AMI_MyIntHandler ()
{
}
void
AMI_MyIntHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_MyIntHandler *_tao_tmp_pointer =
    static_cast<AMI_MyIntHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_MyIntHandler_ptr
AMI_MyIntHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_MyIntHandler>::narrow (_tao_objref, "IDL:AMI_MyIntHandler:1.0");
}

AMI_MyIntHandler_ptr
AMI_MyIntHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_MyIntHandler>::unchecked_narrow (_tao_objref);
}

AMI_MyIntHandler_ptr
AMI_MyIntHandler::_nil ()
{
  return nullptr;
}

AMI_MyIntHandler_ptr
AMI_MyIntHandler::_duplicate (AMI_MyIntHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_MyIntHandler::_tao_release (AMI_MyIntHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_MyIntHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_MyIntHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_MyIntHandler::_interface_repository_id () const
{
  return "IDL:AMI_MyIntHandler:1.0";
}

const char* AMI_MyIntHandler::_desc_repository_id ()
{
  return "IDL:AMI_MyIntHandler:1.0";
}

const char* AMI_MyIntHandler::_desc_interface_name ()
{
  return "AMI_MyIntHandler";
}

::CORBA::Boolean
AMI_MyIntHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_MyIntHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_MyIntHandler:1.0",
    "AMI_MyIntHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_MyIntHandler =
  &_tao_tc_AMI_MyIntHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for RootModule::SUBMODULE1::ChildIF.

RootModule::SUBMODULE1::ChildIF_ptr
TAO::Objref_Traits<RootModule::SUBMODULE1::ChildIF>::duplicate (RootModule::SUBMODULE1::ChildIF_ptr p)
{
  return RootModule::SUBMODULE1::ChildIF::_duplicate (p);
}

void
TAO::Objref_Traits<RootModule::SUBMODULE1::ChildIF>::release (RootModule::SUBMODULE1::ChildIF_ptr p)
{
  ::CORBA::release (p);
}

RootModule::SUBMODULE1::ChildIF_ptr
TAO::Objref_Traits<RootModule::SUBMODULE1::ChildIF>::nil ()
{
  return RootModule::SUBMODULE1::ChildIF::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<RootModule::SUBMODULE1::ChildIF>::marshal (const RootModule::SUBMODULE1::ChildIF_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/enum_typecode.cpp:27

static char const * const _tao_enumerators_RootModule_SUBMODULE1_ChildIF_DifferentMode[] =
  {
    "NORMAL",
    "FAULTY",
    "UNKNOWN"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_RootModule_SUBMODULE1_ChildIF_DifferentMode (
    "IDL:RootModule/SUBMODULE1/ChildIF/DifferentMode:1.0",
    "DifferentMode",
    _tao_enumerators_RootModule_SUBMODULE1_ChildIF_DifferentMode,
    3);
  
::CORBA::TypeCode_ptr const RootModule::SUBMODULE1::ChildIF::_tc_DifferentMode =
  &_tao_tc_RootModule_SUBMODULE1_ChildIF_DifferentMode;

RootModule::SUBMODULE1::ChildIF::ChildIF ()
{
}
void
RootModule::SUBMODULE1::ChildIF::_tao_any_destructor (void *_tao_void_pointer)
{
  ChildIF *_tao_tmp_pointer =
    static_cast<ChildIF *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

RootModule::SUBMODULE1::ChildIF_ptr
RootModule::SUBMODULE1::ChildIF::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<ChildIF>::narrow (_tao_objref, "IDL:RootModule/SUBMODULE1/ChildIF:1.0");
}

RootModule::SUBMODULE1::ChildIF_ptr
RootModule::SUBMODULE1::ChildIF::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<ChildIF>::unchecked_narrow (_tao_objref);
}

RootModule::SUBMODULE1::ChildIF_ptr
RootModule::SUBMODULE1::ChildIF::_nil ()
{
  return nullptr;
}

RootModule::SUBMODULE1::ChildIF_ptr
RootModule::SUBMODULE1::ChildIF::_duplicate (ChildIF_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
RootModule::SUBMODULE1::ChildIF::_tao_release (ChildIF_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
RootModule::SUBMODULE1::ChildIF::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:RootModule/SUBMODULE1/ParentIF:1.0") == 0 ||
      std::strcmp (value, "IDL:RootModule/SUBMODULE1/ChildIF:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* RootModule::SUBMODULE1::ChildIF::_interface_repository_id () const
{
  return "IDL:RootModule/SUBMODULE1/ChildIF:1.0";
}

const char* RootModule::SUBMODULE1::ChildIF::_desc_repository_id ()
{
  return "IDL:RootModule/SUBMODULE1/ChildIF:1.0";
}

const char* RootModule::SUBMODULE1::ChildIF::_desc_interface_name ()
{
  return "ChildIF";
}

::CORBA::Boolean
RootModule::SUBMODULE1::ChildIF::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_RootModule_SUBMODULE1_ChildIF (
    ::CORBA::tk_objref,
    "IDL:RootModule/SUBMODULE1/ChildIF:1.0",
    "ChildIF");
  

namespace RootModule
{
  
  namespace SUBMODULE1
  {
    ::CORBA::TypeCode_ptr const _tc_ChildIF =
      &_tao_tc_RootModule_SUBMODULE1_ChildIF;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_RootModule_SUBMODULE1_AMH_ChildIFExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_RootModule_SUBMODULE1_AMH_ChildIFExceptionHolder (
    ::CORBA::tk_value,
    "IDL:RootModule/SUBMODULE1/AMH_ChildIFExceptionHolder:1.0",
    "AMH_ChildIFExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_RootModule_SUBMODULE1_AMH_ChildIFExceptionHolder,
    0);
  

namespace RootModule
{
  
  namespace SUBMODULE1
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_ChildIFExceptionHolder =
      &_tao_tc_RootModule_SUBMODULE1_AMH_ChildIFExceptionHolder;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder>::add_ref (RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder>::remove_ref (RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder>::release (RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder *
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder *> (v);
}

const char *
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_ChildIFExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_ChildIFExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_type () const
{
  return ::RootModule::SUBMODULE1::_tc_AMH_ChildIFExceptionHolder;
}

RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::~AMH_ChildIFExceptionHolder ()
{}

::CORBA::ValueBase *
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_ChildIFExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_marshal__RootModule_SUBMODULE1_AMH_ChildIFExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_unmarshal__RootModule_SUBMODULE1_AMH_ChildIFExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_ChildIFExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_ChildIFExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_ChildIFExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder_init::AMH_ChildIFExceptionHolder_init ()
{
}

RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder_init::~AMH_ChildIFExceptionHolder_init ()
{
}

RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder_init *
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder_init *> (v);
}

const char*
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder_init::tao_repository_id ()
{
  return ::RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for RootModule::SUBMODULE1::AMH_ChildIFResponseHandler.

RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr
TAO::Objref_Traits<RootModule::SUBMODULE1::AMH_ChildIFResponseHandler>::duplicate (RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr p)
{
  return RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<RootModule::SUBMODULE1::AMH_ChildIFResponseHandler>::release (RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr
TAO::Objref_Traits<RootModule::SUBMODULE1::AMH_ChildIFResponseHandler>::nil ()
{
  return RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<RootModule::SUBMODULE1::AMH_ChildIFResponseHandler>::marshal (const RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::AMH_ChildIFResponseHandler ()
{}void
RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_ChildIFResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_ChildIFResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr
RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_ChildIFResponseHandler::_duplicate (
      dynamic_cast<AMH_ChildIFResponseHandler_ptr> (_tao_objref));
}

RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr
RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_ChildIFResponseHandler::_duplicate (
      dynamic_cast<AMH_ChildIFResponseHandler_ptr> (_tao_objref));
}

RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr
RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_nil ()
{
  return nullptr;
}

RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr
RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_duplicate (AMH_ChildIFResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_tao_release (AMH_ChildIFResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:RootModule/SUBMODULE1/AMH_ChildIFResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_interface_repository_id () const
{
  return "IDL:RootModule/SUBMODULE1/AMH_ChildIFResponseHandler:1.0";
}

const char* RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_desc_repository_id ()
{
  return "IDL:RootModule/SUBMODULE1/AMH_ChildIFResponseHandler:1.0";
}

const char* RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_desc_interface_name ()
{
  return "AMH_ChildIFResponseHandler";
}

::CORBA::Boolean
RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_RootModule_SUBMODULE1_AMH_ChildIFResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:RootModule/SUBMODULE1/AMH_ChildIFResponseHandler:1.0",
    "AMH_ChildIFResponseHandler");
  

namespace RootModule
{
  
  namespace SUBMODULE1
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_ChildIFResponseHandler =
      &_tao_tc_RootModule_SUBMODULE1_AMH_ChildIFResponseHandler;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for RootModule::SUBMODULE1::AMI_ChildIFHandler.

RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr
TAO::Objref_Traits<RootModule::SUBMODULE1::AMI_ChildIFHandler>::duplicate (RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr p)
{
  return RootModule::SUBMODULE1::AMI_ChildIFHandler::_duplicate (p);
}

void
TAO::Objref_Traits<RootModule::SUBMODULE1::AMI_ChildIFHandler>::release (RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr p)
{
  ::CORBA::release (p);
}

RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr
TAO::Objref_Traits<RootModule::SUBMODULE1::AMI_ChildIFHandler>::nil ()
{
  return RootModule::SUBMODULE1::AMI_ChildIFHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<RootModule::SUBMODULE1::AMI_ChildIFHandler>::marshal (const RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



RootModule::SUBMODULE1::AMI_ChildIFHandler::AMI_ChildIFHandler ()
{
}
void
RootModule::SUBMODULE1::AMI_ChildIFHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_ChildIFHandler *_tao_tmp_pointer =
    static_cast<AMI_ChildIFHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr
RootModule::SUBMODULE1::AMI_ChildIFHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_ChildIFHandler>::narrow (_tao_objref, "IDL:RootModule/SUBMODULE1/AMI_ChildIFHandler:1.0");
}

RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr
RootModule::SUBMODULE1::AMI_ChildIFHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_ChildIFHandler>::unchecked_narrow (_tao_objref);
}

RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr
RootModule::SUBMODULE1::AMI_ChildIFHandler::_nil ()
{
  return nullptr;
}

RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr
RootModule::SUBMODULE1::AMI_ChildIFHandler::_duplicate (AMI_ChildIFHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
RootModule::SUBMODULE1::AMI_ChildIFHandler::_tao_release (AMI_ChildIFHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
RootModule::SUBMODULE1::AMI_ChildIFHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:RootModule/SUBMODULE1/AMI_ParentIFHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:RootModule/SUBMODULE1/AMI_ChildIFHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* RootModule::SUBMODULE1::AMI_ChildIFHandler::_interface_repository_id () const
{
  return "IDL:RootModule/SUBMODULE1/AMI_ChildIFHandler:1.0";
}

const char* RootModule::SUBMODULE1::AMI_ChildIFHandler::_desc_repository_id ()
{
  return "IDL:RootModule/SUBMODULE1/AMI_ChildIFHandler:1.0";
}

const char* RootModule::SUBMODULE1::AMI_ChildIFHandler::_desc_interface_name ()
{
  return "AMI_ChildIFHandler";
}

::CORBA::Boolean
RootModule::SUBMODULE1::AMI_ChildIFHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_RootModule_SUBMODULE1_AMI_ChildIFHandler (
    ::CORBA::tk_objref,
    "IDL:RootModule/SUBMODULE1/AMI_ChildIFHandler:1.0",
    "AMI_ChildIFHandler");
  

namespace RootModule
{
  
  namespace SUBMODULE1
  {
    ::CORBA::TypeCode_ptr const _tc_AMI_ChildIFHandler =
      &_tao_tc_RootModule_SUBMODULE1_AMI_ChildIFHandler;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for B.

B_ptr
TAO::Objref_Traits<B>::duplicate (B_ptr p)
{
  return B::_duplicate (p);
}

void
TAO::Objref_Traits<B>::release (B_ptr p)
{
  ::CORBA::release (p);
}

B_ptr
TAO::Objref_Traits<B>::nil ()
{
  return B::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<B>::marshal (const B_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_B_my_b_long (
    ::CORBA::tk_alias,
    "IDL:B/my_b_long:1.0",
    "my_b_long",
    &AAA::_tc_my_long_type);
  
::CORBA::TypeCode_ptr const B::_tc_my_b_long =
  &_tao_tc_B_my_b_long;

B::B ()
{
}
void
B::_tao_any_destructor (void *_tao_void_pointer)
{
  B *_tao_tmp_pointer =
    static_cast<B *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

B_ptr
B::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<B>::narrow (_tao_objref, "IDL:B:1.0");
}

B_ptr
B::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<B>::unchecked_narrow (_tao_objref);
}

B_ptr
B::_nil ()
{
  return nullptr;
}

B_ptr
B::_duplicate (B_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
B::_tao_release (B_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
B::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:B:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* B::_interface_repository_id () const
{
  return "IDL:B:1.0";
}

const char* B::_desc_repository_id ()
{
  return "IDL:B:1.0";
}

const char* B::_desc_interface_name ()
{
  return "B";
}

::CORBA::Boolean
B::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_B (
    ::CORBA::tk_objref,
    "IDL:B:1.0",
    "B");
  
::CORBA::TypeCode_ptr const _tc_B =
  &_tao_tc_B;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_BExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_BExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_BExceptionHolder:1.0",
    "AMH_BExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_BExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_BExceptionHolder =
  &_tao_tc_AMH_BExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_BExceptionHolder>::add_ref (AMH_BExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_BExceptionHolder>::remove_ref (AMH_BExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_BExceptionHolder>::release (AMH_BExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_BExceptionHolder *
AMH_BExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_BExceptionHolder *> (v);
}

const char *
AMH_BExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_BExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_BExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_BExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_BExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_BExceptionHolder;
}

AMH_BExceptionHolder::~AMH_BExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_BExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_BExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_BExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_BExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_BExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_BExceptionHolder::_tao_marshal__AMH_BExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_BExceptionHolder::_tao_unmarshal__AMH_BExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_BExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_BExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_BExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_BExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AMH_BExceptionHolder_init::AMH_BExceptionHolder_init ()
{
}

AMH_BExceptionHolder_init::~AMH_BExceptionHolder_init ()
{
}

AMH_BExceptionHolder_init *
AMH_BExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AMH_BExceptionHolder_init *> (v);
}

const char*
AMH_BExceptionHolder_init::tao_repository_id ()
{
  return ::AMH_BExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AMH_BExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AMH_BExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_BResponseHandler.

AMH_BResponseHandler_ptr
TAO::Objref_Traits<AMH_BResponseHandler>::duplicate (AMH_BResponseHandler_ptr p)
{
  return AMH_BResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_BResponseHandler>::release (AMH_BResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_BResponseHandler_ptr
TAO::Objref_Traits<AMH_BResponseHandler>::nil ()
{
  return AMH_BResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_BResponseHandler>::marshal (const AMH_BResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_BResponseHandler::AMH_BResponseHandler ()
{}void
AMH_BResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_BResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_BResponseHandler_ptr
AMH_BResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_BResponseHandler::_duplicate (
      dynamic_cast<AMH_BResponseHandler_ptr> (_tao_objref));
}

AMH_BResponseHandler_ptr
AMH_BResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_BResponseHandler::_duplicate (
      dynamic_cast<AMH_BResponseHandler_ptr> (_tao_objref));
}

AMH_BResponseHandler_ptr
AMH_BResponseHandler::_nil ()
{
  return nullptr;
}

AMH_BResponseHandler_ptr
AMH_BResponseHandler::_duplicate (AMH_BResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_BResponseHandler::_tao_release (AMH_BResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_BResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_BResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_BResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_BResponseHandler:1.0";
}

const char* AMH_BResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_BResponseHandler:1.0";
}

const char* AMH_BResponseHandler::_desc_interface_name ()
{
  return "AMH_BResponseHandler";
}

::CORBA::Boolean
AMH_BResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_BResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_BResponseHandler:1.0",
    "AMH_BResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_BResponseHandler =
  &_tao_tc_AMH_BResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_BHandler.

AMI_BHandler_ptr
TAO::Objref_Traits<AMI_BHandler>::duplicate (AMI_BHandler_ptr p)
{
  return AMI_BHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_BHandler>::release (AMI_BHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_BHandler_ptr
TAO::Objref_Traits<AMI_BHandler>::nil ()
{
  return AMI_BHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_BHandler>::marshal (const AMI_BHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMI_BHandler::AMI_BHandler ()
{
}
void
AMI_BHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_BHandler *_tao_tmp_pointer =
    static_cast<AMI_BHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_BHandler_ptr
AMI_BHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_BHandler>::narrow (_tao_objref, "IDL:AMI_BHandler:1.0");
}

AMI_BHandler_ptr
AMI_BHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_BHandler>::unchecked_narrow (_tao_objref);
}

AMI_BHandler_ptr
AMI_BHandler::_nil ()
{
  return nullptr;
}

AMI_BHandler_ptr
AMI_BHandler::_duplicate (AMI_BHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_BHandler::_tao_release (AMI_BHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_BHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_BHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_BHandler::_interface_repository_id () const
{
  return "IDL:AMI_BHandler:1.0";
}

const char* AMI_BHandler::_desc_repository_id ()
{
  return "IDL:AMI_BHandler:1.0";
}

const char* AMI_BHandler::_desc_interface_name ()
{
  return "AMI_BHandler";
}

::CORBA::Boolean
AMI_BHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_BHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_BHandler:1.0",
    "AMI_BHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_BHandler =
  &_tao_tc_AMI_BHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_ifaceExceptionHolder::~OBV_AMH_ifaceExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_ifaceExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_ifaceExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_ifaceExceptionHolder::_tao_marshal__AMH_ifaceExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_ifaceExceptionHolder::_tao_unmarshal__AMH_ifaceExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_MyIntExceptionHolder::~OBV_AMH_MyIntExceptionHolder ()
{}

::CORBA::Boolean
OBV_AMH_MyIntExceptionHolder::_tao_marshal__AMH_MyIntExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_MyIntExceptionHolder::_tao_unmarshal__AMH_MyIntExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::~AMH_ChildIFExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_ChildIFExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_marshal__RootModule_SUBMODULE1_AMH_ChildIFExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_unmarshal__RootModule_SUBMODULE1_AMH_ChildIFExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_BExceptionHolder::~OBV_AMH_BExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AMH_BExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    OBV_AMH_BExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AMH_BExceptionHolder::_tao_marshal__AMH_BExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_BExceptionHolder::_tao_unmarshal__AMH_BExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_enum/any_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

void operator<<= (
    ::CORBA::Any &_tao_any,
    choice _tao_elem)
{
  TAO::Any_Basic_Impl_T<choice>::insert (
      _tao_any,
      _tc_choice,
      _tao_elem);
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    choice &_tao_elem)
{
  return
    TAO::Any_Basic_Impl_T<choice>::extract (
        _tao_any,
        _tc_choice,
        _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/any_op_cs.cpp:35


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const myUnion &_tao_elem)
{
  TAO::Any_Dual_Impl_T<myUnion>::insert_copy (
    _tao_any,
    myUnion::_tao_any_destructor,
    _tc_myUnion,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  myUnion *_tao_elem)
{
  TAO::Any_Dual_Impl_T<myUnion>::insert (
    _tao_any,
    myUnion::_tao_any_destructor,
    _tc_myUnion,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const myUnion *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<myUnion>::extract (
    _tao_any,
    myUnion::_tao_any_destructor,
    _tc_myUnion,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/any_op_cs.cpp:35


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const Bog &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Bog>::insert_copy (
    _tao_any,
    Bog::_tao_any_destructor,
    _tc_Bog,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  Bog *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Bog>::insert (
    _tao_any,
    Bog::_tao_any_destructor,
    _tc_Bog,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const Bog *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<Bog>::extract (
    _tao_any,
    Bog::_tao_any_destructor,
    _tc_Bog,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<iface>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  iface_ptr _tao_elem)
{
  iface_ptr _tao_objptr =
    iface::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  iface_ptr *_tao_elem)
{
  TAO::Any_Impl_T<iface>::insert (
    _tao_any,
    iface::_tao_any_destructor,
    _tc_iface,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    iface_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<iface>::extract (
        _tao_any,
        iface::_tao_any_destructor,
        _tc_iface,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_enum/any_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

void operator<<= (
    ::CORBA::Any &_tao_any,
    iface::postal _tao_elem)
{
  TAO::Any_Basic_Impl_T<iface::postal>::insert (
      _tao_any,
      iface::_tc_postal,
      _tao_elem);
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    iface::postal &_tao_elem)
{
  return
    TAO::Any_Basic_Impl_T<iface::postal>::extract (
        _tao_any,
        iface::_tc_postal,
        _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::iface::using_incl &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::iface::using_incl>::insert_copy (
    _tao_any,
    ::iface::using_incl::_tao_any_destructor,
    iface::_tc_using_incl,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::iface::using_incl *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::iface::using_incl>::insert (
    _tao_any,
    ::iface::using_incl::_tao_any_destructor,
    iface::_tc_using_incl,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::iface::using_incl *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::iface::using_incl>::extract (
    _tao_any,
    ::iface::using_incl::_tao_any_destructor,
    iface::_tc_using_incl,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_ifaceExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_ifaceExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_ifaceExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_ifaceExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_ifaceExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_ifaceExceptionHolder>::insert (
    _tao_any,
    AMH_ifaceExceptionHolder::_tao_any_destructor,
    _tc_AMH_ifaceExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_ifaceExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_ifaceExceptionHolder>::extract (
        _tao_any,
        AMH_ifaceExceptionHolder::_tao_any_destructor,
        _tc_AMH_ifaceExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_ifaceResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_ifaceResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_ifaceResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_ifaceResponseHandler_ptr _tao_elem)
{
  AMH_ifaceResponseHandler_ptr _tao_objptr =
    AMH_ifaceResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_ifaceResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_ifaceResponseHandler>::insert (
    _tao_any,
    AMH_ifaceResponseHandler::_tao_any_destructor,
    _tc_AMH_ifaceResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_ifaceResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_ifaceResponseHandler>::extract (
        _tao_any,
        AMH_ifaceResponseHandler::_tao_any_destructor,
        _tc_AMH_ifaceResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_ifaceHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_ifaceHandler_ptr _tao_elem)
{
  AMI_ifaceHandler_ptr _tao_objptr =
    AMI_ifaceHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_ifaceHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_ifaceHandler>::insert (
    _tao_any,
    AMI_ifaceHandler::_tao_any_destructor,
    _tc_AMI_ifaceHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_ifaceHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_ifaceHandler>::extract (
        _tao_any,
        AMI_ifaceHandler::_tao_any_destructor,
        _tc_AMI_ifaceHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/any_op_cs.cpp:43


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {


/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::VT_Test::VTSeq &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::VT_Test::VTSeq>::insert_copy (
    _tao_any,
    ::VT_Test::VTSeq::_tao_any_destructor,
    ::VT_Test::_tc_VTSeq,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::VT_Test::VTSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::VT_Test::VTSeq>::insert (
    _tao_any,
    ::VT_Test::VTSeq::_tao_any_destructor,
    ::VT_Test::_tc_VTSeq,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::VT_Test::VTSeq *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::VT_Test::VTSeq>::extract (
    _tao_any,
    ::VT_Test::VTSeq::_tao_any_destructor,
    ::VT_Test::_tc_VTSeq,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<MyException>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const MyException &_tao_elem)
{
  TAO::Any_Dual_Impl_T<MyException>::insert_copy (
    _tao_any,
    MyException::_tao_any_destructor,
    _tc_MyException,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  MyException *_tao_elem)
{
  TAO::Any_Dual_Impl_T<MyException>::insert (
    _tao_any,
    MyException::_tao_any_destructor,
    _tc_MyException,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const MyException *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<MyException>::extract (
    _tao_any,
    MyException::_tao_any_destructor,
    _tc_MyException,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::TestStr &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::TestStr>::insert_copy (
    _tao_any,
    ::TestStr::_tao_any_destructor,
    _tc_TestStr,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::TestStr *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::TestStr>::insert (
    _tao_any,
    ::TestStr::_tao_any_destructor,
    _tc_TestStr,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::TestStr *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::TestStr>::extract (
    _tao_any,
    ::TestStr::_tao_any_destructor,
    _tc_TestStr,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/any_op_cs.cpp:35


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const TestUn &_tao_elem)
{
  TAO::Any_Dual_Impl_T<TestUn>::insert_copy (
    _tao_any,
    TestUn::_tao_any_destructor,
    _tc_TestUn,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  TestUn *_tao_elem)
{
  TAO::Any_Dual_Impl_T<TestUn>::insert (
    _tao_any,
    TestUn::_tao_any_destructor,
    _tc_TestUn,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const TestUn *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<TestUn>::extract (
    _tao_any,
    TestUn::_tao_any_destructor,
    _tc_TestUn,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<MyInt>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  MyInt_ptr _tao_elem)
{
  MyInt_ptr _tao_objptr =
    MyInt::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  MyInt_ptr *_tao_elem)
{
  TAO::Any_Impl_T<MyInt>::insert (
    _tao_any,
    MyInt::_tao_any_destructor,
    _tc_MyInt,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    MyInt_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<MyInt>::extract (
        _tao_any,
        MyInt::_tao_any_destructor,
        _tc_MyInt,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_MyIntExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_MyIntExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_MyIntExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_MyIntExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_MyIntExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_MyIntExceptionHolder>::insert (
    _tao_any,
    AMH_MyIntExceptionHolder::_tao_any_destructor,
    _tc_AMH_MyIntExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_MyIntExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_MyIntExceptionHolder>::extract (
        _tao_any,
        AMH_MyIntExceptionHolder::_tao_any_destructor,
        _tc_AMH_MyIntExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_MyIntResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_MyIntResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_MyIntResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_MyIntResponseHandler_ptr _tao_elem)
{
  AMH_MyIntResponseHandler_ptr _tao_objptr =
    AMH_MyIntResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_MyIntResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_MyIntResponseHandler>::insert (
    _tao_any,
    AMH_MyIntResponseHandler::_tao_any_destructor,
    _tc_AMH_MyIntResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_MyIntResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_MyIntResponseHandler>::extract (
        _tao_any,
        AMH_MyIntResponseHandler::_tao_any_destructor,
        _tc_AMH_MyIntResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_MyIntHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_MyIntHandler_ptr _tao_elem)
{
  AMI_MyIntHandler_ptr _tao_objptr =
    AMI_MyIntHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_MyIntHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_MyIntHandler>::insert (
    _tao_any,
    AMI_MyIntHandler::_tao_any_destructor,
    _tc_AMI_MyIntHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_MyIntHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_MyIntHandler>::extract (
        _tao_any,
        AMI_MyIntHandler::_tao_any_destructor,
        _tc_AMI_MyIntHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<RootModule::SUBMODULE1::ChildIF>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  RootModule::SUBMODULE1::ChildIF_ptr _tao_elem)
{
  RootModule::SUBMODULE1::ChildIF_ptr _tao_objptr =
    RootModule::SUBMODULE1::ChildIF::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  RootModule::SUBMODULE1::ChildIF_ptr *_tao_elem)
{
  TAO::Any_Impl_T<RootModule::SUBMODULE1::ChildIF>::insert (
    _tao_any,
    RootModule::SUBMODULE1::ChildIF::_tao_any_destructor,
    RootModule::SUBMODULE1::_tc_ChildIF,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    RootModule::SUBMODULE1::ChildIF_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<RootModule::SUBMODULE1::ChildIF>::extract (
        _tao_any,
        RootModule::SUBMODULE1::ChildIF::_tao_any_destructor,
        RootModule::SUBMODULE1::_tc_ChildIF,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_enum/any_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

void operator<<= (
    ::CORBA::Any &_tao_any,
    RootModule::SUBMODULE1::ChildIF::DifferentMode _tao_elem)
{
  TAO::Any_Basic_Impl_T<RootModule::SUBMODULE1::ChildIF::DifferentMode>::insert (
      _tao_any,
      RootModule::SUBMODULE1::ChildIF::_tc_DifferentMode,
      _tao_elem);
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    RootModule::SUBMODULE1::ChildIF::DifferentMode &_tao_elem)
{
  return
    TAO::Any_Basic_Impl_T<RootModule::SUBMODULE1::ChildIF::DifferentMode>::extract (
        _tao_any,
        RootModule::SUBMODULE1::ChildIF::_tc_DifferentMode,
        _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder *_tao_copy =
      _tao_elem ?
        RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder>::insert (
    _tao_any,
    RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_any_destructor,
    RootModule::SUBMODULE1::_tc_AMH_ChildIFExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder>::extract (
        _tao_any,
        RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_any_destructor,
        RootModule::SUBMODULE1::_tc_AMH_ChildIFExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<RootModule::SUBMODULE1::AMH_ChildIFResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<RootModule::SUBMODULE1::AMH_ChildIFResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<RootModule::SUBMODULE1::AMH_ChildIFResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr _tao_elem)
{
  RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr _tao_objptr =
    RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<RootModule::SUBMODULE1::AMH_ChildIFResponseHandler>::insert (
    _tao_any,
    RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_tao_any_destructor,
    RootModule::SUBMODULE1::_tc_AMH_ChildIFResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    RootModule::SUBMODULE1::AMH_ChildIFResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<RootModule::SUBMODULE1::AMH_ChildIFResponseHandler>::extract (
        _tao_any,
        RootModule::SUBMODULE1::AMH_ChildIFResponseHandler::_tao_any_destructor,
        RootModule::SUBMODULE1::_tc_AMH_ChildIFResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<RootModule::SUBMODULE1::AMI_ChildIFHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr _tao_elem)
{
  RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr _tao_objptr =
    RootModule::SUBMODULE1::AMI_ChildIFHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<RootModule::SUBMODULE1::AMI_ChildIFHandler>::insert (
    _tao_any,
    RootModule::SUBMODULE1::AMI_ChildIFHandler::_tao_any_destructor,
    RootModule::SUBMODULE1::_tc_AMI_ChildIFHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<RootModule::SUBMODULE1::AMI_ChildIFHandler>::extract (
        _tao_any,
        RootModule::SUBMODULE1::AMI_ChildIFHandler::_tao_any_destructor,
        RootModule::SUBMODULE1::_tc_AMI_ChildIFHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<B>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  B_ptr _tao_elem)
{
  B_ptr _tao_objptr =
    B::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  B_ptr *_tao_elem)
{
  TAO::Any_Impl_T<B>::insert (
    _tao_any,
    B::_tao_any_destructor,
    _tc_B,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    B_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<B>::extract (
        _tao_any,
        B::_tao_any_destructor,
        _tc_B,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_BExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_BExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_BExceptionHolder>::insert (
    _tao_any,
    AMH_BExceptionHolder::_tao_any_destructor,
    _tc_AMH_BExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_BExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_BExceptionHolder>::extract (
        _tao_any,
        AMH_BExceptionHolder::_tao_any_destructor,
        _tc_AMH_BExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_BResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BResponseHandler_ptr _tao_elem)
{
  AMH_BResponseHandler_ptr _tao_objptr =
    AMH_BResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_BResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_BResponseHandler>::insert (
    _tao_any,
    AMH_BResponseHandler::_tao_any_destructor,
    _tc_AMH_BResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_BResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_BResponseHandler>::extract (
        _tao_any,
        AMH_BResponseHandler::_tao_any_destructor,
        _tc_AMH_BResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_BHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_BHandler_ptr _tao_elem)
{
  AMI_BHandler_ptr _tao_objptr =
    AMI_BHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_BHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_BHandler>::insert (
    _tao_any,
    AMI_BHandler::_tao_any_destructor,
    _tc_AMI_BHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_BHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_BHandler>::extract (
        _tao_any,
        AMI_BHandler::_tao_any_destructor,
        _tc_AMI_BHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_enum/cdr_op_cs.cpp:29


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, choice _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, choice & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<choice> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/cdr_op_cs.cpp:119


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const myUnion &_tao_union)
{
  if (!(strm << _tao_union._d ()))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case ::dog:
      {
        result = strm << _tao_union.cat ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    myUnion &_tao_union)
{
  choice _tao_discriminant;
  if (!(strm >> _tao_discriminant))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case ::dog:
      {
        Aok::Seq1Type _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        if (result)
          {
            _tao_union.cat (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/cdr_op_cs.cpp:119


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Bog &_tao_union)
{
  if (!(strm << _tao_union._d ()))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case ::Agog1:
      {
        result = strm << _tao_union.bog1 ();
      }
      break;
    case ::Agog2:
      {
        result = strm << _tao_union.bog2 ();
      }
      break;
    case ::Agog3:
      {
        result = strm << _tao_union.bog3 ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Bog &_tao_union)
{
  Agog _tao_discriminant;
  if (!(strm >> _tao_discriminant))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case ::Agog1:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        if (result)
          {
            _tao_union.bog1 (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case ::Agog2:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        if (result)
          {
            _tao_union.bog2 (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case ::Agog3:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        if (result)
          {
            _tao_union.bog3 (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_enum/cdr_op_cs.cpp:29


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, iface::postal _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, iface::postal & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<iface::postal> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const iface::using_incl &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.field1) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    iface::using_incl &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.field1) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const iface_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    iface_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::iface>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_ifaceExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_ifaceExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_ifaceExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_ifaceExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_ifaceExceptionHolder *&_tao_valuetype)
{
  return AMH_ifaceExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_ifaceExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_ifaceExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_ifaceExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_ifaceHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_ifaceHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_ifaceHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/cdr_op_cs.cpp:92

#if !defined _TAO_CDR_OP_VT_Test_VTSeq_CPP_
#define _TAO_CDR_OP_VT_Test_VTSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const VT_Test::VTSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    VT_Test::VTSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_VT_Test_VTSeq_CPP_ */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const MyException &_tao_aggregate)
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.exField)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    MyException &_tao_aggregate)
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.exField)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TestStr &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.field) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TestStr &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.field) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_union/cdr_op_cs.cpp:119


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TestUn &_tao_union)
{
  if (!(strm << _tao_union._d ()))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 0:
      {
        
      }
      break;
    case 1:
      {
        result = strm << _tao_union.value2 ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TestUn &_tao_union)
{
  CORBA::Long _tao_discriminant;
  if (!(strm >> _tao_discriminant))
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 0:
      {
        
      }
      break;
    case 1:
      {
        ::CORBA::String_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.out ();
        if (result)
          {
            _tao_union.value2 (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const MyInt_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    MyInt_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::MyInt>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_MyIntExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_MyIntExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_MyIntExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_MyIntExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_MyIntExceptionHolder *&_tao_valuetype)
{
  return AMH_MyIntExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_MyIntExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_MyIntExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_MyIntExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_MyIntHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_MyIntHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_MyIntHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_enum/cdr_op_cs.cpp:29


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, RootModule::SUBMODULE1::ChildIF::DifferentMode _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, RootModule::SUBMODULE1::ChildIF::DifferentMode & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<RootModule::SUBMODULE1::ChildIF::DifferentMode> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RootModule::SUBMODULE1::ChildIF_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RootModule::SUBMODULE1::ChildIF_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::RootModule::SUBMODULE1::ChildIF>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder *&_tao_valuetype)
{
  return RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_RootModule::SUBMODULE1::AMH_ChildIFExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    RootModule::SUBMODULE1::AMI_ChildIFHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::RootModule::SUBMODULE1::AMI_ChildIFHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const B_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    B_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::B>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_BExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_BExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_BExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_BExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_BExceptionHolder *&_tao_valuetype)
{
  return AMH_BExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_BExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_BExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_BExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_BHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_BHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_BHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



