// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v4.0.2
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       https://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     https://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_codegen.cpp:372


#include "TestVersionedNamespaceC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "cstring"

#if !defined (__ACE_INLINE__)
#include "TestVersionedNamespaceC.inl"
#endif /* !defined INLINE */

BEGIN_USER_VERSIONED_NAMESPACE


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_M1_S1[] =
      {
        { "o", &CORBA::_tc_octet }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_M1_S1 (
  ::CORBA::tk_struct,
  "IDL:M1/S1:1.0",
  "S1",
  _tao_fields_M1_S1,
  1);


namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_S1 =
    &_tao_tc_M1_S1;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47



END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for M1::LI.

M1::LI_ptr
TAO::Objref_Traits<M1::LI>::duplicate (M1::LI_ptr p)
{
  return M1::LI::_duplicate (p);
}

void
TAO::Objref_Traits<M1::LI>::release (M1::LI_ptr p)
{
  ::CORBA::release (p);
}

M1::LI_ptr
TAO::Objref_Traits<M1::LI>::nil ()
{
  return M1::LI::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<M1::LI>::marshal (const M1::LI_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M1::LI::LI ()
{}M1::LI_ptr
M1::LI::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return LI::_duplicate (
      dynamic_cast<LI_ptr> (_tao_objref));
}

M1::LI_ptr
M1::LI::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return LI::_duplicate (
      dynamic_cast<LI_ptr> (_tao_objref));
}

M1::LI_ptr
M1::LI::_nil ()
{
  return nullptr;
}

M1::LI_ptr
M1::LI::_duplicate (LI_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
M1::LI::_tao_release (LI_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
M1::LI::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:M1/LI:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* M1::LI::_interface_repository_id () const
{
  return "IDL:M1/LI:1.0";
}

::CORBA::Boolean
M1::LI::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_M1_LI (
    ::CORBA::tk_local_interface,
    "IDL:M1/LI:1.0",
    "LI");
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_LI =
    &_tao_tc_M1_LI;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_M1_V[] =
  {
    { "valString", &CORBA::_tc_string, ::CORBA::PUBLIC_MEMBER },
    { "valStruct", &M1::_tc_S1, ::CORBA::PUBLIC_MEMBER },
    { "valLocalIface", &M1::_tc_LI, ::CORBA::PUBLIC_MEMBER }
    
  };
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_M1_V (
    ::CORBA::tk_value,
    "IDL:M1/V:1.0",
    "V",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_M1_V,
    3);
  

namespace M1
{
  ::CORBA::TypeCode_ptr const _tc_V =
    &_tao_tc_M1_V;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52




END_USER_VERSIONED_NAMESPACE


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<M1::V>::add_ref (M1::V * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<M1::V>::remove_ref (M1::V * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<M1::V>::release (M1::V * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL


BEGIN_USER_VERSIONED_NAMESPACE




M1::V *
M1::V::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::M1::V *> (v);
}

const char *
M1::V::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
M1::V::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr M1::V::_tao_type () const
{
  return ::M1::_tc_V;
}

M1::V::~V ()
{}

::CORBA::Boolean
M1::V::_tao_marshal_v (TAO_OutputCDR &) const
{
  return false;
}

::CORBA::Boolean
M1::V::_tao_unmarshal_v (TAO_InputCDR &)
{
  return false;
}

::CORBA::Boolean
M1::V::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (M1::V::_downcast);
}

::CORBA::Boolean
M1::V::_tao_unmarshal (
    TAO_InputCDR &strm,
    V *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        V::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = V::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



M1::V_init::V_init ()
{
}

M1::V_init::~V_init ()
{
}

M1::V_init *
M1::V_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::M1::V_init *> (v);
}

const char*
M1::V_init::tao_repository_id ()
{
  return ::M1::V::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
M1::V_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_M1::V,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_M1::V::V (
    const char * _tao_init_valString,
    const ::M1::S1 & _tao_init_valStruct,
    ::M1::LI_ptr _tao_init_valLocalIface)
{
  valString (_tao_init_valString);
  valStruct (_tao_init_valStruct);
  valLocalIface (_tao_init_valLocalIface);
}

OBV_M1::V::~V ()
{}

::CORBA::ValueBase *
OBV_M1::V::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    V (
      valString (),
      valStruct (),
      valLocalIface ()
    ),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:825

/// Accessor to set the member.
void
OBV_M1::V::valString (char *val)
{
  this->_pd_valString = (val);
}

/// Accessor to set the member.
void
OBV_M1::V::valString (const char *val)
{
  // Set the value.
  this->_pd_valString = ::CORBA::string_dup (val);
}

/// Accessor to set the member.
void
OBV_M1::V::valString (const ::CORBA::String_var &val)
{
  ::CORBA::String_var valString_var = val;
  this->_pd_valString = valString_var._retn ();
}

const char *
OBV_M1::V::valString () const // get method
{
  return this->_pd_valString;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:993

/// Accessor to set the member.
void
OBV_M1::V::valStruct (const M1::S1 &val)
{
  this->_pd_valStruct = val;
}
/// Readonly get method.
const M1::S1 &
OBV_M1::V::valStruct () const
{
  return this->_pd_valStruct;
}
/// Read/write get method.
M1::S1 &
OBV_M1::V::valStruct ()
{
  return this->_pd_valStruct;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/field_cs.cpp:284

/// Accessor to set the member.
void
OBV_M1::V::valLocalIface (M1::LI_ptr val)
{
  this->_pd_valLocalIface =
    TAO::Objref_Traits< ::M1::LI>::duplicate (val);
}

/// Retrieve the member.
M1::LI_ptr
OBV_M1::V::valLocalIface () const
{
  return this->_pd_valLocalIface.in ();
}


END_USER_VERSIONED_NAMESPACE


