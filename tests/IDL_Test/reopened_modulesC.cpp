// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v4.0.2
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       https://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     https://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_codegen.cpp:372


#include "reopened_modulesC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Messaging/Asynch_Invocation_Adapter.h"
#include "tao/Messaging/ExceptionHolder_i.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "cstring"
#include "memory"

#if !defined (__ACE_INLINE__)
#include "reopened_modulesC.inl"
#endif /* !defined INLINE */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AA::BB::x1.

AA::BB::x1_ptr
TAO::Objref_Traits<AA::BB::x1>::duplicate (AA::BB::x1_ptr p)
{
  return AA::BB::x1::_duplicate (p);
}

void
TAO::Objref_Traits<AA::BB::x1>::release (AA::BB::x1_ptr p)
{
  ::CORBA::release (p);
}

AA::BB::x1_ptr
TAO::Objref_Traits<AA::BB::x1>::nil ()
{
  return AA::BB::x1::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AA::BB::x1>::marshal (const AA::BB::x1_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AA::BB::x1::x1 ()
{
}
void
AA::BB::x1::_tao_any_destructor (void *_tao_void_pointer)
{
  x1 *_tao_tmp_pointer =
    static_cast<x1 *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AA::BB::x1_ptr
AA::BB::x1::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<x1>::narrow (_tao_objref, "IDL:AA/BB/x1:1.0");
}

AA::BB::x1_ptr
AA::BB::x1::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<x1>::unchecked_narrow (_tao_objref);
}

AA::BB::x1_ptr
AA::BB::x1::_nil ()
{
  return nullptr;
}

AA::BB::x1_ptr
AA::BB::x1::_duplicate (x1_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AA::BB::x1::_tao_release (x1_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AA::BB::x1::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AA/BB/x1:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AA::BB::x1::_interface_repository_id () const
{
  return "IDL:AA/BB/x1:1.0";
}

const char* AA::BB::x1::_desc_repository_id ()
{
  return "IDL:AA/BB/x1:1.0";
}

const char* AA::BB::x1::_desc_interface_name ()
{
  return "x1";
}

::CORBA::Boolean
AA::BB::x1::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AA_BB_x1 (
    ::CORBA::tk_objref,
    "IDL:AA/BB/x1:1.0",
    "x1");
  

namespace AA
{
  
  namespace BB
  {
    ::CORBA::TypeCode_ptr const _tc_x1 =
      &_tao_tc_AA_BB_x1;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AA_BB_AMH_x1ExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AA_BB_AMH_x1ExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AA/BB/AMH_x1ExceptionHolder:1.0",
    "AMH_x1ExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AA_BB_AMH_x1ExceptionHolder,
    0);
  

namespace AA
{
  
  namespace BB
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_x1ExceptionHolder =
      &_tao_tc_AA_BB_AMH_x1ExceptionHolder;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AA::BB::AMH_x1ExceptionHolder>::add_ref (AA::BB::AMH_x1ExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AA::BB::AMH_x1ExceptionHolder>::remove_ref (AA::BB::AMH_x1ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AA::BB::AMH_x1ExceptionHolder>::release (AA::BB::AMH_x1ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AA::BB::AMH_x1ExceptionHolder *
AA::BB::AMH_x1ExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AA::BB::AMH_x1ExceptionHolder *> (v);
}

const char *
AA::BB::AMH_x1ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AA::BB::AMH_x1ExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AA::BB::AMH_x1ExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_x1ExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_x1ExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AA::BB::AMH_x1ExceptionHolder::_tao_type () const
{
  return ::AA::BB::_tc_AMH_x1ExceptionHolder;
}

AA::BB::AMH_x1ExceptionHolder::~AMH_x1ExceptionHolder ()
{}

::CORBA::ValueBase *
AA::BB::AMH_x1ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_x1ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AA::BB::AMH_x1ExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AA::BB::AMH_x1ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AA::BB::AMH_x1ExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AA::BB::AMH_x1ExceptionHolder::_tao_marshal__AA_BB_AMH_x1ExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AA::BB::AMH_x1ExceptionHolder::_tao_unmarshal__AA_BB_AMH_x1ExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AA::BB::AMH_x1ExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_x1ExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_x1ExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_x1ExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



AA::BB::AMH_x1ExceptionHolder_init::AMH_x1ExceptionHolder_init ()
{
}

AA::BB::AMH_x1ExceptionHolder_init::~AMH_x1ExceptionHolder_init ()
{
}

AA::BB::AMH_x1ExceptionHolder_init *
AA::BB::AMH_x1ExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::AA::BB::AMH_x1ExceptionHolder_init *> (v);
}

const char*
AA::BB::AMH_x1ExceptionHolder_init::tao_repository_id ()
{
  return ::AA::BB::AMH_x1ExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
AA::BB::AMH_x1ExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_AA::BB::AMH_x1ExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AA::BB::AMH_x1ResponseHandler.

AA::BB::AMH_x1ResponseHandler_ptr
TAO::Objref_Traits<AA::BB::AMH_x1ResponseHandler>::duplicate (AA::BB::AMH_x1ResponseHandler_ptr p)
{
  return AA::BB::AMH_x1ResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AA::BB::AMH_x1ResponseHandler>::release (AA::BB::AMH_x1ResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AA::BB::AMH_x1ResponseHandler_ptr
TAO::Objref_Traits<AA::BB::AMH_x1ResponseHandler>::nil ()
{
  return AA::BB::AMH_x1ResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AA::BB::AMH_x1ResponseHandler>::marshal (const AA::BB::AMH_x1ResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AA::BB::AMH_x1ResponseHandler::AMH_x1ResponseHandler ()
{}void
AA::BB::AMH_x1ResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_x1ResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_x1ResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AA::BB::AMH_x1ResponseHandler_ptr
AA::BB::AMH_x1ResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_x1ResponseHandler::_duplicate (
      dynamic_cast<AMH_x1ResponseHandler_ptr> (_tao_objref));
}

AA::BB::AMH_x1ResponseHandler_ptr
AA::BB::AMH_x1ResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_x1ResponseHandler::_duplicate (
      dynamic_cast<AMH_x1ResponseHandler_ptr> (_tao_objref));
}

AA::BB::AMH_x1ResponseHandler_ptr
AA::BB::AMH_x1ResponseHandler::_nil ()
{
  return nullptr;
}

AA::BB::AMH_x1ResponseHandler_ptr
AA::BB::AMH_x1ResponseHandler::_duplicate (AMH_x1ResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AA::BB::AMH_x1ResponseHandler::_tao_release (AMH_x1ResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AA::BB::AMH_x1ResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AA/BB/AMH_x1ResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AA::BB::AMH_x1ResponseHandler::_interface_repository_id () const
{
  return "IDL:AA/BB/AMH_x1ResponseHandler:1.0";
}

const char* AA::BB::AMH_x1ResponseHandler::_desc_repository_id ()
{
  return "IDL:AA/BB/AMH_x1ResponseHandler:1.0";
}

const char* AA::BB::AMH_x1ResponseHandler::_desc_interface_name ()
{
  return "AMH_x1ResponseHandler";
}

::CORBA::Boolean
AA::BB::AMH_x1ResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AA_BB_AMH_x1ResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AA/BB/AMH_x1ResponseHandler:1.0",
    "AMH_x1ResponseHandler");
  

namespace AA
{
  
  namespace BB
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_x1ResponseHandler =
      &_tao_tc_AA_BB_AMH_x1ResponseHandler;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AA::BB::AMI_x1Handler.

AA::BB::AMI_x1Handler_ptr
TAO::Objref_Traits<AA::BB::AMI_x1Handler>::duplicate (AA::BB::AMI_x1Handler_ptr p)
{
  return AA::BB::AMI_x1Handler::_duplicate (p);
}

void
TAO::Objref_Traits<AA::BB::AMI_x1Handler>::release (AA::BB::AMI_x1Handler_ptr p)
{
  ::CORBA::release (p);
}

AA::BB::AMI_x1Handler_ptr
TAO::Objref_Traits<AA::BB::AMI_x1Handler>::nil ()
{
  return AA::BB::AMI_x1Handler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AA::BB::AMI_x1Handler>::marshal (const AA::BB::AMI_x1Handler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AA::BB::AMI_x1Handler::AMI_x1Handler ()
{
}
void
AA::BB::AMI_x1Handler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_x1Handler *_tao_tmp_pointer =
    static_cast<AMI_x1Handler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AA::BB::AMI_x1Handler_ptr
AA::BB::AMI_x1Handler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_x1Handler>::narrow (_tao_objref, "IDL:AA/BB/AMI_x1Handler:1.0");
}

AA::BB::AMI_x1Handler_ptr
AA::BB::AMI_x1Handler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_x1Handler>::unchecked_narrow (_tao_objref);
}

AA::BB::AMI_x1Handler_ptr
AA::BB::AMI_x1Handler::_nil ()
{
  return nullptr;
}

AA::BB::AMI_x1Handler_ptr
AA::BB::AMI_x1Handler::_duplicate (AMI_x1Handler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AA::BB::AMI_x1Handler::_tao_release (AMI_x1Handler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AA::BB::AMI_x1Handler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AA/BB/AMI_x1Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AA::BB::AMI_x1Handler::_interface_repository_id () const
{
  return "IDL:AA/BB/AMI_x1Handler:1.0";
}

const char* AA::BB::AMI_x1Handler::_desc_repository_id ()
{
  return "IDL:AA/BB/AMI_x1Handler:1.0";
}

const char* AA::BB::AMI_x1Handler::_desc_interface_name ()
{
  return "AMI_x1Handler";
}

::CORBA::Boolean
AA::BB::AMI_x1Handler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AA_BB_AMI_x1Handler (
    ::CORBA::tk_objref,
    "IDL:AA/BB/AMI_x1Handler:1.0",
    "AMI_x1Handler");
  

namespace AA
{
  
  namespace BB
  {
    ::CORBA::TypeCode_ptr const _tc_AMI_x1Handler =
      &_tao_tc_AA_BB_AMI_x1Handler;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AA::BB::CC::x2.

AA::BB::CC::x2_ptr
TAO::Objref_Traits<AA::BB::CC::x2>::duplicate (AA::BB::CC::x2_ptr p)
{
  return AA::BB::CC::x2::_duplicate (p);
}

void
TAO::Objref_Traits<AA::BB::CC::x2>::release (AA::BB::CC::x2_ptr p)
{
  ::CORBA::release (p);
}

AA::BB::CC::x2_ptr
TAO::Objref_Traits<AA::BB::CC::x2>::nil ()
{
  return AA::BB::CC::x2::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AA::BB::CC::x2>::marshal (const AA::BB::CC::x2_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AA::BB::CC::x2::op1 (
  ::AA::BB::x1_ptr obj)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AA::BB::x1>::in_arg_val _tao_obj (obj);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_obj)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op1",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AA::BB::CC::x2::op2 (
  ::AA::BB::x1_ptr obj)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AA::BB::x1>::in_arg_val _tao_obj (obj);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_obj)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op2",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AA::BB::CC::x2::op3 (
  ::AA::BB::x1_ptr obj)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AA::BB::x1>::in_arg_val _tao_obj (obj);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_obj)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op3",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
AA::BB::CC::x2::sendc_op1 (
  ::AA::BB::CC::AMI_x2Handler_ptr ami_handler,
  ::AA::BB::x1_ptr obj)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AA::BB::x1>::in_arg_val _tao_obj (obj);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_obj)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op1",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AA::BB::CC::AMI_x2Handler::op1_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
AA::BB::CC::x2::sendc_op2 (
  ::AA::BB::CC::AMI_x2Handler_ptr ami_handler,
  ::AA::BB::x1_ptr obj)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AA::BB::x1>::in_arg_val _tao_obj (obj);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_obj)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op2",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AA::BB::CC::AMI_x2Handler::op2_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
AA::BB::CC::x2::sendc_op3 (
  ::AA::BB::CC::AMI_x2Handler_ptr ami_handler,
  ::AA::BB::x1_ptr obj)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::AA::BB::x1>::in_arg_val _tao_obj (obj);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_obj)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op3",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AA::BB::CC::AMI_x2Handler::op3_reply_stub
    );
}

AA::BB::CC::x2::x2 ()
{
}
void
AA::BB::CC::x2::_tao_any_destructor (void *_tao_void_pointer)
{
  x2 *_tao_tmp_pointer =
    static_cast<x2 *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AA::BB::CC::x2_ptr
AA::BB::CC::x2::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<x2>::narrow (_tao_objref, "IDL:AA/BB/CC/x2:1.0");
}

AA::BB::CC::x2_ptr
AA::BB::CC::x2::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<x2>::unchecked_narrow (_tao_objref);
}

AA::BB::CC::x2_ptr
AA::BB::CC::x2::_nil ()
{
  return nullptr;
}

AA::BB::CC::x2_ptr
AA::BB::CC::x2::_duplicate (x2_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AA::BB::CC::x2::_tao_release (x2_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AA::BB::CC::x2::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AA/BB/CC/x2:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AA::BB::CC::x2::_interface_repository_id () const
{
  return "IDL:AA/BB/CC/x2:1.0";
}

const char* AA::BB::CC::x2::_desc_repository_id ()
{
  return "IDL:AA/BB/CC/x2:1.0";
}

const char* AA::BB::CC::x2::_desc_interface_name ()
{
  return "x2";
}

::CORBA::Boolean
AA::BB::CC::x2::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AA_BB_CC_x2 (
    ::CORBA::tk_objref,
    "IDL:AA/BB/CC/x2:1.0",
    "x2");
  

namespace AA
{
  
  namespace BB
  {
    
    namespace CC
    {
      ::CORBA::TypeCode_ptr const _tc_x2 =
        &_tao_tc_AA_BB_CC_x2;
    }
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AA_BB_CC_AMH_x2ExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AA_BB_CC_AMH_x2ExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AA/BB/CC/AMH_x2ExceptionHolder:1.0",
    "AMH_x2ExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AA_BB_CC_AMH_x2ExceptionHolder,
    0);
  

namespace AA
{
  
  namespace BB
  {
    
    namespace CC
    {
      ::CORBA::TypeCode_ptr const _tc_AMH_x2ExceptionHolder =
        &_tao_tc_AA_BB_CC_AMH_x2ExceptionHolder;
    }
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AA::BB::CC::AMH_x2ExceptionHolder>::add_ref (AA::BB::CC::AMH_x2ExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AA::BB::CC::AMH_x2ExceptionHolder>::remove_ref (AA::BB::CC::AMH_x2ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AA::BB::CC::AMH_x2ExceptionHolder>::release (AA::BB::CC::AMH_x2ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AA::BB::CC::AMH_x2ExceptionHolder *
AA::BB::CC::AMH_x2ExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AA::BB::CC::AMH_x2ExceptionHolder *> (v);
}

const char *
AA::BB::CC::AMH_x2ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AA::BB::CC::AMH_x2ExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AA::BB::CC::AMH_x2ExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_x2ExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_x2ExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AA::BB::CC::AMH_x2ExceptionHolder::_tao_type () const
{
  return ::AA::BB::CC::_tc_AMH_x2ExceptionHolder;
}

AA::BB::CC::AMH_x2ExceptionHolder::~AMH_x2ExceptionHolder ()
{}

::CORBA::ValueBase *
AA::BB::CC::AMH_x2ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_x2ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AA::BB::CC::AMH_x2ExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AA::BB::CC::AMH_x2ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AA::BB::CC::AMH_x2ExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AA::BB::CC::AMH_x2ExceptionHolder::_tao_marshal__AA_BB_CC_AMH_x2ExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AA::BB::CC::AMH_x2ExceptionHolder::_tao_unmarshal__AA_BB_CC_AMH_x2ExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AA::BB::CC::AMH_x2ExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_x2ExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_x2ExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_x2ExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AA::BB::CC::AMH_x2ExceptionHolder::raise_op1 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AA::BB::CC::AMH_x2ExceptionHolder::raise_op2 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AA::BB::CC::AMH_x2ExceptionHolder::raise_op3 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AA::BB::CC::AMH_x2ExceptionHolder::raise_sendc_op1 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AA::BB::CC::AMH_x2ExceptionHolder::raise_sendc_op2 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AA::BB::CC::AMH_x2ExceptionHolder::raise_sendc_op3 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AA::BB::CC::AMH_x2ResponseHandler.

AA::BB::CC::AMH_x2ResponseHandler_ptr
TAO::Objref_Traits<AA::BB::CC::AMH_x2ResponseHandler>::duplicate (AA::BB::CC::AMH_x2ResponseHandler_ptr p)
{
  return AA::BB::CC::AMH_x2ResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AA::BB::CC::AMH_x2ResponseHandler>::release (AA::BB::CC::AMH_x2ResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AA::BB::CC::AMH_x2ResponseHandler_ptr
TAO::Objref_Traits<AA::BB::CC::AMH_x2ResponseHandler>::nil ()
{
  return AA::BB::CC::AMH_x2ResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AA::BB::CC::AMH_x2ResponseHandler>::marshal (const AA::BB::CC::AMH_x2ResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AA::BB::CC::AMH_x2ResponseHandler::AMH_x2ResponseHandler ()
{}void
AA::BB::CC::AMH_x2ResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_x2ResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_x2ResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AA::BB::CC::AMH_x2ResponseHandler_ptr
AA::BB::CC::AMH_x2ResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_x2ResponseHandler::_duplicate (
      dynamic_cast<AMH_x2ResponseHandler_ptr> (_tao_objref));
}

AA::BB::CC::AMH_x2ResponseHandler_ptr
AA::BB::CC::AMH_x2ResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_x2ResponseHandler::_duplicate (
      dynamic_cast<AMH_x2ResponseHandler_ptr> (_tao_objref));
}

AA::BB::CC::AMH_x2ResponseHandler_ptr
AA::BB::CC::AMH_x2ResponseHandler::_nil ()
{
  return nullptr;
}

AA::BB::CC::AMH_x2ResponseHandler_ptr
AA::BB::CC::AMH_x2ResponseHandler::_duplicate (AMH_x2ResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AA::BB::CC::AMH_x2ResponseHandler::_tao_release (AMH_x2ResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AA::BB::CC::AMH_x2ResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AA/BB/CC/AMH_x2ResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AA::BB::CC::AMH_x2ResponseHandler::_interface_repository_id () const
{
  return "IDL:AA/BB/CC/AMH_x2ResponseHandler:1.0";
}

const char* AA::BB::CC::AMH_x2ResponseHandler::_desc_repository_id ()
{
  return "IDL:AA/BB/CC/AMH_x2ResponseHandler:1.0";
}

const char* AA::BB::CC::AMH_x2ResponseHandler::_desc_interface_name ()
{
  return "AMH_x2ResponseHandler";
}

::CORBA::Boolean
AA::BB::CC::AMH_x2ResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AA_BB_CC_AMH_x2ResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AA/BB/CC/AMH_x2ResponseHandler:1.0",
    "AMH_x2ResponseHandler");
  

namespace AA
{
  
  namespace BB
  {
    
    namespace CC
    {
      ::CORBA::TypeCode_ptr const _tc_AMH_x2ResponseHandler =
        &_tao_tc_AA_BB_CC_AMH_x2ResponseHandler;
    }
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AA::BB::CC::AMI_x2Handler.

AA::BB::CC::AMI_x2Handler_ptr
TAO::Objref_Traits<AA::BB::CC::AMI_x2Handler>::duplicate (AA::BB::CC::AMI_x2Handler_ptr p)
{
  return AA::BB::CC::AMI_x2Handler::_duplicate (p);
}

void
TAO::Objref_Traits<AA::BB::CC::AMI_x2Handler>::release (AA::BB::CC::AMI_x2Handler_ptr p)
{
  ::CORBA::release (p);
}

AA::BB::CC::AMI_x2Handler_ptr
TAO::Objref_Traits<AA::BB::CC::AMI_x2Handler>::nil ()
{
  return AA::BB::CC::AMI_x2Handler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AA::BB::CC::AMI_x2Handler>::marshal (const AA::BB::CC::AMI_x2Handler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AA::BB::CC::AMI_x2Handler::op1 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "op1",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AA::BB::CC::AMI_x2Handler::op1_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AA::BB::CC::AMI_x2Handler_var _tao_reply_handler_object =
    AA::BB::CC::AMI_x2Handler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->op1 (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->op1_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AA::BB::CC::AMI_x2Handler::op1_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op1_excep",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AA::BB::CC::AMI_x2Handler::op2 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "op2",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AA::BB::CC::AMI_x2Handler::op2_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AA::BB::CC::AMI_x2Handler_var _tao_reply_handler_object =
    AA::BB::CC::AMI_x2Handler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->op2 (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->op2_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AA::BB::CC::AMI_x2Handler::op2_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op2_excep",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AA::BB::CC::AMI_x2Handler::op3 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "op3",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AA::BB::CC::AMI_x2Handler::op3_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AA::BB::CC::AMI_x2Handler_var _tao_reply_handler_object =
    AA::BB::CC::AMI_x2Handler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->op3 (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->op3_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AA::BB::CC::AMI_x2Handler::op3_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op3_excep",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

AA::BB::CC::AMI_x2Handler::AMI_x2Handler ()
{
}
void
AA::BB::CC::AMI_x2Handler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_x2Handler *_tao_tmp_pointer =
    static_cast<AMI_x2Handler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AA::BB::CC::AMI_x2Handler_ptr
AA::BB::CC::AMI_x2Handler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_x2Handler>::narrow (_tao_objref, "IDL:AA/BB/CC/AMI_x2Handler:1.0");
}

AA::BB::CC::AMI_x2Handler_ptr
AA::BB::CC::AMI_x2Handler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_x2Handler>::unchecked_narrow (_tao_objref);
}

AA::BB::CC::AMI_x2Handler_ptr
AA::BB::CC::AMI_x2Handler::_nil ()
{
  return nullptr;
}

AA::BB::CC::AMI_x2Handler_ptr
AA::BB::CC::AMI_x2Handler::_duplicate (AMI_x2Handler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AA::BB::CC::AMI_x2Handler::_tao_release (AMI_x2Handler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AA::BB::CC::AMI_x2Handler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AA/BB/CC/AMI_x2Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AA::BB::CC::AMI_x2Handler::_interface_repository_id () const
{
  return "IDL:AA/BB/CC/AMI_x2Handler:1.0";
}

const char* AA::BB::CC::AMI_x2Handler::_desc_repository_id ()
{
  return "IDL:AA/BB/CC/AMI_x2Handler:1.0";
}

const char* AA::BB::CC::AMI_x2Handler::_desc_interface_name ()
{
  return "AMI_x2Handler";
}

::CORBA::Boolean
AA::BB::CC::AMI_x2Handler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AA_BB_CC_AMI_x2Handler (
    ::CORBA::tk_objref,
    "IDL:AA/BB/CC/AMI_x2Handler:1.0",
    "AMI_x2Handler");
  

namespace AA
{
  
  namespace BB
  {
    
    namespace CC
    {
      ::CORBA::TypeCode_ptr const _tc_AMI_x2Handler =
        &_tao_tc_AA_BB_CC_AMI_x2Handler;
    }
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for dot::Person.

dot::Person_ptr
TAO::Objref_Traits<dot::Person>::duplicate (dot::Person_ptr p)
{
  return dot::Person::_duplicate (p);
}

void
TAO::Objref_Traits<dot::Person>::release (dot::Person_ptr p)
{
  ::CORBA::release (p);
}

dot::Person_ptr
TAO::Objref_Traits<dot::Person>::nil ()
{
  return dot::Person::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<dot::Person>::marshal (const dot::Person_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::dot::Party_ptr
dot::Person::someParty ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::dot::Party>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_someParty",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
dot::Person::someParty (
  ::dot::Party_ptr someParty)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::dot::Party>::in_arg_val _tao_someParty (someParty);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_someParty)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_someParty",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
dot::Person::sendc_set_someParty (
  ::dot::AMI_PersonHandler_ptr ami_handler,
  ::dot::Party_ptr someParty)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::dot::Party>::in_arg_val _tao_someParty (someParty);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_someParty)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_someParty",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &dot::AMI_PersonHandler::set_someParty_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
dot::Person::sendc_get_someParty (
  ::dot::AMI_PersonHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_someParty",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &dot::AMI_PersonHandler::get_someParty_reply_stub
    );
}

dot::Person::Person ()
{
}
void
dot::Person::_tao_any_destructor (void *_tao_void_pointer)
{
  Person *_tao_tmp_pointer =
    static_cast<Person *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

dot::Person_ptr
dot::Person::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Person>::narrow (_tao_objref, "IDL:dot/Person:1.0");
}

dot::Person_ptr
dot::Person::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Person>::unchecked_narrow (_tao_objref);
}

dot::Person_ptr
dot::Person::_nil ()
{
  return nullptr;
}

dot::Person_ptr
dot::Person::_duplicate (Person_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
dot::Person::_tao_release (Person_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
dot::Person::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:dot/Person:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* dot::Person::_interface_repository_id () const
{
  return "IDL:dot/Person:1.0";
}

const char* dot::Person::_desc_repository_id ()
{
  return "IDL:dot/Person:1.0";
}

const char* dot::Person::_desc_interface_name ()
{
  return "Person";
}

::CORBA::Boolean
dot::Person::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_dot_Person (
    ::CORBA::tk_objref,
    "IDL:dot/Person:1.0",
    "Person");
  

namespace dot
{
  ::CORBA::TypeCode_ptr const _tc_Person =
    &_tao_tc_dot_Person;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_dot_AMH_PersonExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_dot_AMH_PersonExceptionHolder (
    ::CORBA::tk_value,
    "IDL:dot/AMH_PersonExceptionHolder:1.0",
    "AMH_PersonExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_dot_AMH_PersonExceptionHolder,
    0);
  

namespace dot
{
  ::CORBA::TypeCode_ptr const _tc_AMH_PersonExceptionHolder =
    &_tao_tc_dot_AMH_PersonExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<dot::AMH_PersonExceptionHolder>::add_ref (dot::AMH_PersonExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<dot::AMH_PersonExceptionHolder>::remove_ref (dot::AMH_PersonExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<dot::AMH_PersonExceptionHolder>::release (dot::AMH_PersonExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



dot::AMH_PersonExceptionHolder *
dot::AMH_PersonExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::dot::AMH_PersonExceptionHolder *> (v);
}

const char *
dot::AMH_PersonExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
dot::AMH_PersonExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
dot::AMH_PersonExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_PersonExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_PersonExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr dot::AMH_PersonExceptionHolder::_tao_type () const
{
  return ::dot::_tc_AMH_PersonExceptionHolder;
}

dot::AMH_PersonExceptionHolder::~AMH_PersonExceptionHolder ()
{}

::CORBA::ValueBase *
dot::AMH_PersonExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_PersonExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
dot::AMH_PersonExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
dot::AMH_PersonExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
dot::AMH_PersonExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
dot::AMH_PersonExceptionHolder::_tao_marshal__dot_AMH_PersonExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
dot::AMH_PersonExceptionHolder::_tao_unmarshal__dot_AMH_PersonExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
dot::AMH_PersonExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_PersonExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_PersonExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_PersonExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
dot::AMH_PersonExceptionHolder::raise_get_someParty ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
dot::AMH_PersonExceptionHolder::raise_set_someParty ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
dot::AMH_PersonExceptionHolder::raise_sendc_set_someParty ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
dot::AMH_PersonExceptionHolder::raise_sendc_get_someParty ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for dot::AMH_PersonResponseHandler.

dot::AMH_PersonResponseHandler_ptr
TAO::Objref_Traits<dot::AMH_PersonResponseHandler>::duplicate (dot::AMH_PersonResponseHandler_ptr p)
{
  return dot::AMH_PersonResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<dot::AMH_PersonResponseHandler>::release (dot::AMH_PersonResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

dot::AMH_PersonResponseHandler_ptr
TAO::Objref_Traits<dot::AMH_PersonResponseHandler>::nil ()
{
  return dot::AMH_PersonResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<dot::AMH_PersonResponseHandler>::marshal (const dot::AMH_PersonResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



dot::AMH_PersonResponseHandler::AMH_PersonResponseHandler ()
{}void
dot::AMH_PersonResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_PersonResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_PersonResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

dot::AMH_PersonResponseHandler_ptr
dot::AMH_PersonResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_PersonResponseHandler::_duplicate (
      dynamic_cast<AMH_PersonResponseHandler_ptr> (_tao_objref));
}

dot::AMH_PersonResponseHandler_ptr
dot::AMH_PersonResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_PersonResponseHandler::_duplicate (
      dynamic_cast<AMH_PersonResponseHandler_ptr> (_tao_objref));
}

dot::AMH_PersonResponseHandler_ptr
dot::AMH_PersonResponseHandler::_nil ()
{
  return nullptr;
}

dot::AMH_PersonResponseHandler_ptr
dot::AMH_PersonResponseHandler::_duplicate (AMH_PersonResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
dot::AMH_PersonResponseHandler::_tao_release (AMH_PersonResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
dot::AMH_PersonResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:dot/AMH_PersonResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* dot::AMH_PersonResponseHandler::_interface_repository_id () const
{
  return "IDL:dot/AMH_PersonResponseHandler:1.0";
}

const char* dot::AMH_PersonResponseHandler::_desc_repository_id ()
{
  return "IDL:dot/AMH_PersonResponseHandler:1.0";
}

const char* dot::AMH_PersonResponseHandler::_desc_interface_name ()
{
  return "AMH_PersonResponseHandler";
}

::CORBA::Boolean
dot::AMH_PersonResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_dot_AMH_PersonResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:dot/AMH_PersonResponseHandler:1.0",
    "AMH_PersonResponseHandler");
  

namespace dot
{
  ::CORBA::TypeCode_ptr const _tc_AMH_PersonResponseHandler =
    &_tao_tc_dot_AMH_PersonResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for dot::AMI_PersonHandler.

dot::AMI_PersonHandler_ptr
TAO::Objref_Traits<dot::AMI_PersonHandler>::duplicate (dot::AMI_PersonHandler_ptr p)
{
  return dot::AMI_PersonHandler::_duplicate (p);
}

void
TAO::Objref_Traits<dot::AMI_PersonHandler>::release (dot::AMI_PersonHandler_ptr p)
{
  ::CORBA::release (p);
}

dot::AMI_PersonHandler_ptr
TAO::Objref_Traits<dot::AMI_PersonHandler>::nil ()
{
  return dot::AMI_PersonHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<dot::AMI_PersonHandler>::marshal (const dot::AMI_PersonHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
dot::AMI_PersonHandler::get_someParty (
  ::dot::Party_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::dot::Party>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_someParty",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
dot::AMI_PersonHandler::get_someParty_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  dot::AMI_PersonHandler_var _tao_reply_handler_object =
    dot::AMI_PersonHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::dot::Party_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_someParty (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_someParty_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
dot::AMI_PersonHandler::get_someParty_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_someParty_excep",
      19,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
dot::AMI_PersonHandler::set_someParty ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_someParty",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
dot::AMI_PersonHandler::set_someParty_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  dot::AMI_PersonHandler_var _tao_reply_handler_object =
    dot::AMI_PersonHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_someParty (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_someParty_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
dot::AMI_PersonHandler::set_someParty_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_someParty_excep",
      19,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

dot::AMI_PersonHandler::AMI_PersonHandler ()
{
}
void
dot::AMI_PersonHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_PersonHandler *_tao_tmp_pointer =
    static_cast<AMI_PersonHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

dot::AMI_PersonHandler_ptr
dot::AMI_PersonHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_PersonHandler>::narrow (_tao_objref, "IDL:dot/AMI_PersonHandler:1.0");
}

dot::AMI_PersonHandler_ptr
dot::AMI_PersonHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_PersonHandler>::unchecked_narrow (_tao_objref);
}

dot::AMI_PersonHandler_ptr
dot::AMI_PersonHandler::_nil ()
{
  return nullptr;
}

dot::AMI_PersonHandler_ptr
dot::AMI_PersonHandler::_duplicate (AMI_PersonHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
dot::AMI_PersonHandler::_tao_release (AMI_PersonHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
dot::AMI_PersonHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:dot/AMI_PersonHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* dot::AMI_PersonHandler::_interface_repository_id () const
{
  return "IDL:dot/AMI_PersonHandler:1.0";
}

const char* dot::AMI_PersonHandler::_desc_repository_id ()
{
  return "IDL:dot/AMI_PersonHandler:1.0";
}

const char* dot::AMI_PersonHandler::_desc_interface_name ()
{
  return "AMI_PersonHandler";
}

::CORBA::Boolean
dot::AMI_PersonHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_dot_AMI_PersonHandler (
    ::CORBA::tk_objref,
    "IDL:dot/AMI_PersonHandler:1.0",
    "AMI_PersonHandler");
  

namespace dot
{
  ::CORBA::TypeCode_ptr const _tc_AMI_PersonHandler =
    &_tao_tc_dot_AMI_PersonHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for dot::Party.

dot::Party_ptr
TAO::Objref_Traits<dot::Party>::duplicate (dot::Party_ptr p)
{
  return dot::Party::_duplicate (p);
}

void
TAO::Objref_Traits<dot::Party>::release (dot::Party_ptr p)
{
  ::CORBA::release (p);
}

dot::Party_ptr
TAO::Objref_Traits<dot::Party>::nil ()
{
  return dot::Party::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<dot::Party>::marshal (const dot::Party_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::dot::Person_ptr
dot::Party::somePerson ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::dot::Person>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_somePerson",
      15,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
dot::Party::somePerson (
  ::dot::Person_ptr somePerson)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::dot::Person>::in_arg_val _tao_somePerson (somePerson);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_somePerson)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_somePerson",
      15,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
dot::Party::sendc_set_somePerson (
  ::dot::AMI_PartyHandler_ptr ami_handler,
  ::dot::Person_ptr somePerson)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::dot::Person>::in_arg_val _tao_somePerson (somePerson);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_somePerson)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_somePerson",
      15,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &dot::AMI_PartyHandler::set_somePerson_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
dot::Party::sendc_get_somePerson (
  ::dot::AMI_PartyHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_somePerson",
      15,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &dot::AMI_PartyHandler::get_somePerson_reply_stub
    );
}

dot::Party::Party ()
{
}
void
dot::Party::_tao_any_destructor (void *_tao_void_pointer)
{
  Party *_tao_tmp_pointer =
    static_cast<Party *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

dot::Party_ptr
dot::Party::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Party>::narrow (_tao_objref, "IDL:dot/Party:1.0");
}

dot::Party_ptr
dot::Party::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Party>::unchecked_narrow (_tao_objref);
}

dot::Party_ptr
dot::Party::_nil ()
{
  return nullptr;
}

dot::Party_ptr
dot::Party::_duplicate (Party_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
dot::Party::_tao_release (Party_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
dot::Party::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:dot/Party:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* dot::Party::_interface_repository_id () const
{
  return "IDL:dot/Party:1.0";
}

const char* dot::Party::_desc_repository_id ()
{
  return "IDL:dot/Party:1.0";
}

const char* dot::Party::_desc_interface_name ()
{
  return "Party";
}

::CORBA::Boolean
dot::Party::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_dot_Party (
    ::CORBA::tk_objref,
    "IDL:dot/Party:1.0",
    "Party");
  

namespace dot
{
  ::CORBA::TypeCode_ptr const _tc_Party =
    &_tao_tc_dot_Party;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_dot_AMH_PartyExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_dot_AMH_PartyExceptionHolder (
    ::CORBA::tk_value,
    "IDL:dot/AMH_PartyExceptionHolder:1.0",
    "AMH_PartyExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_dot_AMH_PartyExceptionHolder,
    0);
  

namespace dot
{
  ::CORBA::TypeCode_ptr const _tc_AMH_PartyExceptionHolder =
    &_tao_tc_dot_AMH_PartyExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<dot::AMH_PartyExceptionHolder>::add_ref (dot::AMH_PartyExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<dot::AMH_PartyExceptionHolder>::remove_ref (dot::AMH_PartyExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<dot::AMH_PartyExceptionHolder>::release (dot::AMH_PartyExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



dot::AMH_PartyExceptionHolder *
dot::AMH_PartyExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::dot::AMH_PartyExceptionHolder *> (v);
}

const char *
dot::AMH_PartyExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
dot::AMH_PartyExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
dot::AMH_PartyExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_PartyExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_PartyExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr dot::AMH_PartyExceptionHolder::_tao_type () const
{
  return ::dot::_tc_AMH_PartyExceptionHolder;
}

dot::AMH_PartyExceptionHolder::~AMH_PartyExceptionHolder ()
{}

::CORBA::ValueBase *
dot::AMH_PartyExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_PartyExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
dot::AMH_PartyExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
dot::AMH_PartyExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
dot::AMH_PartyExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
dot::AMH_PartyExceptionHolder::_tao_marshal__dot_AMH_PartyExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
dot::AMH_PartyExceptionHolder::_tao_unmarshal__dot_AMH_PartyExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
dot::AMH_PartyExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_PartyExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_PartyExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_PartyExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
dot::AMH_PartyExceptionHolder::raise_get_somePerson ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
dot::AMH_PartyExceptionHolder::raise_set_somePerson ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
dot::AMH_PartyExceptionHolder::raise_sendc_set_somePerson ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
dot::AMH_PartyExceptionHolder::raise_sendc_get_somePerson ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for dot::AMH_PartyResponseHandler.

dot::AMH_PartyResponseHandler_ptr
TAO::Objref_Traits<dot::AMH_PartyResponseHandler>::duplicate (dot::AMH_PartyResponseHandler_ptr p)
{
  return dot::AMH_PartyResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<dot::AMH_PartyResponseHandler>::release (dot::AMH_PartyResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

dot::AMH_PartyResponseHandler_ptr
TAO::Objref_Traits<dot::AMH_PartyResponseHandler>::nil ()
{
  return dot::AMH_PartyResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<dot::AMH_PartyResponseHandler>::marshal (const dot::AMH_PartyResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



dot::AMH_PartyResponseHandler::AMH_PartyResponseHandler ()
{}void
dot::AMH_PartyResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_PartyResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_PartyResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

dot::AMH_PartyResponseHandler_ptr
dot::AMH_PartyResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_PartyResponseHandler::_duplicate (
      dynamic_cast<AMH_PartyResponseHandler_ptr> (_tao_objref));
}

dot::AMH_PartyResponseHandler_ptr
dot::AMH_PartyResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_PartyResponseHandler::_duplicate (
      dynamic_cast<AMH_PartyResponseHandler_ptr> (_tao_objref));
}

dot::AMH_PartyResponseHandler_ptr
dot::AMH_PartyResponseHandler::_nil ()
{
  return nullptr;
}

dot::AMH_PartyResponseHandler_ptr
dot::AMH_PartyResponseHandler::_duplicate (AMH_PartyResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
dot::AMH_PartyResponseHandler::_tao_release (AMH_PartyResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
dot::AMH_PartyResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:dot/AMH_PartyResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* dot::AMH_PartyResponseHandler::_interface_repository_id () const
{
  return "IDL:dot/AMH_PartyResponseHandler:1.0";
}

const char* dot::AMH_PartyResponseHandler::_desc_repository_id ()
{
  return "IDL:dot/AMH_PartyResponseHandler:1.0";
}

const char* dot::AMH_PartyResponseHandler::_desc_interface_name ()
{
  return "AMH_PartyResponseHandler";
}

::CORBA::Boolean
dot::AMH_PartyResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_dot_AMH_PartyResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:dot/AMH_PartyResponseHandler:1.0",
    "AMH_PartyResponseHandler");
  

namespace dot
{
  ::CORBA::TypeCode_ptr const _tc_AMH_PartyResponseHandler =
    &_tao_tc_dot_AMH_PartyResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for dot::AMI_PartyHandler.

dot::AMI_PartyHandler_ptr
TAO::Objref_Traits<dot::AMI_PartyHandler>::duplicate (dot::AMI_PartyHandler_ptr p)
{
  return dot::AMI_PartyHandler::_duplicate (p);
}

void
TAO::Objref_Traits<dot::AMI_PartyHandler>::release (dot::AMI_PartyHandler_ptr p)
{
  ::CORBA::release (p);
}

dot::AMI_PartyHandler_ptr
TAO::Objref_Traits<dot::AMI_PartyHandler>::nil ()
{
  return dot::AMI_PartyHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<dot::AMI_PartyHandler>::marshal (const dot::AMI_PartyHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
dot::AMI_PartyHandler::get_somePerson (
  ::dot::Person_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::dot::Person>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_somePerson",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
dot::AMI_PartyHandler::get_somePerson_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  dot::AMI_PartyHandler_var _tao_reply_handler_object =
    dot::AMI_PartyHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::dot::Person_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_somePerson (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_somePerson_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
dot::AMI_PartyHandler::get_somePerson_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_somePerson_excep",
      20,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
dot::AMI_PartyHandler::set_somePerson ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_somePerson",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
dot::AMI_PartyHandler::set_somePerson_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  dot::AMI_PartyHandler_var _tao_reply_handler_object =
    dot::AMI_PartyHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_somePerson (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_somePerson_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
dot::AMI_PartyHandler::set_somePerson_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_somePerson_excep",
      20,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

dot::AMI_PartyHandler::AMI_PartyHandler ()
{
}
void
dot::AMI_PartyHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_PartyHandler *_tao_tmp_pointer =
    static_cast<AMI_PartyHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

dot::AMI_PartyHandler_ptr
dot::AMI_PartyHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_PartyHandler>::narrow (_tao_objref, "IDL:dot/AMI_PartyHandler:1.0");
}

dot::AMI_PartyHandler_ptr
dot::AMI_PartyHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_PartyHandler>::unchecked_narrow (_tao_objref);
}

dot::AMI_PartyHandler_ptr
dot::AMI_PartyHandler::_nil ()
{
  return nullptr;
}

dot::AMI_PartyHandler_ptr
dot::AMI_PartyHandler::_duplicate (AMI_PartyHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
dot::AMI_PartyHandler::_tao_release (AMI_PartyHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
dot::AMI_PartyHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:dot/AMI_PartyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* dot::AMI_PartyHandler::_interface_repository_id () const
{
  return "IDL:dot/AMI_PartyHandler:1.0";
}

const char* dot::AMI_PartyHandler::_desc_repository_id ()
{
  return "IDL:dot/AMI_PartyHandler:1.0";
}

const char* dot::AMI_PartyHandler::_desc_interface_name ()
{
  return "AMI_PartyHandler";
}

::CORBA::Boolean
dot::AMI_PartyHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_dot_AMI_PartyHandler (
    ::CORBA::tk_objref,
    "IDL:dot/AMI_PartyHandler:1.0",
    "AMI_PartyHandler");
  

namespace dot
{
  ::CORBA::TypeCode_ptr const _tc_AMI_PartyHandler =
    &_tao_tc_dot_AMI_PartyHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Outside_Reopened_Tricky (
    ::CORBA::tk_alias,
    "IDL:Outside/Reopened/Tricky:1.0",
    "Tricky",
    &CORBA::_tc_short);
  

namespace Outside
{
  
  namespace Reopened
  {
    ::CORBA::TypeCode_ptr const _tc_Tricky =
      &_tao_tc_Outside_Reopened_Tricky;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Outside_Tricky (
    ::CORBA::tk_alias,
    "IDL:Outside/Tricky:1.0",
    "Tricky",
    &CORBA::_tc_long);
  

namespace Outside
{
  ::CORBA::TypeCode_ptr const _tc_Tricky =
    &_tao_tc_Outside_Tricky;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Outside_Reopened_Newdef (
    ::CORBA::tk_alias,
    "IDL:Outside/Reopened/Newdef:1.0",
    "Newdef",
    &CORBA::_tc_float);
  

namespace Outside
{
  
  namespace Reopened
  {
    ::CORBA::TypeCode_ptr const _tc_Newdef =
      &_tao_tc_Outside_Reopened_Newdef;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for OpHolder.

OpHolder_ptr
TAO::Objref_Traits<OpHolder>::duplicate (OpHolder_ptr p)
{
  return OpHolder::_duplicate (p);
}

void
TAO::Objref_Traits<OpHolder>::release (OpHolder_ptr p)
{
  ::CORBA::release (p);
}

OpHolder_ptr
TAO::Objref_Traits<OpHolder>::nil ()
{
  return OpHolder::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<OpHolder>::marshal (const OpHolder_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
OpHolder::Operation (
  ::Outside::Tricky p1,
  ::Outside::Reopened::Tricky_out p2,
  ::Outside::Reopened::Newdef & p3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_p1 (p1);
  TAO::Arg_Traits< ::CORBA::Short>::out_arg_val _tao_p2 (p2);
  TAO::Arg_Traits< ::CORBA::Float>::inout_arg_val _tao_p3 (p3);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_p1),
      std::addressof(_tao_p2),
      std::addressof(_tao_p3)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      4,
      "Operation",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
OpHolder::sendc_Operation (
  ::AMI_OpHolderHandler_ptr ami_handler,
  ::Outside::Tricky p1,
  ::Outside::Reopened::Newdef p3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_p1 (p1);
  TAO::Arg_Traits< ::CORBA::Float>::in_arg_val _tao_p3 (p3);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_p1),
      std::addressof(_tao_p3)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      3,
      "Operation",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_OpHolderHandler::Operation_reply_stub
    );
}

OpHolder::OpHolder ()
{
}
void
OpHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  OpHolder *_tao_tmp_pointer =
    static_cast<OpHolder *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

OpHolder_ptr
OpHolder::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<OpHolder>::narrow (_tao_objref, "IDL:OpHolder:1.0");
}

OpHolder_ptr
OpHolder::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<OpHolder>::unchecked_narrow (_tao_objref);
}

OpHolder_ptr
OpHolder::_nil ()
{
  return nullptr;
}

OpHolder_ptr
OpHolder::_duplicate (OpHolder_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
OpHolder::_tao_release (OpHolder_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
OpHolder::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:OpHolder:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* OpHolder::_interface_repository_id () const
{
  return "IDL:OpHolder:1.0";
}

const char* OpHolder::_desc_repository_id ()
{
  return "IDL:OpHolder:1.0";
}

const char* OpHolder::_desc_interface_name ()
{
  return "OpHolder";
}

::CORBA::Boolean
OpHolder::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_OpHolder (
    ::CORBA::tk_objref,
    "IDL:OpHolder:1.0",
    "OpHolder");
  
::CORBA::TypeCode_ptr const _tc_OpHolder =
  &_tao_tc_OpHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_OpHolderExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_OpHolderExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_OpHolderExceptionHolder:1.0",
    "AMH_OpHolderExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_OpHolderExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_OpHolderExceptionHolder =
  &_tao_tc_AMH_OpHolderExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_OpHolderExceptionHolder>::add_ref (AMH_OpHolderExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_OpHolderExceptionHolder>::remove_ref (AMH_OpHolderExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_OpHolderExceptionHolder>::release (AMH_OpHolderExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_OpHolderExceptionHolder *
AMH_OpHolderExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_OpHolderExceptionHolder *> (v);
}

const char *
AMH_OpHolderExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_OpHolderExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_OpHolderExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_OpHolderExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_OpHolderExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_OpHolderExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_OpHolderExceptionHolder;
}

AMH_OpHolderExceptionHolder::~AMH_OpHolderExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_OpHolderExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_OpHolderExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_OpHolderExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_OpHolderExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_OpHolderExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_OpHolderExceptionHolder::_tao_marshal__AMH_OpHolderExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_OpHolderExceptionHolder::_tao_unmarshal__AMH_OpHolderExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_OpHolderExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_OpHolderExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_OpHolderExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_OpHolderExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_OpHolderExceptionHolder::raise_Operation ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_OpHolderExceptionHolder::raise_sendc_Operation ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_OpHolderResponseHandler.

AMH_OpHolderResponseHandler_ptr
TAO::Objref_Traits<AMH_OpHolderResponseHandler>::duplicate (AMH_OpHolderResponseHandler_ptr p)
{
  return AMH_OpHolderResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_OpHolderResponseHandler>::release (AMH_OpHolderResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_OpHolderResponseHandler_ptr
TAO::Objref_Traits<AMH_OpHolderResponseHandler>::nil ()
{
  return AMH_OpHolderResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_OpHolderResponseHandler>::marshal (const AMH_OpHolderResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_OpHolderResponseHandler::AMH_OpHolderResponseHandler ()
{}void
AMH_OpHolderResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_OpHolderResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_OpHolderResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_OpHolderResponseHandler_ptr
AMH_OpHolderResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_OpHolderResponseHandler::_duplicate (
      dynamic_cast<AMH_OpHolderResponseHandler_ptr> (_tao_objref));
}

AMH_OpHolderResponseHandler_ptr
AMH_OpHolderResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_OpHolderResponseHandler::_duplicate (
      dynamic_cast<AMH_OpHolderResponseHandler_ptr> (_tao_objref));
}

AMH_OpHolderResponseHandler_ptr
AMH_OpHolderResponseHandler::_nil ()
{
  return nullptr;
}

AMH_OpHolderResponseHandler_ptr
AMH_OpHolderResponseHandler::_duplicate (AMH_OpHolderResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_OpHolderResponseHandler::_tao_release (AMH_OpHolderResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_OpHolderResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_OpHolderResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_OpHolderResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_OpHolderResponseHandler:1.0";
}

const char* AMH_OpHolderResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_OpHolderResponseHandler:1.0";
}

const char* AMH_OpHolderResponseHandler::_desc_interface_name ()
{
  return "AMH_OpHolderResponseHandler";
}

::CORBA::Boolean
AMH_OpHolderResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_OpHolderResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_OpHolderResponseHandler:1.0",
    "AMH_OpHolderResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_OpHolderResponseHandler =
  &_tao_tc_AMH_OpHolderResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_OpHolderHandler.

AMI_OpHolderHandler_ptr
TAO::Objref_Traits<AMI_OpHolderHandler>::duplicate (AMI_OpHolderHandler_ptr p)
{
  return AMI_OpHolderHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_OpHolderHandler>::release (AMI_OpHolderHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_OpHolderHandler_ptr
TAO::Objref_Traits<AMI_OpHolderHandler>::nil ()
{
  return AMI_OpHolderHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_OpHolderHandler>::marshal (const AMI_OpHolderHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_OpHolderHandler::Operation (
  ::Outside::Reopened::Tricky p2,
  ::Outside::Reopened::Newdef p3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Short>::in_arg_val _tao_p2 (p2);
  TAO::Arg_Traits< ::CORBA::Float>::in_arg_val _tao_p3 (p3);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_p2),
      std::addressof(_tao_p3)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      3,
      "Operation",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_OpHolderHandler::Operation_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_OpHolderHandler_var _tao_reply_handler_object =
    AMI_OpHolderHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::Outside::Reopened::Tricky p2;
      ::Outside::Reopened::Newdef p3;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> p2) &&
            (_tao_in >> p3)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->Operation (
          
          p2,
          
          p3
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->Operation_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_OpHolderHandler::Operation_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "Operation_excep",
      15,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

AMI_OpHolderHandler::AMI_OpHolderHandler ()
{
}
void
AMI_OpHolderHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_OpHolderHandler *_tao_tmp_pointer =
    static_cast<AMI_OpHolderHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_OpHolderHandler_ptr
AMI_OpHolderHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_OpHolderHandler>::narrow (_tao_objref, "IDL:AMI_OpHolderHandler:1.0");
}

AMI_OpHolderHandler_ptr
AMI_OpHolderHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_OpHolderHandler>::unchecked_narrow (_tao_objref);
}

AMI_OpHolderHandler_ptr
AMI_OpHolderHandler::_nil ()
{
  return nullptr;
}

AMI_OpHolderHandler_ptr
AMI_OpHolderHandler::_duplicate (AMI_OpHolderHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_OpHolderHandler::_tao_release (AMI_OpHolderHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_OpHolderHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_OpHolderHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_OpHolderHandler::_interface_repository_id () const
{
  return "IDL:AMI_OpHolderHandler:1.0";
}

const char* AMI_OpHolderHandler::_desc_repository_id ()
{
  return "IDL:AMI_OpHolderHandler:1.0";
}

const char* AMI_OpHolderHandler::_desc_interface_name ()
{
  return "AMI_OpHolderHandler";
}

::CORBA::Boolean
AMI_OpHolderHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_OpHolderHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_OpHolderHandler:1.0",
    "AMI_OpHolderHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_OpHolderHandler =
  &_tao_tc_AMI_OpHolderHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_com_mr_info (
    ::CORBA::tk_alias,
    "IDL:com/mr/info:1.0",
    "info",
    &CORBA::_tc_short);
  

namespace com
{
  
  namespace mr
  {
    ::CORBA::TypeCode_ptr const _tc_info =
      &_tao_tc_com_mr_info;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for com::IFace.

com::IFace_ptr
TAO::Objref_Traits<com::IFace>::duplicate (com::IFace_ptr p)
{
  return com::IFace::_duplicate (p);
}

void
TAO::Objref_Traits<com::IFace>::release (com::IFace_ptr p)
{
  ::CORBA::release (p);
}

com::IFace_ptr
TAO::Objref_Traits<com::IFace>::nil ()
{
  return com::IFace::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<com::IFace>::marshal (const com::IFace_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::com::mr::info
com::IFace::getInfo ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::CORBA::Short>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "getInfo",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
com::IFace::sendc_getInfo (
  ::com::AMI_IFaceHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "getInfo",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &com::AMI_IFaceHandler::getInfo_reply_stub
    );
}

com::IFace::IFace ()
{
}
void
com::IFace::_tao_any_destructor (void *_tao_void_pointer)
{
  IFace *_tao_tmp_pointer =
    static_cast<IFace *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

com::IFace_ptr
com::IFace::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<IFace>::narrow (_tao_objref, "IDL:com/IFace:1.0");
}

com::IFace_ptr
com::IFace::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<IFace>::unchecked_narrow (_tao_objref);
}

com::IFace_ptr
com::IFace::_nil ()
{
  return nullptr;
}

com::IFace_ptr
com::IFace::_duplicate (IFace_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
com::IFace::_tao_release (IFace_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
com::IFace::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:com/IFace:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* com::IFace::_interface_repository_id () const
{
  return "IDL:com/IFace:1.0";
}

const char* com::IFace::_desc_repository_id ()
{
  return "IDL:com/IFace:1.0";
}

const char* com::IFace::_desc_interface_name ()
{
  return "IFace";
}

::CORBA::Boolean
com::IFace::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_com_IFace (
    ::CORBA::tk_objref,
    "IDL:com/IFace:1.0",
    "IFace");
  

namespace com
{
  ::CORBA::TypeCode_ptr const _tc_IFace =
    &_tao_tc_com_IFace;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_com_AMH_IFaceExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_com_AMH_IFaceExceptionHolder (
    ::CORBA::tk_value,
    "IDL:com/AMH_IFaceExceptionHolder:1.0",
    "AMH_IFaceExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_com_AMH_IFaceExceptionHolder,
    0);
  

namespace com
{
  ::CORBA::TypeCode_ptr const _tc_AMH_IFaceExceptionHolder =
    &_tao_tc_com_AMH_IFaceExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<com::AMH_IFaceExceptionHolder>::add_ref (com::AMH_IFaceExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<com::AMH_IFaceExceptionHolder>::remove_ref (com::AMH_IFaceExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<com::AMH_IFaceExceptionHolder>::release (com::AMH_IFaceExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



com::AMH_IFaceExceptionHolder *
com::AMH_IFaceExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::com::AMH_IFaceExceptionHolder *> (v);
}

const char *
com::AMH_IFaceExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
com::AMH_IFaceExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
com::AMH_IFaceExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_IFaceExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_IFaceExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr com::AMH_IFaceExceptionHolder::_tao_type () const
{
  return ::com::_tc_AMH_IFaceExceptionHolder;
}

com::AMH_IFaceExceptionHolder::~AMH_IFaceExceptionHolder ()
{}

::CORBA::ValueBase *
com::AMH_IFaceExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_IFaceExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
com::AMH_IFaceExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
com::AMH_IFaceExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
com::AMH_IFaceExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
com::AMH_IFaceExceptionHolder::_tao_marshal__com_AMH_IFaceExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
com::AMH_IFaceExceptionHolder::_tao_unmarshal__com_AMH_IFaceExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
com::AMH_IFaceExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_IFaceExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_IFaceExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_IFaceExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
com::AMH_IFaceExceptionHolder::raise_getInfo ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
com::AMH_IFaceExceptionHolder::raise_sendc_getInfo ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for com::AMH_IFaceResponseHandler.

com::AMH_IFaceResponseHandler_ptr
TAO::Objref_Traits<com::AMH_IFaceResponseHandler>::duplicate (com::AMH_IFaceResponseHandler_ptr p)
{
  return com::AMH_IFaceResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<com::AMH_IFaceResponseHandler>::release (com::AMH_IFaceResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

com::AMH_IFaceResponseHandler_ptr
TAO::Objref_Traits<com::AMH_IFaceResponseHandler>::nil ()
{
  return com::AMH_IFaceResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<com::AMH_IFaceResponseHandler>::marshal (const com::AMH_IFaceResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



com::AMH_IFaceResponseHandler::AMH_IFaceResponseHandler ()
{}void
com::AMH_IFaceResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_IFaceResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_IFaceResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

com::AMH_IFaceResponseHandler_ptr
com::AMH_IFaceResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_IFaceResponseHandler::_duplicate (
      dynamic_cast<AMH_IFaceResponseHandler_ptr> (_tao_objref));
}

com::AMH_IFaceResponseHandler_ptr
com::AMH_IFaceResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_IFaceResponseHandler::_duplicate (
      dynamic_cast<AMH_IFaceResponseHandler_ptr> (_tao_objref));
}

com::AMH_IFaceResponseHandler_ptr
com::AMH_IFaceResponseHandler::_nil ()
{
  return nullptr;
}

com::AMH_IFaceResponseHandler_ptr
com::AMH_IFaceResponseHandler::_duplicate (AMH_IFaceResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
com::AMH_IFaceResponseHandler::_tao_release (AMH_IFaceResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
com::AMH_IFaceResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:com/AMH_IFaceResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* com::AMH_IFaceResponseHandler::_interface_repository_id () const
{
  return "IDL:com/AMH_IFaceResponseHandler:1.0";
}

const char* com::AMH_IFaceResponseHandler::_desc_repository_id ()
{
  return "IDL:com/AMH_IFaceResponseHandler:1.0";
}

const char* com::AMH_IFaceResponseHandler::_desc_interface_name ()
{
  return "AMH_IFaceResponseHandler";
}

::CORBA::Boolean
com::AMH_IFaceResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_com_AMH_IFaceResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:com/AMH_IFaceResponseHandler:1.0",
    "AMH_IFaceResponseHandler");
  

namespace com
{
  ::CORBA::TypeCode_ptr const _tc_AMH_IFaceResponseHandler =
    &_tao_tc_com_AMH_IFaceResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for com::AMI_IFaceHandler.

com::AMI_IFaceHandler_ptr
TAO::Objref_Traits<com::AMI_IFaceHandler>::duplicate (com::AMI_IFaceHandler_ptr p)
{
  return com::AMI_IFaceHandler::_duplicate (p);
}

void
TAO::Objref_Traits<com::AMI_IFaceHandler>::release (com::AMI_IFaceHandler_ptr p)
{
  ::CORBA::release (p);
}

com::AMI_IFaceHandler_ptr
TAO::Objref_Traits<com::AMI_IFaceHandler>::nil ()
{
  return com::AMI_IFaceHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<com::AMI_IFaceHandler>::marshal (const com::AMI_IFaceHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
com::AMI_IFaceHandler::getInfo (
  ::com::mr::info ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Short>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getInfo",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
com::AMI_IFaceHandler::getInfo_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  com::AMI_IFaceHandler_var _tao_reply_handler_object =
    com::AMI_IFaceHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::com::mr::info ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->getInfo (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->getInfo_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
com::AMI_IFaceHandler::getInfo_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getInfo_excep",
      13,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

com::AMI_IFaceHandler::AMI_IFaceHandler ()
{
}
void
com::AMI_IFaceHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_IFaceHandler *_tao_tmp_pointer =
    static_cast<AMI_IFaceHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

com::AMI_IFaceHandler_ptr
com::AMI_IFaceHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_IFaceHandler>::narrow (_tao_objref, "IDL:com/AMI_IFaceHandler:1.0");
}

com::AMI_IFaceHandler_ptr
com::AMI_IFaceHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_IFaceHandler>::unchecked_narrow (_tao_objref);
}

com::AMI_IFaceHandler_ptr
com::AMI_IFaceHandler::_nil ()
{
  return nullptr;
}

com::AMI_IFaceHandler_ptr
com::AMI_IFaceHandler::_duplicate (AMI_IFaceHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
com::AMI_IFaceHandler::_tao_release (AMI_IFaceHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
com::AMI_IFaceHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:com/AMI_IFaceHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* com::AMI_IFaceHandler::_interface_repository_id () const
{
  return "IDL:com/AMI_IFaceHandler:1.0";
}

const char* com::AMI_IFaceHandler::_desc_repository_id ()
{
  return "IDL:com/AMI_IFaceHandler:1.0";
}

const char* com::AMI_IFaceHandler::_desc_interface_name ()
{
  return "AMI_IFaceHandler";
}

::CORBA::Boolean
com::AMI_IFaceHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_com_AMI_IFaceHandler (
    ::CORBA::tk_objref,
    "IDL:com/AMI_IFaceHandler:1.0",
    "AMI_IFaceHandler");
  

namespace com
{
  ::CORBA::TypeCode_ptr const _tc_AMI_IFaceHandler =
    &_tao_tc_com_AMI_IFaceHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Y::Z.

Y::Z_ptr
TAO::Objref_Traits<Y::Z>::duplicate (Y::Z_ptr p)
{
  return Y::Z::_duplicate (p);
}

void
TAO::Objref_Traits<Y::Z>::release (Y::Z_ptr p)
{
  ::CORBA::release (p);
}

Y::Z_ptr
TAO::Objref_Traits<Y::Z>::nil ()
{
  return Y::Z::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Y::Z>::marshal (const Y::Z_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Y::Z::Z ()
{
}
void
Y::Z::_tao_any_destructor (void *_tao_void_pointer)
{
  Z *_tao_tmp_pointer =
    static_cast<Z *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Y::Z_ptr
Y::Z::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Z>::narrow (_tao_objref, "IDL:Y/Z:1.0");
}

Y::Z_ptr
Y::Z::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Z>::unchecked_narrow (_tao_objref);
}

Y::Z_ptr
Y::Z::_nil ()
{
  return nullptr;
}

Y::Z_ptr
Y::Z::_duplicate (Z_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Y::Z::_tao_release (Z_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Y::Z::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Y/Z:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Y::Z::_interface_repository_id () const
{
  return "IDL:Y/Z:1.0";
}

const char* Y::Z::_desc_repository_id ()
{
  return "IDL:Y/Z:1.0";
}

const char* Y::Z::_desc_interface_name ()
{
  return "Z";
}

::CORBA::Boolean
Y::Z::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Y_Z (
    ::CORBA::tk_objref,
    "IDL:Y/Z:1.0",
    "Z");
  

namespace Y
{
  ::CORBA::TypeCode_ptr const _tc_Z =
    &_tao_tc_Y_Z;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_Y_AMH_ZExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_Y_AMH_ZExceptionHolder (
    ::CORBA::tk_value,
    "IDL:Y/AMH_ZExceptionHolder:1.0",
    "AMH_ZExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Y_AMH_ZExceptionHolder,
    0);
  

namespace Y
{
  ::CORBA::TypeCode_ptr const _tc_AMH_ZExceptionHolder =
    &_tao_tc_Y_AMH_ZExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<Y::AMH_ZExceptionHolder>::add_ref (Y::AMH_ZExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Y::AMH_ZExceptionHolder>::remove_ref (Y::AMH_ZExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Y::AMH_ZExceptionHolder>::release (Y::AMH_ZExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Y::AMH_ZExceptionHolder *
Y::AMH_ZExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::Y::AMH_ZExceptionHolder *> (v);
}

const char *
Y::AMH_ZExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
Y::AMH_ZExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Y::AMH_ZExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_ZExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_ZExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Y::AMH_ZExceptionHolder::_tao_type () const
{
  return ::Y::_tc_AMH_ZExceptionHolder;
}

Y::AMH_ZExceptionHolder::~AMH_ZExceptionHolder ()
{}

::CORBA::ValueBase *
Y::AMH_ZExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_ZExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
Y::AMH_ZExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
Y::AMH_ZExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
Y::AMH_ZExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
Y::AMH_ZExceptionHolder::_tao_marshal__Y_AMH_ZExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
Y::AMH_ZExceptionHolder::_tao_unmarshal__Y_AMH_ZExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
Y::AMH_ZExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_ZExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_ZExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_ZExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



Y::AMH_ZExceptionHolder_init::AMH_ZExceptionHolder_init ()
{
}

Y::AMH_ZExceptionHolder_init::~AMH_ZExceptionHolder_init ()
{
}

Y::AMH_ZExceptionHolder_init *
Y::AMH_ZExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::Y::AMH_ZExceptionHolder_init *> (v);
}

const char*
Y::AMH_ZExceptionHolder_init::tao_repository_id ()
{
  return ::Y::AMH_ZExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
Y::AMH_ZExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_Y::AMH_ZExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Y::AMH_ZResponseHandler.

Y::AMH_ZResponseHandler_ptr
TAO::Objref_Traits<Y::AMH_ZResponseHandler>::duplicate (Y::AMH_ZResponseHandler_ptr p)
{
  return Y::AMH_ZResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Y::AMH_ZResponseHandler>::release (Y::AMH_ZResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

Y::AMH_ZResponseHandler_ptr
TAO::Objref_Traits<Y::AMH_ZResponseHandler>::nil ()
{
  return Y::AMH_ZResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Y::AMH_ZResponseHandler>::marshal (const Y::AMH_ZResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Y::AMH_ZResponseHandler::AMH_ZResponseHandler ()
{}void
Y::AMH_ZResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_ZResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_ZResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Y::AMH_ZResponseHandler_ptr
Y::AMH_ZResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_ZResponseHandler::_duplicate (
      dynamic_cast<AMH_ZResponseHandler_ptr> (_tao_objref));
}

Y::AMH_ZResponseHandler_ptr
Y::AMH_ZResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_ZResponseHandler::_duplicate (
      dynamic_cast<AMH_ZResponseHandler_ptr> (_tao_objref));
}

Y::AMH_ZResponseHandler_ptr
Y::AMH_ZResponseHandler::_nil ()
{
  return nullptr;
}

Y::AMH_ZResponseHandler_ptr
Y::AMH_ZResponseHandler::_duplicate (AMH_ZResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Y::AMH_ZResponseHandler::_tao_release (AMH_ZResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Y::AMH_ZResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Y/AMH_ZResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* Y::AMH_ZResponseHandler::_interface_repository_id () const
{
  return "IDL:Y/AMH_ZResponseHandler:1.0";
}

const char* Y::AMH_ZResponseHandler::_desc_repository_id ()
{
  return "IDL:Y/AMH_ZResponseHandler:1.0";
}

const char* Y::AMH_ZResponseHandler::_desc_interface_name ()
{
  return "AMH_ZResponseHandler";
}

::CORBA::Boolean
Y::AMH_ZResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Y_AMH_ZResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:Y/AMH_ZResponseHandler:1.0",
    "AMH_ZResponseHandler");
  

namespace Y
{
  ::CORBA::TypeCode_ptr const _tc_AMH_ZResponseHandler =
    &_tao_tc_Y_AMH_ZResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Y::AMI_ZHandler.

Y::AMI_ZHandler_ptr
TAO::Objref_Traits<Y::AMI_ZHandler>::duplicate (Y::AMI_ZHandler_ptr p)
{
  return Y::AMI_ZHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Y::AMI_ZHandler>::release (Y::AMI_ZHandler_ptr p)
{
  ::CORBA::release (p);
}

Y::AMI_ZHandler_ptr
TAO::Objref_Traits<Y::AMI_ZHandler>::nil ()
{
  return Y::AMI_ZHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Y::AMI_ZHandler>::marshal (const Y::AMI_ZHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Y::AMI_ZHandler::AMI_ZHandler ()
{
}
void
Y::AMI_ZHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_ZHandler *_tao_tmp_pointer =
    static_cast<AMI_ZHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Y::AMI_ZHandler_ptr
Y::AMI_ZHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_ZHandler>::narrow (_tao_objref, "IDL:Y/AMI_ZHandler:1.0");
}

Y::AMI_ZHandler_ptr
Y::AMI_ZHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_ZHandler>::unchecked_narrow (_tao_objref);
}

Y::AMI_ZHandler_ptr
Y::AMI_ZHandler::_nil ()
{
  return nullptr;
}

Y::AMI_ZHandler_ptr
Y::AMI_ZHandler::_duplicate (AMI_ZHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Y::AMI_ZHandler::_tao_release (AMI_ZHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Y::AMI_ZHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:Y/AMI_ZHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Y::AMI_ZHandler::_interface_repository_id () const
{
  return "IDL:Y/AMI_ZHandler:1.0";
}

const char* Y::AMI_ZHandler::_desc_repository_id ()
{
  return "IDL:Y/AMI_ZHandler:1.0";
}

const char* Y::AMI_ZHandler::_desc_interface_name ()
{
  return "AMI_ZHandler";
}

::CORBA::Boolean
Y::AMI_ZHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Y_AMI_ZHandler (
    ::CORBA::tk_objref,
    "IDL:Y/AMI_ZHandler:1.0",
    "AMI_ZHandler");
  

namespace Y
{
  ::CORBA::TypeCode_ptr const _tc_AMI_ZHandler =
    &_tao_tc_Y_AMI_ZHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/exception_cs.cpp:97

X::Ex::Ex ()
  : ::CORBA::UserException (
        "IDL:X/Ex:1.0",
        "Ex")
{
}

X::Ex::Ex (const ::X::Ex &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ())
{
}

X::Ex&
X::Ex::operator= (const ::X::Ex &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void X::Ex::_tao_any_destructor (void *_tao_void_pointer)
{
  Ex *_tao_tmp_pointer =
    static_cast<Ex *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

X::Ex *
X::Ex::_downcast (::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<Ex *> (_tao_excp);
}

const X::Ex *
X::Ex::_downcast (::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const Ex *> (_tao_excp);
}

::CORBA::Exception *X::Ex::_alloc ()
{
  ::CORBA::Exception *retval {};
  ACE_NEW_RETURN (retval, ::X::Ex, nullptr);
  return retval;
}

::CORBA::Exception *
X::Ex::_tao_duplicate () const
{
  ::CORBA::Exception *result {};
  ACE_NEW_RETURN (result, ::X::Ex (*this), nullptr);
  return result;
}

void X::Ex::_raise () const
{
  throw *this;
}

void X::Ex::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void X::Ex::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr X::Ex::_tao_type () const
{
  return ::X::_tc_Ex;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_X_Ex = nullptr;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_X_Ex (
  ::CORBA::tk_except,
  "IDL:X/Ex:1.0",
  "Ex",
  _tao_fields_X_Ex,
  0);


namespace X
{
  ::CORBA::TypeCode_ptr const _tc_Ex =
    &_tao_tc_X_Ex;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for X::BI.

X::BI_ptr
TAO::Objref_Traits<X::BI>::duplicate (X::BI_ptr p)
{
  return X::BI::_duplicate (p);
}

void
TAO::Objref_Traits<X::BI>::release (X::BI_ptr p)
{
  ::CORBA::release (p);
}

X::BI_ptr
TAO::Objref_Traits<X::BI>::nil ()
{
  return X::BI::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<X::BI>::marshal (const X::BI_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
X::BI::method ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  static TAO::Exception_Data
  _tao_X_BI_method_exceptiondata [] = 
    {
      {
        "IDL:X/Ex:1.0",
        X::Ex::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , X::_tc_Ex
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "method",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (
      _tao_X_BI_method_exceptiondata,
      1
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
X::BI::sendc_method (
  ::X::AMI_BIHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "method",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &X::AMI_BIHandler::method_reply_stub
    );
}

X::BI::BI ()
{
}
void
X::BI::_tao_any_destructor (void *_tao_void_pointer)
{
  BI *_tao_tmp_pointer =
    static_cast<BI *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

X::BI_ptr
X::BI::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<BI>::narrow (_tao_objref, "IDL:X/BI:1.0");
}

X::BI_ptr
X::BI::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<BI>::unchecked_narrow (_tao_objref);
}

X::BI_ptr
X::BI::_nil ()
{
  return nullptr;
}

X::BI_ptr
X::BI::_duplicate (BI_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
X::BI::_tao_release (BI_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
X::BI::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Y/Z:1.0") == 0 ||
      std::strcmp (value, "IDL:X/BI:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* X::BI::_interface_repository_id () const
{
  return "IDL:X/BI:1.0";
}

const char* X::BI::_desc_repository_id ()
{
  return "IDL:X/BI:1.0";
}

const char* X::BI::_desc_interface_name ()
{
  return "BI";
}

::CORBA::Boolean
X::BI::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_X_BI (
    ::CORBA::tk_objref,
    "IDL:X/BI:1.0",
    "BI");
  

namespace X
{
  ::CORBA::TypeCode_ptr const _tc_BI =
    &_tao_tc_X_BI;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_X_AMH_BIExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_X_AMH_BIExceptionHolder (
    ::CORBA::tk_value,
    "IDL:X/AMH_BIExceptionHolder:1.0",
    "AMH_BIExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_X_AMH_BIExceptionHolder,
    0);
  

namespace X
{
  ::CORBA::TypeCode_ptr const _tc_AMH_BIExceptionHolder =
    &_tao_tc_X_AMH_BIExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<X::AMH_BIExceptionHolder>::add_ref (X::AMH_BIExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<X::AMH_BIExceptionHolder>::remove_ref (X::AMH_BIExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<X::AMH_BIExceptionHolder>::release (X::AMH_BIExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



X::AMH_BIExceptionHolder *
X::AMH_BIExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::X::AMH_BIExceptionHolder *> (v);
}

const char *
X::AMH_BIExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
X::AMH_BIExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
X::AMH_BIExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BIExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_BIExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr X::AMH_BIExceptionHolder::_tao_type () const
{
  return ::X::_tc_AMH_BIExceptionHolder;
}

X::AMH_BIExceptionHolder::~AMH_BIExceptionHolder ()
{}

::CORBA::ValueBase *
X::AMH_BIExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_BIExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
X::AMH_BIExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
X::AMH_BIExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
X::AMH_BIExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
X::AMH_BIExceptionHolder::_tao_marshal__X_AMH_BIExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
X::AMH_BIExceptionHolder::_tao_unmarshal__X_AMH_BIExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
X::AMH_BIExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_BIExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_BIExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_BIExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
X::AMH_BIExceptionHolder::raise_method ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
X::AMH_BIExceptionHolder::raise_sendc_method ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for X::AMH_BIResponseHandler.

X::AMH_BIResponseHandler_ptr
TAO::Objref_Traits<X::AMH_BIResponseHandler>::duplicate (X::AMH_BIResponseHandler_ptr p)
{
  return X::AMH_BIResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<X::AMH_BIResponseHandler>::release (X::AMH_BIResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

X::AMH_BIResponseHandler_ptr
TAO::Objref_Traits<X::AMH_BIResponseHandler>::nil ()
{
  return X::AMH_BIResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<X::AMH_BIResponseHandler>::marshal (const X::AMH_BIResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



X::AMH_BIResponseHandler::AMH_BIResponseHandler ()
{}void
X::AMH_BIResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BIResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_BIResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

X::AMH_BIResponseHandler_ptr
X::AMH_BIResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_BIResponseHandler::_duplicate (
      dynamic_cast<AMH_BIResponseHandler_ptr> (_tao_objref));
}

X::AMH_BIResponseHandler_ptr
X::AMH_BIResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_BIResponseHandler::_duplicate (
      dynamic_cast<AMH_BIResponseHandler_ptr> (_tao_objref));
}

X::AMH_BIResponseHandler_ptr
X::AMH_BIResponseHandler::_nil ()
{
  return nullptr;
}

X::AMH_BIResponseHandler_ptr
X::AMH_BIResponseHandler::_duplicate (AMH_BIResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
X::AMH_BIResponseHandler::_tao_release (AMH_BIResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
X::AMH_BIResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:X/AMH_BIResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* X::AMH_BIResponseHandler::_interface_repository_id () const
{
  return "IDL:X/AMH_BIResponseHandler:1.0";
}

const char* X::AMH_BIResponseHandler::_desc_repository_id ()
{
  return "IDL:X/AMH_BIResponseHandler:1.0";
}

const char* X::AMH_BIResponseHandler::_desc_interface_name ()
{
  return "AMH_BIResponseHandler";
}

::CORBA::Boolean
X::AMH_BIResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_X_AMH_BIResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:X/AMH_BIResponseHandler:1.0",
    "AMH_BIResponseHandler");
  

namespace X
{
  ::CORBA::TypeCode_ptr const _tc_AMH_BIResponseHandler =
    &_tao_tc_X_AMH_BIResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for X::AMI_BIHandler.

X::AMI_BIHandler_ptr
TAO::Objref_Traits<X::AMI_BIHandler>::duplicate (X::AMI_BIHandler_ptr p)
{
  return X::AMI_BIHandler::_duplicate (p);
}

void
TAO::Objref_Traits<X::AMI_BIHandler>::release (X::AMI_BIHandler_ptr p)
{
  ::CORBA::release (p);
}

X::AMI_BIHandler_ptr
TAO::Objref_Traits<X::AMI_BIHandler>::nil ()
{
  return X::AMI_BIHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<X::AMI_BIHandler>::marshal (const X::AMI_BIHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
X::AMI_BIHandler::method ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  static TAO::Exception_Data
  _tao_X_AMI_BIHandler_method_exceptiondata [] = 
    {
      {
        "IDL:X/Ex:1.0",
        X::Ex::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , X::_tc_Ex
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "method",
      6,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (
      _tao_X_AMI_BIHandler_method_exceptiondata,
      1
    );
}

void
X::AMI_BIHandler::method_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  X::AMI_BIHandler_var _tao_reply_handler_object =
    X::AMI_BIHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->method (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      
      static TAO::Exception_Data exceptions_data [] =
      {
        {
          "IDL:X/Ex:1.0",
          X::Ex::_alloc
#if TAO_HAS_INTERCEPTORS == 1
          , X::_tc_Ex
#endif /* TAO_HAS_INTERCEPTORS */
        }
      };

      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            exceptions_data,
            1,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->method_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
X::AMI_BIHandler::method_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  static TAO::Exception_Data
  _tao_X_AMI_BIHandler_method_excep_exceptiondata [] = 
    {
      {
        "IDL:X/Ex:1.0",
        X::Ex::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , X::_tc_Ex
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "method_excep",
      12,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (
      _tao_X_AMI_BIHandler_method_excep_exceptiondata,
      1
    );
}

X::AMI_BIHandler::AMI_BIHandler ()
{
}
void
X::AMI_BIHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_BIHandler *_tao_tmp_pointer =
    static_cast<AMI_BIHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

X::AMI_BIHandler_ptr
X::AMI_BIHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_BIHandler>::narrow (_tao_objref, "IDL:X/AMI_BIHandler:1.0");
}

X::AMI_BIHandler_ptr
X::AMI_BIHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_BIHandler>::unchecked_narrow (_tao_objref);
}

X::AMI_BIHandler_ptr
X::AMI_BIHandler::_nil ()
{
  return nullptr;
}

X::AMI_BIHandler_ptr
X::AMI_BIHandler::_duplicate (AMI_BIHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
X::AMI_BIHandler::_tao_release (AMI_BIHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
X::AMI_BIHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:Y/AMI_ZHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:X/AMI_BIHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* X::AMI_BIHandler::_interface_repository_id () const
{
  return "IDL:X/AMI_BIHandler:1.0";
}

const char* X::AMI_BIHandler::_desc_repository_id ()
{
  return "IDL:X/AMI_BIHandler:1.0";
}

const char* X::AMI_BIHandler::_desc_interface_name ()
{
  return "AMI_BIHandler";
}

::CORBA::Boolean
X::AMI_BIHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_X_AMI_BIHandler (
    ::CORBA::tk_objref,
    "IDL:X/AMI_BIHandler:1.0",
    "AMI_BIHandler");
  

namespace X
{
  ::CORBA::TypeCode_ptr const _tc_AMI_BIHandler =
    &_tao_tc_X_AMI_BIHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for XX::blah_intfc.

XX::blah_intfc_ptr
TAO::Objref_Traits<XX::blah_intfc>::duplicate (XX::blah_intfc_ptr p)
{
  return XX::blah_intfc::_duplicate (p);
}

void
TAO::Objref_Traits<XX::blah_intfc>::release (XX::blah_intfc_ptr p)
{
  ::CORBA::release (p);
}

XX::blah_intfc_ptr
TAO::Objref_Traits<XX::blah_intfc>::nil ()
{
  return XX::blah_intfc::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<XX::blah_intfc>::marshal (const XX::blah_intfc_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
XX::blah_intfc::op1 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "op1",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
XX::blah_intfc::sendc_op1 (
  ::XX::AMI_blah_intfcHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "op1",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &XX::AMI_blah_intfcHandler::op1_reply_stub
    );
}

XX::blah_intfc::blah_intfc ()
{
}
void
XX::blah_intfc::_tao_any_destructor (void *_tao_void_pointer)
{
  blah_intfc *_tao_tmp_pointer =
    static_cast<blah_intfc *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

XX::blah_intfc_ptr
XX::blah_intfc::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<blah_intfc>::narrow (_tao_objref, "IDL:XX/blah_intfc:1.0");
}

XX::blah_intfc_ptr
XX::blah_intfc::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<blah_intfc>::unchecked_narrow (_tao_objref);
}

XX::blah_intfc_ptr
XX::blah_intfc::_nil ()
{
  return nullptr;
}

XX::blah_intfc_ptr
XX::blah_intfc::_duplicate (blah_intfc_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
XX::blah_intfc::_tao_release (blah_intfc_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
XX::blah_intfc::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:XX/blah_intfc:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* XX::blah_intfc::_interface_repository_id () const
{
  return "IDL:XX/blah_intfc:1.0";
}

const char* XX::blah_intfc::_desc_repository_id ()
{
  return "IDL:XX/blah_intfc:1.0";
}

const char* XX::blah_intfc::_desc_interface_name ()
{
  return "blah_intfc";
}

::CORBA::Boolean
XX::blah_intfc::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_XX_blah_intfc (
    ::CORBA::tk_objref,
    "IDL:XX/blah_intfc:1.0",
    "blah_intfc");
  

namespace XX
{
  ::CORBA::TypeCode_ptr const _tc_blah_intfc =
    &_tao_tc_XX_blah_intfc;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_XX_AMH_blah_intfcExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_XX_AMH_blah_intfcExceptionHolder (
    ::CORBA::tk_value,
    "IDL:XX/AMH_blah_intfcExceptionHolder:1.0",
    "AMH_blah_intfcExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_XX_AMH_blah_intfcExceptionHolder,
    0);
  

namespace XX
{
  ::CORBA::TypeCode_ptr const _tc_AMH_blah_intfcExceptionHolder =
    &_tao_tc_XX_AMH_blah_intfcExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<XX::AMH_blah_intfcExceptionHolder>::add_ref (XX::AMH_blah_intfcExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<XX::AMH_blah_intfcExceptionHolder>::remove_ref (XX::AMH_blah_intfcExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<XX::AMH_blah_intfcExceptionHolder>::release (XX::AMH_blah_intfcExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



XX::AMH_blah_intfcExceptionHolder *
XX::AMH_blah_intfcExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::XX::AMH_blah_intfcExceptionHolder *> (v);
}

const char *
XX::AMH_blah_intfcExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
XX::AMH_blah_intfcExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
XX::AMH_blah_intfcExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_blah_intfcExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_blah_intfcExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr XX::AMH_blah_intfcExceptionHolder::_tao_type () const
{
  return ::XX::_tc_AMH_blah_intfcExceptionHolder;
}

XX::AMH_blah_intfcExceptionHolder::~AMH_blah_intfcExceptionHolder ()
{}

::CORBA::ValueBase *
XX::AMH_blah_intfcExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_blah_intfcExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
XX::AMH_blah_intfcExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
XX::AMH_blah_intfcExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
XX::AMH_blah_intfcExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
XX::AMH_blah_intfcExceptionHolder::_tao_marshal__XX_AMH_blah_intfcExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
XX::AMH_blah_intfcExceptionHolder::_tao_unmarshal__XX_AMH_blah_intfcExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
XX::AMH_blah_intfcExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_blah_intfcExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_blah_intfcExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_blah_intfcExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
XX::AMH_blah_intfcExceptionHolder::raise_op1 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
XX::AMH_blah_intfcExceptionHolder::raise_sendc_op1 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for XX::AMH_blah_intfcResponseHandler.

XX::AMH_blah_intfcResponseHandler_ptr
TAO::Objref_Traits<XX::AMH_blah_intfcResponseHandler>::duplicate (XX::AMH_blah_intfcResponseHandler_ptr p)
{
  return XX::AMH_blah_intfcResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<XX::AMH_blah_intfcResponseHandler>::release (XX::AMH_blah_intfcResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

XX::AMH_blah_intfcResponseHandler_ptr
TAO::Objref_Traits<XX::AMH_blah_intfcResponseHandler>::nil ()
{
  return XX::AMH_blah_intfcResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<XX::AMH_blah_intfcResponseHandler>::marshal (const XX::AMH_blah_intfcResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



XX::AMH_blah_intfcResponseHandler::AMH_blah_intfcResponseHandler ()
{}void
XX::AMH_blah_intfcResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_blah_intfcResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_blah_intfcResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

XX::AMH_blah_intfcResponseHandler_ptr
XX::AMH_blah_intfcResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_blah_intfcResponseHandler::_duplicate (
      dynamic_cast<AMH_blah_intfcResponseHandler_ptr> (_tao_objref));
}

XX::AMH_blah_intfcResponseHandler_ptr
XX::AMH_blah_intfcResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_blah_intfcResponseHandler::_duplicate (
      dynamic_cast<AMH_blah_intfcResponseHandler_ptr> (_tao_objref));
}

XX::AMH_blah_intfcResponseHandler_ptr
XX::AMH_blah_intfcResponseHandler::_nil ()
{
  return nullptr;
}

XX::AMH_blah_intfcResponseHandler_ptr
XX::AMH_blah_intfcResponseHandler::_duplicate (AMH_blah_intfcResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
XX::AMH_blah_intfcResponseHandler::_tao_release (AMH_blah_intfcResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
XX::AMH_blah_intfcResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:XX/AMH_blah_intfcResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* XX::AMH_blah_intfcResponseHandler::_interface_repository_id () const
{
  return "IDL:XX/AMH_blah_intfcResponseHandler:1.0";
}

const char* XX::AMH_blah_intfcResponseHandler::_desc_repository_id ()
{
  return "IDL:XX/AMH_blah_intfcResponseHandler:1.0";
}

const char* XX::AMH_blah_intfcResponseHandler::_desc_interface_name ()
{
  return "AMH_blah_intfcResponseHandler";
}

::CORBA::Boolean
XX::AMH_blah_intfcResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_XX_AMH_blah_intfcResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:XX/AMH_blah_intfcResponseHandler:1.0",
    "AMH_blah_intfcResponseHandler");
  

namespace XX
{
  ::CORBA::TypeCode_ptr const _tc_AMH_blah_intfcResponseHandler =
    &_tao_tc_XX_AMH_blah_intfcResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for XX::AMI_blah_intfcHandler.

XX::AMI_blah_intfcHandler_ptr
TAO::Objref_Traits<XX::AMI_blah_intfcHandler>::duplicate (XX::AMI_blah_intfcHandler_ptr p)
{
  return XX::AMI_blah_intfcHandler::_duplicate (p);
}

void
TAO::Objref_Traits<XX::AMI_blah_intfcHandler>::release (XX::AMI_blah_intfcHandler_ptr p)
{
  ::CORBA::release (p);
}

XX::AMI_blah_intfcHandler_ptr
TAO::Objref_Traits<XX::AMI_blah_intfcHandler>::nil ()
{
  return XX::AMI_blah_intfcHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<XX::AMI_blah_intfcHandler>::marshal (const XX::AMI_blah_intfcHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
XX::AMI_blah_intfcHandler::op1 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "op1",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
XX::AMI_blah_intfcHandler::op1_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  XX::AMI_blah_intfcHandler_var _tao_reply_handler_object =
    XX::AMI_blah_intfcHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->op1 (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->op1_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
XX::AMI_blah_intfcHandler::op1_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op1_excep",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

XX::AMI_blah_intfcHandler::AMI_blah_intfcHandler ()
{
}
void
XX::AMI_blah_intfcHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_blah_intfcHandler *_tao_tmp_pointer =
    static_cast<AMI_blah_intfcHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

XX::AMI_blah_intfcHandler_ptr
XX::AMI_blah_intfcHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_blah_intfcHandler>::narrow (_tao_objref, "IDL:XX/AMI_blah_intfcHandler:1.0");
}

XX::AMI_blah_intfcHandler_ptr
XX::AMI_blah_intfcHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_blah_intfcHandler>::unchecked_narrow (_tao_objref);
}

XX::AMI_blah_intfcHandler_ptr
XX::AMI_blah_intfcHandler::_nil ()
{
  return nullptr;
}

XX::AMI_blah_intfcHandler_ptr
XX::AMI_blah_intfcHandler::_duplicate (AMI_blah_intfcHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
XX::AMI_blah_intfcHandler::_tao_release (AMI_blah_intfcHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
XX::AMI_blah_intfcHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:XX/AMI_blah_intfcHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* XX::AMI_blah_intfcHandler::_interface_repository_id () const
{
  return "IDL:XX/AMI_blah_intfcHandler:1.0";
}

const char* XX::AMI_blah_intfcHandler::_desc_repository_id ()
{
  return "IDL:XX/AMI_blah_intfcHandler:1.0";
}

const char* XX::AMI_blah_intfcHandler::_desc_interface_name ()
{
  return "AMI_blah_intfcHandler";
}

::CORBA::Boolean
XX::AMI_blah_intfcHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_XX_AMI_blah_intfcHandler (
    ::CORBA::tk_objref,
    "IDL:XX/AMI_blah_intfcHandler:1.0",
    "AMI_blah_intfcHandler");
  

namespace XX
{
  ::CORBA::TypeCode_ptr const _tc_AMI_blah_intfcHandler =
    &_tao_tc_XX_AMI_blah_intfcHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for XX::blah0.

XX::blah0_ptr
TAO::Objref_Traits<XX::blah0>::duplicate (XX::blah0_ptr p)
{
  return XX::blah0::_duplicate (p);
}

void
TAO::Objref_Traits<XX::blah0>::release (XX::blah0_ptr p)
{
  ::CORBA::release (p);
}

XX::blah0_ptr
TAO::Objref_Traits<XX::blah0>::nil ()
{
  return XX::blah0::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<XX::blah0>::marshal (const XX::blah0_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
XX::blah0::op0 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "op0",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
XX::blah0::sendc_op0 (
  ::XX::AMI_blah0Handler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "op0",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &XX::AMI_blah0Handler::op0_reply_stub
    );
}

XX::blah0::blah0 ()
{
}
void
XX::blah0::_tao_any_destructor (void *_tao_void_pointer)
{
  blah0 *_tao_tmp_pointer =
    static_cast<blah0 *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

XX::blah0_ptr
XX::blah0::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<blah0>::narrow (_tao_objref, "IDL:XX/blah0:1.0");
}

XX::blah0_ptr
XX::blah0::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<blah0>::unchecked_narrow (_tao_objref);
}

XX::blah0_ptr
XX::blah0::_nil ()
{
  return nullptr;
}

XX::blah0_ptr
XX::blah0::_duplicate (blah0_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
XX::blah0::_tao_release (blah0_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
XX::blah0::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:XX/blah_intfc:1.0") == 0 ||
      std::strcmp (value, "IDL:XX/blah0:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* XX::blah0::_interface_repository_id () const
{
  return "IDL:XX/blah0:1.0";
}

const char* XX::blah0::_desc_repository_id ()
{
  return "IDL:XX/blah0:1.0";
}

const char* XX::blah0::_desc_interface_name ()
{
  return "blah0";
}

::CORBA::Boolean
XX::blah0::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_XX_blah0 (
    ::CORBA::tk_objref,
    "IDL:XX/blah0:1.0",
    "blah0");
  

namespace XX
{
  ::CORBA::TypeCode_ptr const _tc_blah0 =
    &_tao_tc_XX_blah0;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_XX_AMH_blah0ExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_XX_AMH_blah0ExceptionHolder (
    ::CORBA::tk_value,
    "IDL:XX/AMH_blah0ExceptionHolder:1.0",
    "AMH_blah0ExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_XX_AMH_blah0ExceptionHolder,
    0);
  

namespace XX
{
  ::CORBA::TypeCode_ptr const _tc_AMH_blah0ExceptionHolder =
    &_tao_tc_XX_AMH_blah0ExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<XX::AMH_blah0ExceptionHolder>::add_ref (XX::AMH_blah0ExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<XX::AMH_blah0ExceptionHolder>::remove_ref (XX::AMH_blah0ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<XX::AMH_blah0ExceptionHolder>::release (XX::AMH_blah0ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



XX::AMH_blah0ExceptionHolder *
XX::AMH_blah0ExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::XX::AMH_blah0ExceptionHolder *> (v);
}

const char *
XX::AMH_blah0ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
XX::AMH_blah0ExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
XX::AMH_blah0ExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_blah0ExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_blah0ExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr XX::AMH_blah0ExceptionHolder::_tao_type () const
{
  return ::XX::_tc_AMH_blah0ExceptionHolder;
}

XX::AMH_blah0ExceptionHolder::~AMH_blah0ExceptionHolder ()
{}

::CORBA::ValueBase *
XX::AMH_blah0ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_blah0ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
XX::AMH_blah0ExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
XX::AMH_blah0ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
XX::AMH_blah0ExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
XX::AMH_blah0ExceptionHolder::_tao_marshal__XX_AMH_blah0ExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
XX::AMH_blah0ExceptionHolder::_tao_unmarshal__XX_AMH_blah0ExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
XX::AMH_blah0ExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_blah0ExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_blah0ExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_blah0ExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
XX::AMH_blah0ExceptionHolder::raise_op0 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
XX::AMH_blah0ExceptionHolder::raise_sendc_op0 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for XX::AMH_blah0ResponseHandler.

XX::AMH_blah0ResponseHandler_ptr
TAO::Objref_Traits<XX::AMH_blah0ResponseHandler>::duplicate (XX::AMH_blah0ResponseHandler_ptr p)
{
  return XX::AMH_blah0ResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<XX::AMH_blah0ResponseHandler>::release (XX::AMH_blah0ResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

XX::AMH_blah0ResponseHandler_ptr
TAO::Objref_Traits<XX::AMH_blah0ResponseHandler>::nil ()
{
  return XX::AMH_blah0ResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<XX::AMH_blah0ResponseHandler>::marshal (const XX::AMH_blah0ResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



XX::AMH_blah0ResponseHandler::AMH_blah0ResponseHandler ()
{}void
XX::AMH_blah0ResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_blah0ResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_blah0ResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

XX::AMH_blah0ResponseHandler_ptr
XX::AMH_blah0ResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_blah0ResponseHandler::_duplicate (
      dynamic_cast<AMH_blah0ResponseHandler_ptr> (_tao_objref));
}

XX::AMH_blah0ResponseHandler_ptr
XX::AMH_blah0ResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_blah0ResponseHandler::_duplicate (
      dynamic_cast<AMH_blah0ResponseHandler_ptr> (_tao_objref));
}

XX::AMH_blah0ResponseHandler_ptr
XX::AMH_blah0ResponseHandler::_nil ()
{
  return nullptr;
}

XX::AMH_blah0ResponseHandler_ptr
XX::AMH_blah0ResponseHandler::_duplicate (AMH_blah0ResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
XX::AMH_blah0ResponseHandler::_tao_release (AMH_blah0ResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
XX::AMH_blah0ResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:XX/AMH_blah0ResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* XX::AMH_blah0ResponseHandler::_interface_repository_id () const
{
  return "IDL:XX/AMH_blah0ResponseHandler:1.0";
}

const char* XX::AMH_blah0ResponseHandler::_desc_repository_id ()
{
  return "IDL:XX/AMH_blah0ResponseHandler:1.0";
}

const char* XX::AMH_blah0ResponseHandler::_desc_interface_name ()
{
  return "AMH_blah0ResponseHandler";
}

::CORBA::Boolean
XX::AMH_blah0ResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_XX_AMH_blah0ResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:XX/AMH_blah0ResponseHandler:1.0",
    "AMH_blah0ResponseHandler");
  

namespace XX
{
  ::CORBA::TypeCode_ptr const _tc_AMH_blah0ResponseHandler =
    &_tao_tc_XX_AMH_blah0ResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for XX::AMI_blah0Handler.

XX::AMI_blah0Handler_ptr
TAO::Objref_Traits<XX::AMI_blah0Handler>::duplicate (XX::AMI_blah0Handler_ptr p)
{
  return XX::AMI_blah0Handler::_duplicate (p);
}

void
TAO::Objref_Traits<XX::AMI_blah0Handler>::release (XX::AMI_blah0Handler_ptr p)
{
  ::CORBA::release (p);
}

XX::AMI_blah0Handler_ptr
TAO::Objref_Traits<XX::AMI_blah0Handler>::nil ()
{
  return XX::AMI_blah0Handler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<XX::AMI_blah0Handler>::marshal (const XX::AMI_blah0Handler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
XX::AMI_blah0Handler::op0 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "op0",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
XX::AMI_blah0Handler::op0_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  XX::AMI_blah0Handler_var _tao_reply_handler_object =
    XX::AMI_blah0Handler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->op0 (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->op0_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
XX::AMI_blah0Handler::op0_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op0_excep",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

XX::AMI_blah0Handler::AMI_blah0Handler ()
{
}
void
XX::AMI_blah0Handler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_blah0Handler *_tao_tmp_pointer =
    static_cast<AMI_blah0Handler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

XX::AMI_blah0Handler_ptr
XX::AMI_blah0Handler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_blah0Handler>::narrow (_tao_objref, "IDL:XX/AMI_blah0Handler:1.0");
}

XX::AMI_blah0Handler_ptr
XX::AMI_blah0Handler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_blah0Handler>::unchecked_narrow (_tao_objref);
}

XX::AMI_blah0Handler_ptr
XX::AMI_blah0Handler::_nil ()
{
  return nullptr;
}

XX::AMI_blah0Handler_ptr
XX::AMI_blah0Handler::_duplicate (AMI_blah0Handler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
XX::AMI_blah0Handler::_tao_release (AMI_blah0Handler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
XX::AMI_blah0Handler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:XX/AMI_blah_intfcHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:XX/AMI_blah0Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* XX::AMI_blah0Handler::_interface_repository_id () const
{
  return "IDL:XX/AMI_blah0Handler:1.0";
}

const char* XX::AMI_blah0Handler::_desc_repository_id ()
{
  return "IDL:XX/AMI_blah0Handler:1.0";
}

const char* XX::AMI_blah0Handler::_desc_interface_name ()
{
  return "AMI_blah0Handler";
}

::CORBA::Boolean
XX::AMI_blah0Handler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_XX_AMI_blah0Handler (
    ::CORBA::tk_objref,
    "IDL:XX/AMI_blah0Handler:1.0",
    "AMI_blah0Handler");
  

namespace XX
{
  ::CORBA::TypeCode_ptr const _tc_AMI_blah0Handler =
    &_tao_tc_XX_AMI_blah0Handler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for frag::frag_iface.

frag::frag_iface_ptr
TAO::Objref_Traits<frag::frag_iface>::duplicate (frag::frag_iface_ptr p)
{
  return frag::frag_iface::_duplicate (p);
}

void
TAO::Objref_Traits<frag::frag_iface>::release (frag::frag_iface_ptr p)
{
  ::CORBA::release (p);
}

frag::frag_iface_ptr
TAO::Objref_Traits<frag::frag_iface>::nil ()
{
  return frag::frag_iface::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<frag::frag_iface>::marshal (const frag::frag_iface_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



frag::frag_iface::frag_iface ()
{
}
void
frag::frag_iface::_tao_any_destructor (void *_tao_void_pointer)
{
  frag_iface *_tao_tmp_pointer =
    static_cast<frag_iface *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

frag::frag_iface_ptr
frag::frag_iface::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<frag_iface>::narrow (_tao_objref, "IDL:frag/frag_iface:1.0");
}

frag::frag_iface_ptr
frag::frag_iface::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<frag_iface>::unchecked_narrow (_tao_objref);
}

frag::frag_iface_ptr
frag::frag_iface::_nil ()
{
  return nullptr;
}

frag::frag_iface_ptr
frag::frag_iface::_duplicate (frag_iface_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
frag::frag_iface::_tao_release (frag_iface_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
frag::frag_iface::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:frag/frag_iface:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* frag::frag_iface::_interface_repository_id () const
{
  return "IDL:frag/frag_iface:1.0";
}

const char* frag::frag_iface::_desc_repository_id ()
{
  return "IDL:frag/frag_iface:1.0";
}

const char* frag::frag_iface::_desc_interface_name ()
{
  return "frag_iface";
}

::CORBA::Boolean
frag::frag_iface::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_frag_frag_iface (
    ::CORBA::tk_objref,
    "IDL:frag/frag_iface:1.0",
    "frag_iface");
  

namespace frag
{
  ::CORBA::TypeCode_ptr const _tc_frag_iface =
    &_tao_tc_frag_frag_iface;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_frag_AMH_frag_ifaceExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_frag_AMH_frag_ifaceExceptionHolder (
    ::CORBA::tk_value,
    "IDL:frag/AMH_frag_ifaceExceptionHolder:1.0",
    "AMH_frag_ifaceExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_frag_AMH_frag_ifaceExceptionHolder,
    0);
  

namespace frag
{
  ::CORBA::TypeCode_ptr const _tc_AMH_frag_ifaceExceptionHolder =
    &_tao_tc_frag_AMH_frag_ifaceExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<frag::AMH_frag_ifaceExceptionHolder>::add_ref (frag::AMH_frag_ifaceExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<frag::AMH_frag_ifaceExceptionHolder>::remove_ref (frag::AMH_frag_ifaceExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<frag::AMH_frag_ifaceExceptionHolder>::release (frag::AMH_frag_ifaceExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



frag::AMH_frag_ifaceExceptionHolder *
frag::AMH_frag_ifaceExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::frag::AMH_frag_ifaceExceptionHolder *> (v);
}

const char *
frag::AMH_frag_ifaceExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
frag::AMH_frag_ifaceExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
frag::AMH_frag_ifaceExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_frag_ifaceExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_frag_ifaceExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr frag::AMH_frag_ifaceExceptionHolder::_tao_type () const
{
  return ::frag::_tc_AMH_frag_ifaceExceptionHolder;
}

frag::AMH_frag_ifaceExceptionHolder::~AMH_frag_ifaceExceptionHolder ()
{}

::CORBA::ValueBase *
frag::AMH_frag_ifaceExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_frag_ifaceExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
frag::AMH_frag_ifaceExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
frag::AMH_frag_ifaceExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
frag::AMH_frag_ifaceExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
frag::AMH_frag_ifaceExceptionHolder::_tao_marshal__frag_AMH_frag_ifaceExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
frag::AMH_frag_ifaceExceptionHolder::_tao_unmarshal__frag_AMH_frag_ifaceExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
frag::AMH_frag_ifaceExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_frag_ifaceExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_frag_ifaceExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_frag_ifaceExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



frag::AMH_frag_ifaceExceptionHolder_init::AMH_frag_ifaceExceptionHolder_init ()
{
}

frag::AMH_frag_ifaceExceptionHolder_init::~AMH_frag_ifaceExceptionHolder_init ()
{
}

frag::AMH_frag_ifaceExceptionHolder_init *
frag::AMH_frag_ifaceExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::frag::AMH_frag_ifaceExceptionHolder_init *> (v);
}

const char*
frag::AMH_frag_ifaceExceptionHolder_init::tao_repository_id ()
{
  return ::frag::AMH_frag_ifaceExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
frag::AMH_frag_ifaceExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_frag::AMH_frag_ifaceExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for frag::AMH_frag_ifaceResponseHandler.

frag::AMH_frag_ifaceResponseHandler_ptr
TAO::Objref_Traits<frag::AMH_frag_ifaceResponseHandler>::duplicate (frag::AMH_frag_ifaceResponseHandler_ptr p)
{
  return frag::AMH_frag_ifaceResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<frag::AMH_frag_ifaceResponseHandler>::release (frag::AMH_frag_ifaceResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

frag::AMH_frag_ifaceResponseHandler_ptr
TAO::Objref_Traits<frag::AMH_frag_ifaceResponseHandler>::nil ()
{
  return frag::AMH_frag_ifaceResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<frag::AMH_frag_ifaceResponseHandler>::marshal (const frag::AMH_frag_ifaceResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



frag::AMH_frag_ifaceResponseHandler::AMH_frag_ifaceResponseHandler ()
{}void
frag::AMH_frag_ifaceResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_frag_ifaceResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_frag_ifaceResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

frag::AMH_frag_ifaceResponseHandler_ptr
frag::AMH_frag_ifaceResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_frag_ifaceResponseHandler::_duplicate (
      dynamic_cast<AMH_frag_ifaceResponseHandler_ptr> (_tao_objref));
}

frag::AMH_frag_ifaceResponseHandler_ptr
frag::AMH_frag_ifaceResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_frag_ifaceResponseHandler::_duplicate (
      dynamic_cast<AMH_frag_ifaceResponseHandler_ptr> (_tao_objref));
}

frag::AMH_frag_ifaceResponseHandler_ptr
frag::AMH_frag_ifaceResponseHandler::_nil ()
{
  return nullptr;
}

frag::AMH_frag_ifaceResponseHandler_ptr
frag::AMH_frag_ifaceResponseHandler::_duplicate (AMH_frag_ifaceResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
frag::AMH_frag_ifaceResponseHandler::_tao_release (AMH_frag_ifaceResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
frag::AMH_frag_ifaceResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:frag/AMH_frag_ifaceResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* frag::AMH_frag_ifaceResponseHandler::_interface_repository_id () const
{
  return "IDL:frag/AMH_frag_ifaceResponseHandler:1.0";
}

const char* frag::AMH_frag_ifaceResponseHandler::_desc_repository_id ()
{
  return "IDL:frag/AMH_frag_ifaceResponseHandler:1.0";
}

const char* frag::AMH_frag_ifaceResponseHandler::_desc_interface_name ()
{
  return "AMH_frag_ifaceResponseHandler";
}

::CORBA::Boolean
frag::AMH_frag_ifaceResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_frag_AMH_frag_ifaceResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:frag/AMH_frag_ifaceResponseHandler:1.0",
    "AMH_frag_ifaceResponseHandler");
  

namespace frag
{
  ::CORBA::TypeCode_ptr const _tc_AMH_frag_ifaceResponseHandler =
    &_tao_tc_frag_AMH_frag_ifaceResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for frag::AMI_frag_ifaceHandler.

frag::AMI_frag_ifaceHandler_ptr
TAO::Objref_Traits<frag::AMI_frag_ifaceHandler>::duplicate (frag::AMI_frag_ifaceHandler_ptr p)
{
  return frag::AMI_frag_ifaceHandler::_duplicate (p);
}

void
TAO::Objref_Traits<frag::AMI_frag_ifaceHandler>::release (frag::AMI_frag_ifaceHandler_ptr p)
{
  ::CORBA::release (p);
}

frag::AMI_frag_ifaceHandler_ptr
TAO::Objref_Traits<frag::AMI_frag_ifaceHandler>::nil ()
{
  return frag::AMI_frag_ifaceHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<frag::AMI_frag_ifaceHandler>::marshal (const frag::AMI_frag_ifaceHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



frag::AMI_frag_ifaceHandler::AMI_frag_ifaceHandler ()
{
}
void
frag::AMI_frag_ifaceHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_frag_ifaceHandler *_tao_tmp_pointer =
    static_cast<AMI_frag_ifaceHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

frag::AMI_frag_ifaceHandler_ptr
frag::AMI_frag_ifaceHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_frag_ifaceHandler>::narrow (_tao_objref, "IDL:frag/AMI_frag_ifaceHandler:1.0");
}

frag::AMI_frag_ifaceHandler_ptr
frag::AMI_frag_ifaceHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_frag_ifaceHandler>::unchecked_narrow (_tao_objref);
}

frag::AMI_frag_ifaceHandler_ptr
frag::AMI_frag_ifaceHandler::_nil ()
{
  return nullptr;
}

frag::AMI_frag_ifaceHandler_ptr
frag::AMI_frag_ifaceHandler::_duplicate (AMI_frag_ifaceHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
frag::AMI_frag_ifaceHandler::_tao_release (AMI_frag_ifaceHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
frag::AMI_frag_ifaceHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:frag/AMI_frag_ifaceHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* frag::AMI_frag_ifaceHandler::_interface_repository_id () const
{
  return "IDL:frag/AMI_frag_ifaceHandler:1.0";
}

const char* frag::AMI_frag_ifaceHandler::_desc_repository_id ()
{
  return "IDL:frag/AMI_frag_ifaceHandler:1.0";
}

const char* frag::AMI_frag_ifaceHandler::_desc_interface_name ()
{
  return "AMI_frag_ifaceHandler";
}

::CORBA::Boolean
frag::AMI_frag_ifaceHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_frag_AMI_frag_ifaceHandler (
    ::CORBA::tk_objref,
    "IDL:frag/AMI_frag_ifaceHandler:1.0",
    "AMI_frag_ifaceHandler");
  

namespace frag
{
  ::CORBA::TypeCode_ptr const _tc_AMI_frag_ifaceHandler =
    &_tao_tc_frag_AMI_frag_ifaceHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_frag_ret_long (
    ::CORBA::tk_alias,
    "IDL:frag/ret_long:1.0",
    "ret_long",
    &CORBA::_tc_long);
  

namespace frag
{
  ::CORBA::TypeCode_ptr const _tc_ret_long =
    &_tao_tc_frag_ret_long;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for gather.

gather_ptr
TAO::Objref_Traits<gather>::duplicate (gather_ptr p)
{
  return gather::_duplicate (p);
}

void
TAO::Objref_Traits<gather>::release (gather_ptr p)
{
  ::CORBA::release (p);
}

gather_ptr
TAO::Objref_Traits<gather>::nil ()
{
  return gather::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<gather>::marshal (const gather_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::frag::ret_long
gather::op (
  const ::frag::dub_seq & inarg,
  ::frag::pug & inoutarg,
  ::frag::frag_iface_out outarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;
  TAO::Arg_Traits< ::frag::dub_seq>::in_arg_val _tao_inarg (inarg);
  TAO::Arg_Traits< ::frag::pug>::inout_arg_val _tao_inoutarg (inoutarg);
  TAO::Arg_Traits< ::frag::frag_iface>::out_arg_val _tao_outarg (outarg);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_inarg),
      std::addressof(_tao_inoutarg),
      std::addressof(_tao_outarg)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      4,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
gather::sendc_op (
  ::AMI_gatherHandler_ptr ami_handler,
  const ::frag::dub_seq & inarg,
  const ::frag::pug & inoutarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::frag::dub_seq>::in_arg_val _tao_inarg (inarg);
  TAO::Arg_Traits< ::frag::pug>::in_arg_val _tao_inoutarg (inoutarg);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_inarg),
      std::addressof(_tao_inoutarg)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      3,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &AMI_gatherHandler::op_reply_stub
    );
}

gather::gather ()
{
}
void
gather::_tao_any_destructor (void *_tao_void_pointer)
{
  gather *_tao_tmp_pointer =
    static_cast<gather *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

gather_ptr
gather::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<gather>::narrow (_tao_objref, "IDL:gather:1.0");
}

gather_ptr
gather::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<gather>::unchecked_narrow (_tao_objref);
}

gather_ptr
gather::_nil ()
{
  return nullptr;
}

gather_ptr
gather::_duplicate (gather_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
gather::_tao_release (gather_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
gather::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:gather:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* gather::_interface_repository_id () const
{
  return "IDL:gather:1.0";
}

const char* gather::_desc_repository_id ()
{
  return "IDL:gather:1.0";
}

const char* gather::_desc_interface_name ()
{
  return "gather";
}

::CORBA::Boolean
gather::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_gather (
    ::CORBA::tk_objref,
    "IDL:gather:1.0",
    "gather");
  
::CORBA::TypeCode_ptr const _tc_gather =
  &_tao_tc_gather;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_AMH_gatherExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_AMH_gatherExceptionHolder (
    ::CORBA::tk_value,
    "IDL:AMH_gatherExceptionHolder:1.0",
    "AMH_gatherExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_AMH_gatherExceptionHolder,
    0);
  
::CORBA::TypeCode_ptr const _tc_AMH_gatherExceptionHolder =
  &_tao_tc_AMH_gatherExceptionHolder;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<AMH_gatherExceptionHolder>::add_ref (AMH_gatherExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<AMH_gatherExceptionHolder>::remove_ref (AMH_gatherExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<AMH_gatherExceptionHolder>::release (AMH_gatherExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_gatherExceptionHolder *
AMH_gatherExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::AMH_gatherExceptionHolder *> (v);
}

const char *
AMH_gatherExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
AMH_gatherExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
AMH_gatherExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_gatherExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_gatherExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr AMH_gatherExceptionHolder::_tao_type () const
{
  return ::_tc_AMH_gatherExceptionHolder;
}

AMH_gatherExceptionHolder::~AMH_gatherExceptionHolder ()
{}

::CORBA::ValueBase *
AMH_gatherExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_gatherExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
AMH_gatherExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
AMH_gatherExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
AMH_gatherExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
AMH_gatherExceptionHolder::_tao_marshal__AMH_gatherExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
AMH_gatherExceptionHolder::_tao_unmarshal__AMH_gatherExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
AMH_gatherExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_gatherExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_gatherExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_gatherExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_gatherExceptionHolder::raise_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
AMH_gatherExceptionHolder::raise_sendc_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMH_gatherResponseHandler.

AMH_gatherResponseHandler_ptr
TAO::Objref_Traits<AMH_gatherResponseHandler>::duplicate (AMH_gatherResponseHandler_ptr p)
{
  return AMH_gatherResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMH_gatherResponseHandler>::release (AMH_gatherResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

AMH_gatherResponseHandler_ptr
TAO::Objref_Traits<AMH_gatherResponseHandler>::nil ()
{
  return AMH_gatherResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMH_gatherResponseHandler>::marshal (const AMH_gatherResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



AMH_gatherResponseHandler::AMH_gatherResponseHandler ()
{}void
AMH_gatherResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_gatherResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_gatherResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMH_gatherResponseHandler_ptr
AMH_gatherResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_gatherResponseHandler::_duplicate (
      dynamic_cast<AMH_gatherResponseHandler_ptr> (_tao_objref));
}

AMH_gatherResponseHandler_ptr
AMH_gatherResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_gatherResponseHandler::_duplicate (
      dynamic_cast<AMH_gatherResponseHandler_ptr> (_tao_objref));
}

AMH_gatherResponseHandler_ptr
AMH_gatherResponseHandler::_nil ()
{
  return nullptr;
}

AMH_gatherResponseHandler_ptr
AMH_gatherResponseHandler::_duplicate (AMH_gatherResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMH_gatherResponseHandler::_tao_release (AMH_gatherResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMH_gatherResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:AMH_gatherResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* AMH_gatherResponseHandler::_interface_repository_id () const
{
  return "IDL:AMH_gatherResponseHandler:1.0";
}

const char* AMH_gatherResponseHandler::_desc_repository_id ()
{
  return "IDL:AMH_gatherResponseHandler:1.0";
}

const char* AMH_gatherResponseHandler::_desc_interface_name ()
{
  return "AMH_gatherResponseHandler";
}

::CORBA::Boolean
AMH_gatherResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMH_gatherResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:AMH_gatherResponseHandler:1.0",
    "AMH_gatherResponseHandler");
  
::CORBA::TypeCode_ptr const _tc_AMH_gatherResponseHandler =
  &_tao_tc_AMH_gatherResponseHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for AMI_gatherHandler.

AMI_gatherHandler_ptr
TAO::Objref_Traits<AMI_gatherHandler>::duplicate (AMI_gatherHandler_ptr p)
{
  return AMI_gatherHandler::_duplicate (p);
}

void
TAO::Objref_Traits<AMI_gatherHandler>::release (AMI_gatherHandler_ptr p)
{
  ::CORBA::release (p);
}

AMI_gatherHandler_ptr
TAO::Objref_Traits<AMI_gatherHandler>::nil ()
{
  return AMI_gatherHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<AMI_gatherHandler>::marshal (const AMI_gatherHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_gatherHandler::op (
  ::frag::ret_long ami_return_val,
  const ::frag::pug & inoutarg,
  ::frag::frag_iface_ptr outarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_ami_return_val (ami_return_val);
  TAO::Arg_Traits< ::frag::pug>::in_arg_val _tao_inoutarg (inoutarg);
  TAO::Arg_Traits< ::frag::frag_iface>::in_arg_val _tao_outarg (outarg);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val),
      std::addressof(_tao_inoutarg),
      std::addressof(_tao_outarg)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      4,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
AMI_gatherHandler::op_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  AMI_gatherHandler_var _tao_reply_handler_object =
    AMI_gatherHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::frag::ret_long ami_return_val;
      ::frag::pug inoutarg;
      ::frag::frag_iface_var outarg;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val) &&
            (_tao_in >> inoutarg) &&
            (_tao_in >> outarg.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->op (
          
          ami_return_val,
          
          inoutarg,
          
          outarg.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->op_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
AMI_gatherHandler::op_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op_excep",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

AMI_gatherHandler::AMI_gatherHandler ()
{
}
void
AMI_gatherHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_gatherHandler *_tao_tmp_pointer =
    static_cast<AMI_gatherHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

AMI_gatherHandler_ptr
AMI_gatherHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_gatherHandler>::narrow (_tao_objref, "IDL:AMI_gatherHandler:1.0");
}

AMI_gatherHandler_ptr
AMI_gatherHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_gatherHandler>::unchecked_narrow (_tao_objref);
}

AMI_gatherHandler_ptr
AMI_gatherHandler::_nil ()
{
  return nullptr;
}

AMI_gatherHandler_ptr
AMI_gatherHandler::_duplicate (AMI_gatherHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
AMI_gatherHandler::_tao_release (AMI_gatherHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
AMI_gatherHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:AMI_gatherHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* AMI_gatherHandler::_interface_repository_id () const
{
  return "IDL:AMI_gatherHandler:1.0";
}

const char* AMI_gatherHandler::_desc_repository_id ()
{
  return "IDL:AMI_gatherHandler:1.0";
}

const char* AMI_gatherHandler::_desc_interface_name ()
{
  return "AMI_gatherHandler";
}

::CORBA::Boolean
AMI_gatherHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_AMI_gatherHandler (
    ::CORBA::tk_objref,
    "IDL:AMI_gatherHandler:1.0",
    "AMI_gatherHandler");
  
::CORBA::TypeCode_ptr const _tc_AMI_gatherHandler =
  &_tao_tc_AMI_gatherHandler;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_foo_longdef (
    ::CORBA::tk_alias,
    "IDL:foo/longdef:1.0",
    "longdef",
    &CORBA::_tc_long);
  

namespace foo
{
  ::CORBA::TypeCode_ptr const _tc_longdef =
    &_tao_tc_foo_longdef;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_longdef2 (
    ::CORBA::tk_alias,
    "IDL:longdef2:1.0",
    "longdef2",
    &CORBA::_tc_long);
  
::CORBA::TypeCode_ptr const _tc_longdef2 =
  &_tao_tc_longdef2;
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_bar[] =
      {
        { "s", &CORBA::_tc_short }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_bar (
  ::CORBA::tk_struct,
  "IDL:bar:1.0",
  "bar",
  _tao_fields_bar,
  1);

::CORBA::TypeCode_ptr const _tc_bar =
  &_tao_tc_bar;


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
bar::_tao_any_destructor (
    void *_tao_void_pointer)
{
  bar *_tao_tmp_pointer =
    static_cast<bar *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_foo_foo_struct[] =
      {
        { "longval", &foo::_tc_longdef },
        { "longval2", &_tc_longdef2 }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_foo_foo_struct (
  ::CORBA::tk_struct,
  "IDL:foo/foo_struct:1.0",
  "foo_struct",
  _tao_fields_foo_foo_struct,
  2);


namespace foo
{
  ::CORBA::TypeCode_ptr const _tc_foo_struct =
    &_tao_tc_foo_foo_struct;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
foo::foo_struct::_tao_any_destructor (
    void *_tao_void_pointer)
{
  foo_struct *_tao_tmp_pointer =
    static_cast<foo_struct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for foo::obj.

foo::obj_ptr
TAO::Objref_Traits<foo::obj>::duplicate (foo::obj_ptr p)
{
  return foo::obj::_duplicate (p);
}

void
TAO::Objref_Traits<foo::obj>::release (foo::obj_ptr p)
{
  ::CORBA::release (p);
}

foo::obj_ptr
TAO::Objref_Traits<foo::obj>::nil ()
{
  return foo::obj::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<foo::obj>::marshal (const foo::obj_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
foo::obj::op (
  const ::bar & inarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::bar>::in_arg_val _tao_inarg (inarg);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_inarg)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
foo::obj::sendc_op (
  ::foo::AMI_objHandler_ptr ami_handler,
  const ::bar & inarg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::bar>::in_arg_val _tao_inarg (inarg);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_inarg)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &foo::AMI_objHandler::op_reply_stub
    );
}

foo::obj::obj ()
{
}
void
foo::obj::_tao_any_destructor (void *_tao_void_pointer)
{
  obj *_tao_tmp_pointer =
    static_cast<obj *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

foo::obj_ptr
foo::obj::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<obj>::narrow (_tao_objref, "IDL:foo/obj:1.0");
}

foo::obj_ptr
foo::obj::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<obj>::unchecked_narrow (_tao_objref);
}

foo::obj_ptr
foo::obj::_nil ()
{
  return nullptr;
}

foo::obj_ptr
foo::obj::_duplicate (obj_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
foo::obj::_tao_release (obj_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
foo::obj::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:foo/obj:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* foo::obj::_interface_repository_id () const
{
  return "IDL:foo/obj:1.0";
}

const char* foo::obj::_desc_repository_id ()
{
  return "IDL:foo/obj:1.0";
}

const char* foo::obj::_desc_interface_name ()
{
  return "obj";
}

::CORBA::Boolean
foo::obj::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_foo_obj (
    ::CORBA::tk_objref,
    "IDL:foo/obj:1.0",
    "obj");
  

namespace foo
{
  ::CORBA::TypeCode_ptr const _tc_obj =
    &_tao_tc_foo_obj;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_foo_AMH_objExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_foo_AMH_objExceptionHolder (
    ::CORBA::tk_value,
    "IDL:foo/AMH_objExceptionHolder:1.0",
    "AMH_objExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_foo_AMH_objExceptionHolder,
    0);
  

namespace foo
{
  ::CORBA::TypeCode_ptr const _tc_AMH_objExceptionHolder =
    &_tao_tc_foo_AMH_objExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<foo::AMH_objExceptionHolder>::add_ref (foo::AMH_objExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<foo::AMH_objExceptionHolder>::remove_ref (foo::AMH_objExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<foo::AMH_objExceptionHolder>::release (foo::AMH_objExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



foo::AMH_objExceptionHolder *
foo::AMH_objExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::foo::AMH_objExceptionHolder *> (v);
}

const char *
foo::AMH_objExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
foo::AMH_objExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
foo::AMH_objExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_objExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_objExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr foo::AMH_objExceptionHolder::_tao_type () const
{
  return ::foo::_tc_AMH_objExceptionHolder;
}

foo::AMH_objExceptionHolder::~AMH_objExceptionHolder ()
{}

::CORBA::ValueBase *
foo::AMH_objExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_objExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
foo::AMH_objExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
foo::AMH_objExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
foo::AMH_objExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
foo::AMH_objExceptionHolder::_tao_marshal__foo_AMH_objExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
foo::AMH_objExceptionHolder::_tao_unmarshal__foo_AMH_objExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
foo::AMH_objExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_objExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_objExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_objExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
foo::AMH_objExceptionHolder::raise_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
foo::AMH_objExceptionHolder::raise_sendc_op ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for foo::AMH_objResponseHandler.

foo::AMH_objResponseHandler_ptr
TAO::Objref_Traits<foo::AMH_objResponseHandler>::duplicate (foo::AMH_objResponseHandler_ptr p)
{
  return foo::AMH_objResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<foo::AMH_objResponseHandler>::release (foo::AMH_objResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

foo::AMH_objResponseHandler_ptr
TAO::Objref_Traits<foo::AMH_objResponseHandler>::nil ()
{
  return foo::AMH_objResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<foo::AMH_objResponseHandler>::marshal (const foo::AMH_objResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



foo::AMH_objResponseHandler::AMH_objResponseHandler ()
{}void
foo::AMH_objResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_objResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_objResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

foo::AMH_objResponseHandler_ptr
foo::AMH_objResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_objResponseHandler::_duplicate (
      dynamic_cast<AMH_objResponseHandler_ptr> (_tao_objref));
}

foo::AMH_objResponseHandler_ptr
foo::AMH_objResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_objResponseHandler::_duplicate (
      dynamic_cast<AMH_objResponseHandler_ptr> (_tao_objref));
}

foo::AMH_objResponseHandler_ptr
foo::AMH_objResponseHandler::_nil ()
{
  return nullptr;
}

foo::AMH_objResponseHandler_ptr
foo::AMH_objResponseHandler::_duplicate (AMH_objResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
foo::AMH_objResponseHandler::_tao_release (AMH_objResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
foo::AMH_objResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:foo/AMH_objResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* foo::AMH_objResponseHandler::_interface_repository_id () const
{
  return "IDL:foo/AMH_objResponseHandler:1.0";
}

const char* foo::AMH_objResponseHandler::_desc_repository_id ()
{
  return "IDL:foo/AMH_objResponseHandler:1.0";
}

const char* foo::AMH_objResponseHandler::_desc_interface_name ()
{
  return "AMH_objResponseHandler";
}

::CORBA::Boolean
foo::AMH_objResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_foo_AMH_objResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:foo/AMH_objResponseHandler:1.0",
    "AMH_objResponseHandler");
  

namespace foo
{
  ::CORBA::TypeCode_ptr const _tc_AMH_objResponseHandler =
    &_tao_tc_foo_AMH_objResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for foo::AMI_objHandler.

foo::AMI_objHandler_ptr
TAO::Objref_Traits<foo::AMI_objHandler>::duplicate (foo::AMI_objHandler_ptr p)
{
  return foo::AMI_objHandler::_duplicate (p);
}

void
TAO::Objref_Traits<foo::AMI_objHandler>::release (foo::AMI_objHandler_ptr p)
{
  ::CORBA::release (p);
}

foo::AMI_objHandler_ptr
TAO::Objref_Traits<foo::AMI_objHandler>::nil ()
{
  return foo::AMI_objHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<foo::AMI_objHandler>::marshal (const foo::AMI_objHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
foo::AMI_objHandler::op ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "op",
      2,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
foo::AMI_objHandler::op_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  foo::AMI_objHandler_var _tao_reply_handler_object =
    foo::AMI_objHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->op (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->op_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
foo::AMI_objHandler::op_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "op_excep",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

foo::AMI_objHandler::AMI_objHandler ()
{
}
void
foo::AMI_objHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_objHandler *_tao_tmp_pointer =
    static_cast<AMI_objHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

foo::AMI_objHandler_ptr
foo::AMI_objHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_objHandler>::narrow (_tao_objref, "IDL:foo/AMI_objHandler:1.0");
}

foo::AMI_objHandler_ptr
foo::AMI_objHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_objHandler>::unchecked_narrow (_tao_objref);
}

foo::AMI_objHandler_ptr
foo::AMI_objHandler::_nil ()
{
  return nullptr;
}

foo::AMI_objHandler_ptr
foo::AMI_objHandler::_duplicate (AMI_objHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
foo::AMI_objHandler::_tao_release (AMI_objHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
foo::AMI_objHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:foo/AMI_objHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* foo::AMI_objHandler::_interface_repository_id () const
{
  return "IDL:foo/AMI_objHandler:1.0";
}

const char* foo::AMI_objHandler::_desc_repository_id ()
{
  return "IDL:foo/AMI_objHandler:1.0";
}

const char* foo::AMI_objHandler::_desc_interface_name ()
{
  return "AMI_objHandler";
}

::CORBA::Boolean
foo::AMI_objHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_foo_AMI_objHandler (
    ::CORBA::tk_objref,
    "IDL:foo/AMI_objHandler:1.0",
    "AMI_objHandler");
  

namespace foo
{
  ::CORBA::TypeCode_ptr const _tc_AMI_objHandler =
    &_tao_tc_foo_AMI_objHandler;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/sequence_cs.cpp:104



#if !defined (_A_B_X2SEQ_CS_)
#define _A_B_X2SEQ_CS_

A::B::X2Seq::X2Seq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        X2,
        X2_var
      > (max)
{}

A::B::X2Seq::X2Seq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    A::B::X2_ptr * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_object_reference_sequence<
        X2,
        X2_var
      >
    (max, length, buffer, release)
{}

void A::B::X2Seq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  X2Seq * _tao_tmp_pointer =
    static_cast<X2Seq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:457


#ifndef _TAO_TYPECODE_A_B_X2Seq_GUARD
#define _TAO_TYPECODE_A_B_X2Seq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        A_B_X2Seq_0 (
          ::CORBA::tk_sequence,
          &A::B::_tc_X2,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_A_B_X2Seq_0 =
        &A_B_X2Seq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_A_B_X2Seq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_A_B_X2Seq (
    ::CORBA::tk_alias,
    "IDL:A/B/X2Seq:1.0",
    "X2Seq",
    &TAO::TypeCode::tc_A_B_X2Seq_0);
  

namespace A
{
  
  namespace B
  {
    ::CORBA::TypeCode_ptr const _tc_X2Seq =
      &_tao_tc_A_B_X2Seq;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for A::B::X3.

A::B::X3_ptr
TAO::Objref_Traits<A::B::X3>::duplicate (A::B::X3_ptr p)
{
  return A::B::X3::_duplicate (p);
}

void
TAO::Objref_Traits<A::B::X3>::release (A::B::X3_ptr p)
{
  ::CORBA::release (p);
}

A::B::X3_ptr
TAO::Objref_Traits<A::B::X3>::nil ()
{
  return A::B::X3::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<A::B::X3>::marshal (const A::B::X3_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::A::B::X2Seq *
A::B::X3::getSeqOfX2 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::A::B::X2Seq>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "getSeqOfX2",
      10,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

char *
A::B::X3::getX3 ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< char *>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "getX3",
      5,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
A::B::X3::sendc_getSeqOfX2 (
  ::A::B::AMI_X3Handler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "getSeqOfX2",
      10,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &A::B::AMI_X3Handler::getSeqOfX2_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
A::B::X3::sendc_getX3 (
  ::A::B::AMI_X3Handler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "getX3",
      5,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &A::B::AMI_X3Handler::getX3_reply_stub
    );
}

A::B::X3::X3 ()
{
}
void
A::B::X3::_tao_any_destructor (void *_tao_void_pointer)
{
  X3 *_tao_tmp_pointer =
    static_cast<X3 *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

A::B::X3_ptr
A::B::X3::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<X3>::narrow (_tao_objref, "IDL:A/B/X3:1.0");
}

A::B::X3_ptr
A::B::X3::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<X3>::unchecked_narrow (_tao_objref);
}

A::B::X3_ptr
A::B::X3::_nil ()
{
  return nullptr;
}

A::B::X3_ptr
A::B::X3::_duplicate (X3_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
A::B::X3::_tao_release (X3_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
A::B::X3::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:A/B/X1:1.0") == 0 ||
      std::strcmp (value, "IDL:A/B/X2:1.0") == 0 ||
      std::strcmp (value, "IDL:A/B/X3:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* A::B::X3::_interface_repository_id () const
{
  return "IDL:A/B/X3:1.0";
}

const char* A::B::X3::_desc_repository_id ()
{
  return "IDL:A/B/X3:1.0";
}

const char* A::B::X3::_desc_interface_name ()
{
  return "X3";
}

::CORBA::Boolean
A::B::X3::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_A_B_X3 (
    ::CORBA::tk_objref,
    "IDL:A/B/X3:1.0",
    "X3");
  

namespace A
{
  
  namespace B
  {
    ::CORBA::TypeCode_ptr const _tc_X3 =
      &_tao_tc_A_B_X3;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_A_B_AMH_X3ExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_A_B_AMH_X3ExceptionHolder (
    ::CORBA::tk_value,
    "IDL:A/B/AMH_X3ExceptionHolder:1.0",
    "AMH_X3ExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_A_B_AMH_X3ExceptionHolder,
    0);
  

namespace A
{
  
  namespace B
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_X3ExceptionHolder =
      &_tao_tc_A_B_AMH_X3ExceptionHolder;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<A::B::AMH_X3ExceptionHolder>::add_ref (A::B::AMH_X3ExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<A::B::AMH_X3ExceptionHolder>::remove_ref (A::B::AMH_X3ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<A::B::AMH_X3ExceptionHolder>::release (A::B::AMH_X3ExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



A::B::AMH_X3ExceptionHolder *
A::B::AMH_X3ExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::A::B::AMH_X3ExceptionHolder *> (v);
}

const char *
A::B::AMH_X3ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
A::B::AMH_X3ExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
A::B::AMH_X3ExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_X3ExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_X3ExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr A::B::AMH_X3ExceptionHolder::_tao_type () const
{
  return ::A::B::_tc_AMH_X3ExceptionHolder;
}

A::B::AMH_X3ExceptionHolder::~AMH_X3ExceptionHolder ()
{}

::CORBA::ValueBase *
A::B::AMH_X3ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_X3ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
A::B::AMH_X3ExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
A::B::AMH_X3ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
A::B::AMH_X3ExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
A::B::AMH_X3ExceptionHolder::_tao_marshal__A_B_AMH_X3ExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
A::B::AMH_X3ExceptionHolder::_tao_unmarshal__A_B_AMH_X3ExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
A::B::AMH_X3ExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_X3ExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_X3ExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_X3ExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
A::B::AMH_X3ExceptionHolder::raise_getSeqOfX2 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
A::B::AMH_X3ExceptionHolder::raise_getX3 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
A::B::AMH_X3ExceptionHolder::raise_sendc_getSeqOfX2 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
A::B::AMH_X3ExceptionHolder::raise_sendc_getX3 ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for A::B::AMH_X3ResponseHandler.

A::B::AMH_X3ResponseHandler_ptr
TAO::Objref_Traits<A::B::AMH_X3ResponseHandler>::duplicate (A::B::AMH_X3ResponseHandler_ptr p)
{
  return A::B::AMH_X3ResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<A::B::AMH_X3ResponseHandler>::release (A::B::AMH_X3ResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

A::B::AMH_X3ResponseHandler_ptr
TAO::Objref_Traits<A::B::AMH_X3ResponseHandler>::nil ()
{
  return A::B::AMH_X3ResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<A::B::AMH_X3ResponseHandler>::marshal (const A::B::AMH_X3ResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



A::B::AMH_X3ResponseHandler::AMH_X3ResponseHandler ()
{}void
A::B::AMH_X3ResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_X3ResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_X3ResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

A::B::AMH_X3ResponseHandler_ptr
A::B::AMH_X3ResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_X3ResponseHandler::_duplicate (
      dynamic_cast<AMH_X3ResponseHandler_ptr> (_tao_objref));
}

A::B::AMH_X3ResponseHandler_ptr
A::B::AMH_X3ResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_X3ResponseHandler::_duplicate (
      dynamic_cast<AMH_X3ResponseHandler_ptr> (_tao_objref));
}

A::B::AMH_X3ResponseHandler_ptr
A::B::AMH_X3ResponseHandler::_nil ()
{
  return nullptr;
}

A::B::AMH_X3ResponseHandler_ptr
A::B::AMH_X3ResponseHandler::_duplicate (AMH_X3ResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
A::B::AMH_X3ResponseHandler::_tao_release (AMH_X3ResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
A::B::AMH_X3ResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:A/B/AMH_X3ResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* A::B::AMH_X3ResponseHandler::_interface_repository_id () const
{
  return "IDL:A/B/AMH_X3ResponseHandler:1.0";
}

const char* A::B::AMH_X3ResponseHandler::_desc_repository_id ()
{
  return "IDL:A/B/AMH_X3ResponseHandler:1.0";
}

const char* A::B::AMH_X3ResponseHandler::_desc_interface_name ()
{
  return "AMH_X3ResponseHandler";
}

::CORBA::Boolean
A::B::AMH_X3ResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_A_B_AMH_X3ResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:A/B/AMH_X3ResponseHandler:1.0",
    "AMH_X3ResponseHandler");
  

namespace A
{
  
  namespace B
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_X3ResponseHandler =
      &_tao_tc_A_B_AMH_X3ResponseHandler;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for A::B::AMI_X3Handler.

A::B::AMI_X3Handler_ptr
TAO::Objref_Traits<A::B::AMI_X3Handler>::duplicate (A::B::AMI_X3Handler_ptr p)
{
  return A::B::AMI_X3Handler::_duplicate (p);
}

void
TAO::Objref_Traits<A::B::AMI_X3Handler>::release (A::B::AMI_X3Handler_ptr p)
{
  ::CORBA::release (p);
}

A::B::AMI_X3Handler_ptr
TAO::Objref_Traits<A::B::AMI_X3Handler>::nil ()
{
  return A::B::AMI_X3Handler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<A::B::AMI_X3Handler>::marshal (const A::B::AMI_X3Handler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
A::B::AMI_X3Handler::getSeqOfX2 (
  const ::A::B::X2Seq & ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::A::B::X2Seq>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getSeqOfX2",
      10,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
A::B::AMI_X3Handler::getSeqOfX2_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  A::B::AMI_X3Handler_var _tao_reply_handler_object =
    A::B::AMI_X3Handler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::A::B::X2Seq ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val)
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->getSeqOfX2 (
          
          ami_return_val
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->getSeqOfX2_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
A::B::AMI_X3Handler::getSeqOfX2_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getSeqOfX2_excep",
      16,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
A::B::AMI_X3Handler::getX3 (
  const char * ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< char *>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getX3",
      5,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
A::B::AMI_X3Handler::getX3_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  A::B::AMI_X3Handler_var _tao_reply_handler_object =
    A::B::AMI_X3Handler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::CORBA::String_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->getX3 (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->getX3_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
A::B::AMI_X3Handler::getX3_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "getX3_excep",
      11,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

A::B::AMI_X3Handler::AMI_X3Handler ()
{
}
void
A::B::AMI_X3Handler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_X3Handler *_tao_tmp_pointer =
    static_cast<AMI_X3Handler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

A::B::AMI_X3Handler_ptr
A::B::AMI_X3Handler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_X3Handler>::narrow (_tao_objref, "IDL:A/B/AMI_X3Handler:1.0");
}

A::B::AMI_X3Handler_ptr
A::B::AMI_X3Handler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_X3Handler>::unchecked_narrow (_tao_objref);
}

A::B::AMI_X3Handler_ptr
A::B::AMI_X3Handler::_nil ()
{
  return nullptr;
}

A::B::AMI_X3Handler_ptr
A::B::AMI_X3Handler::_duplicate (AMI_X3Handler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
A::B::AMI_X3Handler::_tao_release (AMI_X3Handler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
A::B::AMI_X3Handler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:A/B/AMI_X1Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:A/B/AMI_X2Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:A/B/AMI_X3Handler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* A::B::AMI_X3Handler::_interface_repository_id () const
{
  return "IDL:A/B/AMI_X3Handler:1.0";
}

const char* A::B::AMI_X3Handler::_desc_repository_id ()
{
  return "IDL:A/B/AMI_X3Handler:1.0";
}

const char* A::B::AMI_X3Handler::_desc_interface_name ()
{
  return "AMI_X3Handler";
}

::CORBA::Boolean
A::B::AMI_X3Handler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_A_B_AMI_X3Handler (
    ::CORBA::tk_objref,
    "IDL:A/B/AMI_X3Handler:1.0",
    "AMI_X3Handler");
  

namespace A
{
  
  namespace B
  {
    ::CORBA::TypeCode_ptr const _tc_AMI_X3Handler =
      &_tao_tc_A_B_AMI_X3Handler;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for mA::A.

mA::A_ptr
TAO::Objref_Traits<mA::A>::duplicate (mA::A_ptr p)
{
  return mA::A::_duplicate (p);
}

void
TAO::Objref_Traits<mA::A>::release (mA::A_ptr p)
{
  ::CORBA::release (p);
}

mA::A_ptr
TAO::Objref_Traits<mA::A>::nil ()
{
  return mA::A::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<mA::A>::marshal (const mA::A_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::mB::B_ptr
mA::A::theB ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::mB::B>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_theB",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
mA::A::theB (
  ::mB::B_ptr theB)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::mB::B>::in_arg_val _tao_theB (theB);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_theB)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_theB",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
mA::A::sendc_set_theB (
  ::mA::AMI_AHandler_ptr ami_handler,
  ::mB::B_ptr theB)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::mB::B>::in_arg_val _tao_theB (theB);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_theB)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_theB",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &mA::AMI_AHandler::set_theB_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
mA::A::sendc_get_theB (
  ::mA::AMI_AHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_theB",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &mA::AMI_AHandler::get_theB_reply_stub
    );
}

mA::A::A ()
{
}
void
mA::A::_tao_any_destructor (void *_tao_void_pointer)
{
  A *_tao_tmp_pointer =
    static_cast<A *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

mA::A_ptr
mA::A::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<A>::narrow (_tao_objref, "IDL:mA/A:1.0");
}

mA::A_ptr
mA::A::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<A>::unchecked_narrow (_tao_objref);
}

mA::A_ptr
mA::A::_nil ()
{
  return nullptr;
}

mA::A_ptr
mA::A::_duplicate (A_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
mA::A::_tao_release (A_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
mA::A::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:mA/A:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* mA::A::_interface_repository_id () const
{
  return "IDL:mA/A:1.0";
}

const char* mA::A::_desc_repository_id ()
{
  return "IDL:mA/A:1.0";
}

const char* mA::A::_desc_interface_name ()
{
  return "A";
}

::CORBA::Boolean
mA::A::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_mA_A (
    ::CORBA::tk_objref,
    "IDL:mA/A:1.0",
    "A");
  

namespace mA
{
  ::CORBA::TypeCode_ptr const _tc_A =
    &_tao_tc_mA_A;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_mA_AMH_AExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_mA_AMH_AExceptionHolder (
    ::CORBA::tk_value,
    "IDL:mA/AMH_AExceptionHolder:1.0",
    "AMH_AExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_mA_AMH_AExceptionHolder,
    0);
  

namespace mA
{
  ::CORBA::TypeCode_ptr const _tc_AMH_AExceptionHolder =
    &_tao_tc_mA_AMH_AExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<mA::AMH_AExceptionHolder>::add_ref (mA::AMH_AExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<mA::AMH_AExceptionHolder>::remove_ref (mA::AMH_AExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<mA::AMH_AExceptionHolder>::release (mA::AMH_AExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



mA::AMH_AExceptionHolder *
mA::AMH_AExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::mA::AMH_AExceptionHolder *> (v);
}

const char *
mA::AMH_AExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
mA::AMH_AExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
mA::AMH_AExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_AExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_AExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr mA::AMH_AExceptionHolder::_tao_type () const
{
  return ::mA::_tc_AMH_AExceptionHolder;
}

mA::AMH_AExceptionHolder::~AMH_AExceptionHolder ()
{}

::CORBA::ValueBase *
mA::AMH_AExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_AExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
mA::AMH_AExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
mA::AMH_AExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
mA::AMH_AExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
mA::AMH_AExceptionHolder::_tao_marshal__mA_AMH_AExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
mA::AMH_AExceptionHolder::_tao_unmarshal__mA_AMH_AExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
mA::AMH_AExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_AExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_AExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_AExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
mA::AMH_AExceptionHolder::raise_get_theB ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
mA::AMH_AExceptionHolder::raise_set_theB ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
mA::AMH_AExceptionHolder::raise_sendc_set_theB ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
mA::AMH_AExceptionHolder::raise_sendc_get_theB ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for mA::AMH_AResponseHandler.

mA::AMH_AResponseHandler_ptr
TAO::Objref_Traits<mA::AMH_AResponseHandler>::duplicate (mA::AMH_AResponseHandler_ptr p)
{
  return mA::AMH_AResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<mA::AMH_AResponseHandler>::release (mA::AMH_AResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

mA::AMH_AResponseHandler_ptr
TAO::Objref_Traits<mA::AMH_AResponseHandler>::nil ()
{
  return mA::AMH_AResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<mA::AMH_AResponseHandler>::marshal (const mA::AMH_AResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



mA::AMH_AResponseHandler::AMH_AResponseHandler ()
{}void
mA::AMH_AResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_AResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_AResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

mA::AMH_AResponseHandler_ptr
mA::AMH_AResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_AResponseHandler::_duplicate (
      dynamic_cast<AMH_AResponseHandler_ptr> (_tao_objref));
}

mA::AMH_AResponseHandler_ptr
mA::AMH_AResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_AResponseHandler::_duplicate (
      dynamic_cast<AMH_AResponseHandler_ptr> (_tao_objref));
}

mA::AMH_AResponseHandler_ptr
mA::AMH_AResponseHandler::_nil ()
{
  return nullptr;
}

mA::AMH_AResponseHandler_ptr
mA::AMH_AResponseHandler::_duplicate (AMH_AResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
mA::AMH_AResponseHandler::_tao_release (AMH_AResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
mA::AMH_AResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:mA/AMH_AResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* mA::AMH_AResponseHandler::_interface_repository_id () const
{
  return "IDL:mA/AMH_AResponseHandler:1.0";
}

const char* mA::AMH_AResponseHandler::_desc_repository_id ()
{
  return "IDL:mA/AMH_AResponseHandler:1.0";
}

const char* mA::AMH_AResponseHandler::_desc_interface_name ()
{
  return "AMH_AResponseHandler";
}

::CORBA::Boolean
mA::AMH_AResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_mA_AMH_AResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:mA/AMH_AResponseHandler:1.0",
    "AMH_AResponseHandler");
  

namespace mA
{
  ::CORBA::TypeCode_ptr const _tc_AMH_AResponseHandler =
    &_tao_tc_mA_AMH_AResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for mA::AMI_AHandler.

mA::AMI_AHandler_ptr
TAO::Objref_Traits<mA::AMI_AHandler>::duplicate (mA::AMI_AHandler_ptr p)
{
  return mA::AMI_AHandler::_duplicate (p);
}

void
TAO::Objref_Traits<mA::AMI_AHandler>::release (mA::AMI_AHandler_ptr p)
{
  ::CORBA::release (p);
}

mA::AMI_AHandler_ptr
TAO::Objref_Traits<mA::AMI_AHandler>::nil ()
{
  return mA::AMI_AHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<mA::AMI_AHandler>::marshal (const mA::AMI_AHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
mA::AMI_AHandler::get_theB (
  ::mB::B_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::mB::B>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_theB",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
mA::AMI_AHandler::get_theB_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  mA::AMI_AHandler_var _tao_reply_handler_object =
    mA::AMI_AHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::mB::B_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_theB (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_theB_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
mA::AMI_AHandler::get_theB_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_theB_excep",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
mA::AMI_AHandler::set_theB ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_theB",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
mA::AMI_AHandler::set_theB_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  mA::AMI_AHandler_var _tao_reply_handler_object =
    mA::AMI_AHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_theB (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_theB_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
mA::AMI_AHandler::set_theB_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_theB_excep",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

mA::AMI_AHandler::AMI_AHandler ()
{
}
void
mA::AMI_AHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_AHandler *_tao_tmp_pointer =
    static_cast<AMI_AHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

mA::AMI_AHandler_ptr
mA::AMI_AHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_AHandler>::narrow (_tao_objref, "IDL:mA/AMI_AHandler:1.0");
}

mA::AMI_AHandler_ptr
mA::AMI_AHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_AHandler>::unchecked_narrow (_tao_objref);
}

mA::AMI_AHandler_ptr
mA::AMI_AHandler::_nil ()
{
  return nullptr;
}

mA::AMI_AHandler_ptr
mA::AMI_AHandler::_duplicate (AMI_AHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
mA::AMI_AHandler::_tao_release (AMI_AHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
mA::AMI_AHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:mA/AMI_AHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* mA::AMI_AHandler::_interface_repository_id () const
{
  return "IDL:mA/AMI_AHandler:1.0";
}

const char* mA::AMI_AHandler::_desc_repository_id ()
{
  return "IDL:mA/AMI_AHandler:1.0";
}

const char* mA::AMI_AHandler::_desc_interface_name ()
{
  return "AMI_AHandler";
}

::CORBA::Boolean
mA::AMI_AHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_mA_AMI_AHandler (
    ::CORBA::tk_objref,
    "IDL:mA/AMI_AHandler:1.0",
    "AMI_AHandler");
  

namespace mA
{
  ::CORBA::TypeCode_ptr const _tc_AMI_AHandler =
    &_tao_tc_mA_AMI_AHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for mB::B.

mB::B_ptr
TAO::Objref_Traits<mB::B>::duplicate (mB::B_ptr p)
{
  return mB::B::_duplicate (p);
}

void
TAO::Objref_Traits<mB::B>::release (mB::B_ptr p)
{
  ::CORBA::release (p);
}

mB::B_ptr
TAO::Objref_Traits<mB::B>::nil ()
{
  return mB::B::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<mB::B>::marshal (const mB::B_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

::mA::A_ptr
mB::B::theA ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::mA::A>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_theA",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);

  return _tao_retval.retn ();
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
mB::B::theA (
  ::mA::A_ptr theA)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::mA::A>::in_arg_val _tao_theA (theA);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_theA)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_theA",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
mB::B::sendc_set_theA (
  ::mB::AMI_BHandler_ptr ami_handler,
  ::mA::A_ptr theA)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  
  
  TAO::Arg_Traits<void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::mA::A>::in_arg_val _tao_theA (theA);

  TAO::Argument *_the_tao_operation_signature[] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_theA)
    };

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_theA",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &mB::AMI_BHandler::set_theA_reply_stub
    );
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/ami_cs.cpp:54



void
mB::B::sendc_get_theA (
  ::mB::AMI_BHandler_ptr ami_handler)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  

  TAO::Argument ** _the_tao_operation_signature {};

  TAO::Asynch_Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      0,
      "_get_theA",
      9,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
    );

  _invocation_call.invoke (
      ami_handler,
      &mB::AMI_BHandler::get_theA_reply_stub
    );
}

mB::B::B ()
{
}
void
mB::B::_tao_any_destructor (void *_tao_void_pointer)
{
  B *_tao_tmp_pointer =
    static_cast<B *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

mB::B_ptr
mB::B::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<B>::narrow (_tao_objref, "IDL:mB/B:1.0");
}

mB::B_ptr
mB::B::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<B>::unchecked_narrow (_tao_objref);
}

mB::B_ptr
mB::B::_nil ()
{
  return nullptr;
}

mB::B_ptr
mB::B::_duplicate (B_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
mB::B::_tao_release (B_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
mB::B::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:mA/A:1.0") == 0 ||
      std::strcmp (value, "IDL:mB/B:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* mB::B::_interface_repository_id () const
{
  return "IDL:mB/B:1.0";
}

const char* mB::B::_desc_repository_id ()
{
  return "IDL:mB/B:1.0";
}

const char* mB::B::_desc_interface_name ()
{
  return "B";
}

::CORBA::Boolean
mB::B::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_mB_B (
    ::CORBA::tk_objref,
    "IDL:mB/B:1.0",
    "B");
  

namespace mB
{
  ::CORBA::TypeCode_ptr const _tc_B =
    &_tao_tc_mB_B;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_mB_AMH_BExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_mB_AMH_BExceptionHolder (
    ::CORBA::tk_value,
    "IDL:mB/AMH_BExceptionHolder:1.0",
    "AMH_BExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_mB_AMH_BExceptionHolder,
    0);
  

namespace mB
{
  ::CORBA::TypeCode_ptr const _tc_AMH_BExceptionHolder =
    &_tao_tc_mB_AMH_BExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<mB::AMH_BExceptionHolder>::add_ref (mB::AMH_BExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<mB::AMH_BExceptionHolder>::remove_ref (mB::AMH_BExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<mB::AMH_BExceptionHolder>::release (mB::AMH_BExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



mB::AMH_BExceptionHolder *
mB::AMH_BExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::mB::AMH_BExceptionHolder *> (v);
}

const char *
mB::AMH_BExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
mB::AMH_BExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
mB::AMH_BExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_BExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr mB::AMH_BExceptionHolder::_tao_type () const
{
  return ::mB::_tc_AMH_BExceptionHolder;
}

mB::AMH_BExceptionHolder::~AMH_BExceptionHolder ()
{}

::CORBA::ValueBase *
mB::AMH_BExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_BExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
mB::AMH_BExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
mB::AMH_BExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
mB::AMH_BExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
mB::AMH_BExceptionHolder::_tao_marshal__mB_AMH_BExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
mB::AMH_BExceptionHolder::_tao_unmarshal__mB_AMH_BExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
mB::AMH_BExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_BExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_BExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_BExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
mB::AMH_BExceptionHolder::raise_get_theA ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
mB::AMH_BExceptionHolder::raise_set_theA ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
mB::AMH_BExceptionHolder::raise_sendc_set_theA ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:442

void
mB::AMH_BExceptionHolder::raise_sendc_get_theA ()
{
  std::unique_ptr< ::CORBA::Exception> safety (this->exception);
  this->exception->_raise ();
}

// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for mB::AMH_BResponseHandler.

mB::AMH_BResponseHandler_ptr
TAO::Objref_Traits<mB::AMH_BResponseHandler>::duplicate (mB::AMH_BResponseHandler_ptr p)
{
  return mB::AMH_BResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<mB::AMH_BResponseHandler>::release (mB::AMH_BResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

mB::AMH_BResponseHandler_ptr
TAO::Objref_Traits<mB::AMH_BResponseHandler>::nil ()
{
  return mB::AMH_BResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<mB::AMH_BResponseHandler>::marshal (const mB::AMH_BResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



mB::AMH_BResponseHandler::AMH_BResponseHandler ()
{}void
mB::AMH_BResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_BResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

mB::AMH_BResponseHandler_ptr
mB::AMH_BResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_BResponseHandler::_duplicate (
      dynamic_cast<AMH_BResponseHandler_ptr> (_tao_objref));
}

mB::AMH_BResponseHandler_ptr
mB::AMH_BResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_BResponseHandler::_duplicate (
      dynamic_cast<AMH_BResponseHandler_ptr> (_tao_objref));
}

mB::AMH_BResponseHandler_ptr
mB::AMH_BResponseHandler::_nil ()
{
  return nullptr;
}

mB::AMH_BResponseHandler_ptr
mB::AMH_BResponseHandler::_duplicate (AMH_BResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
mB::AMH_BResponseHandler::_tao_release (AMH_BResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
mB::AMH_BResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:mB/AMH_BResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* mB::AMH_BResponseHandler::_interface_repository_id () const
{
  return "IDL:mB/AMH_BResponseHandler:1.0";
}

const char* mB::AMH_BResponseHandler::_desc_repository_id ()
{
  return "IDL:mB/AMH_BResponseHandler:1.0";
}

const char* mB::AMH_BResponseHandler::_desc_interface_name ()
{
  return "AMH_BResponseHandler";
}

::CORBA::Boolean
mB::AMH_BResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_mB_AMH_BResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:mB/AMH_BResponseHandler:1.0",
    "AMH_BResponseHandler");
  

namespace mB
{
  ::CORBA::TypeCode_ptr const _tc_AMH_BResponseHandler =
    &_tao_tc_mB_AMH_BResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for mB::AMI_BHandler.

mB::AMI_BHandler_ptr
TAO::Objref_Traits<mB::AMI_BHandler>::duplicate (mB::AMI_BHandler_ptr p)
{
  return mB::AMI_BHandler::_duplicate (p);
}

void
TAO::Objref_Traits<mB::AMI_BHandler>::release (mB::AMI_BHandler_ptr p)
{
  ::CORBA::release (p);
}

mB::AMI_BHandler_ptr
TAO::Objref_Traits<mB::AMI_BHandler>::nil ()
{
  return mB::AMI_BHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<mB::AMI_BHandler>::marshal (const mB::AMI_BHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
mB::AMI_BHandler::get_theA (
  ::mA::A_ptr ami_return_val)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::mA::A>::in_arg_val _tao_ami_return_val (ami_return_val);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_ami_return_val)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_theA",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

void
mB::AMI_BHandler::get_theA_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  mB::AMI_BHandler_var _tao_reply_handler_object =
    mB::AMI_BHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {

      ::mA::A_var ami_return_val;      // Demarshall all the arguments.
      if (!(

            (_tao_in >> ami_return_val.out ())
         ))
        throw ::CORBA::MARSHAL ();
      
      // Invoke the call back method.
      _tao_reply_handler_object->get_theA (
          
          ami_return_val.in ()
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->get_theA_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
mB::AMI_BHandler::get_theA_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_theA_excep",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
mB::AMI_BHandler::set_theA ()
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      1,
      "set_theA",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _invocation_call.invoke (nullptr, 0);
}

void
mB::AMI_BHandler::set_theA_reply_stub (
  TAO_InputCDR &_tao_in,
  ::Messaging::ReplyHandler_ptr _tao_reply_handler,
  ::CORBA::ULong reply_status)
{
  // Retrieve Reply Handler object.
  mB::AMI_BHandler_var _tao_reply_handler_object =
    mB::AMI_BHandler::_narrow (_tao_reply_handler);

  // Exception handling
  switch (reply_status)
  {
    case TAO_AMI_REPLY_OK:
    {
      // Demarshall all the arguments.
      // Invoke the call back method.
      _tao_reply_handler_object->set_theA (
          
        );
      break;
    }
    case TAO_AMI_REPLY_USER_EXCEPTION:
    case TAO_AMI_REPLY_SYSTEM_EXCEPTION:
    {
      const ACE_Message_Block* cdr = _tao_in.start ();
      ::CORBA::OctetSeq _tao_marshaled_exception (
          static_cast <CORBA::ULong> (cdr->length ()),
          static_cast <CORBA::ULong> (cdr->length ()),
          reinterpret_cast <unsigned char*> (cdr->rd_ptr ()),
          0);
      ::Messaging::ExceptionHolder* exception_holder_ptr {};
      ACE_NEW (
          exception_holder_ptr,
          ::TAO::ExceptionHolder (
            (reply_status == TAO_AMI_REPLY_SYSTEM_EXCEPTION),
            _tao_in.byte_order (),
            _tao_marshaled_exception,
            0,
            0,
            _tao_in.char_translator (),
            _tao_in.wchar_translator ()));
        
      ::Messaging::ExceptionHolder_var exception_holder_var = exception_holder_ptr;
      _tao_reply_handler_object->set_theA_excep (
          exception_holder_var);
      break;
    }
    case TAO_AMI_REPLY_NOT_OK:
      // @@ Michael: Not even the spec mentions this case.
      //             We have to think about this case.
      break;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_operation/operation_cs.cpp:87

void
mB::AMI_BHandler::set_theA_excep (
  ::Messaging::ExceptionHolder * excep_holder)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Messaging::ExceptionHolder>::in_arg_val _tao_excep_holder (excep_holder);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      std::addressof(_tao_retval),
      std::addressof(_tao_excep_holder)
    };

  TAO::Invocation_Adapter _invocation_call (
      this,
      _the_tao_operation_signature,
      2,
      "set_theA_excep",
      14,
      TAO::TAO_CO_NONE | TAO::TAO_CO_DIRECT_STRATEGY | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _invocation_call.invoke (nullptr, 0);
}

mB::AMI_BHandler::AMI_BHandler ()
{
}
void
mB::AMI_BHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_BHandler *_tao_tmp_pointer =
    static_cast<AMI_BHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

mB::AMI_BHandler_ptr
mB::AMI_BHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_BHandler>::narrow (_tao_objref, "IDL:mB/AMI_BHandler:1.0");
}

mB::AMI_BHandler_ptr
mB::AMI_BHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_BHandler>::unchecked_narrow (_tao_objref);
}

mB::AMI_BHandler_ptr
mB::AMI_BHandler::_nil ()
{
  return nullptr;
}

mB::AMI_BHandler_ptr
mB::AMI_BHandler::_duplicate (AMI_BHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
mB::AMI_BHandler::_tao_release (AMI_BHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
mB::AMI_BHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:mA/AMI_AHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:mB/AMI_BHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* mB::AMI_BHandler::_interface_repository_id () const
{
  return "IDL:mB/AMI_BHandler:1.0";
}

const char* mB::AMI_BHandler::_desc_repository_id ()
{
  return "IDL:mB/AMI_BHandler:1.0";
}

const char* mB::AMI_BHandler::_desc_interface_name ()
{
  return "AMI_BHandler";
}

::CORBA::Boolean
mB::AMI_BHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_mB_AMI_BHandler (
    ::CORBA::tk_objref,
    "IDL:mB/AMI_BHandler:1.0",
    "AMI_BHandler");
  

namespace mB
{
  ::CORBA::TypeCode_ptr const _tc_AMI_BHandler =
    &_tao_tc_mB_AMI_BHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for mC::C.

mC::C_ptr
TAO::Objref_Traits<mC::C>::duplicate (mC::C_ptr p)
{
  return mC::C::_duplicate (p);
}

void
TAO::Objref_Traits<mC::C>::release (mC::C_ptr p)
{
  ::CORBA::release (p);
}

mC::C_ptr
TAO::Objref_Traits<mC::C>::nil ()
{
  return mC::C::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<mC::C>::marshal (const mC::C_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



mC::C::C ()
{
}
void
mC::C::_tao_any_destructor (void *_tao_void_pointer)
{
  C *_tao_tmp_pointer =
    static_cast<C *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

mC::C_ptr
mC::C::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<C>::narrow (_tao_objref, "IDL:mC/C:1.0");
}

mC::C_ptr
mC::C::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<C>::unchecked_narrow (_tao_objref);
}

mC::C_ptr
mC::C::_nil ()
{
  return nullptr;
}

mC::C_ptr
mC::C::_duplicate (C_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
mC::C::_tao_release (C_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
mC::C::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:mA/A:1.0") == 0 ||
      std::strcmp (value, "IDL:mB/B:1.0") == 0 ||
      std::strcmp (value, "IDL:mC/C:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* mC::C::_interface_repository_id () const
{
  return "IDL:mC/C:1.0";
}

const char* mC::C::_desc_repository_id ()
{
  return "IDL:mC/C:1.0";
}

const char* mC::C::_desc_interface_name ()
{
  return "C";
}

::CORBA::Boolean
mC::C::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_mC_C (
    ::CORBA::tk_objref,
    "IDL:mC/C:1.0",
    "C");
  

namespace mC
{
  ::CORBA::TypeCode_ptr const _tc_C =
    &_tao_tc_mC_C;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_mC_AMH_CExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_mC_AMH_CExceptionHolder (
    ::CORBA::tk_value,
    "IDL:mC/AMH_CExceptionHolder:1.0",
    "AMH_CExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_mC_AMH_CExceptionHolder,
    0);
  

namespace mC
{
  ::CORBA::TypeCode_ptr const _tc_AMH_CExceptionHolder =
    &_tao_tc_mC_AMH_CExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<mC::AMH_CExceptionHolder>::add_ref (mC::AMH_CExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<mC::AMH_CExceptionHolder>::remove_ref (mC::AMH_CExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<mC::AMH_CExceptionHolder>::release (mC::AMH_CExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



mC::AMH_CExceptionHolder *
mC::AMH_CExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::mC::AMH_CExceptionHolder *> (v);
}

const char *
mC::AMH_CExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
mC::AMH_CExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
mC::AMH_CExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_CExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_CExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr mC::AMH_CExceptionHolder::_tao_type () const
{
  return ::mC::_tc_AMH_CExceptionHolder;
}

mC::AMH_CExceptionHolder::~AMH_CExceptionHolder ()
{}

::CORBA::ValueBase *
mC::AMH_CExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_CExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
mC::AMH_CExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
mC::AMH_CExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
mC::AMH_CExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
mC::AMH_CExceptionHolder::_tao_marshal__mC_AMH_CExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
mC::AMH_CExceptionHolder::_tao_unmarshal__mC_AMH_CExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
mC::AMH_CExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_CExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_CExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_CExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



mC::AMH_CExceptionHolder_init::AMH_CExceptionHolder_init ()
{
}

mC::AMH_CExceptionHolder_init::~AMH_CExceptionHolder_init ()
{
}

mC::AMH_CExceptionHolder_init *
mC::AMH_CExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::mC::AMH_CExceptionHolder_init *> (v);
}

const char*
mC::AMH_CExceptionHolder_init::tao_repository_id ()
{
  return ::mC::AMH_CExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
mC::AMH_CExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_mC::AMH_CExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for mC::AMH_CResponseHandler.

mC::AMH_CResponseHandler_ptr
TAO::Objref_Traits<mC::AMH_CResponseHandler>::duplicate (mC::AMH_CResponseHandler_ptr p)
{
  return mC::AMH_CResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<mC::AMH_CResponseHandler>::release (mC::AMH_CResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

mC::AMH_CResponseHandler_ptr
TAO::Objref_Traits<mC::AMH_CResponseHandler>::nil ()
{
  return mC::AMH_CResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<mC::AMH_CResponseHandler>::marshal (const mC::AMH_CResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



mC::AMH_CResponseHandler::AMH_CResponseHandler ()
{}void
mC::AMH_CResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_CResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_CResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

mC::AMH_CResponseHandler_ptr
mC::AMH_CResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_CResponseHandler::_duplicate (
      dynamic_cast<AMH_CResponseHandler_ptr> (_tao_objref));
}

mC::AMH_CResponseHandler_ptr
mC::AMH_CResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_CResponseHandler::_duplicate (
      dynamic_cast<AMH_CResponseHandler_ptr> (_tao_objref));
}

mC::AMH_CResponseHandler_ptr
mC::AMH_CResponseHandler::_nil ()
{
  return nullptr;
}

mC::AMH_CResponseHandler_ptr
mC::AMH_CResponseHandler::_duplicate (AMH_CResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
mC::AMH_CResponseHandler::_tao_release (AMH_CResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
mC::AMH_CResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:mC/AMH_CResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* mC::AMH_CResponseHandler::_interface_repository_id () const
{
  return "IDL:mC/AMH_CResponseHandler:1.0";
}

const char* mC::AMH_CResponseHandler::_desc_repository_id ()
{
  return "IDL:mC/AMH_CResponseHandler:1.0";
}

const char* mC::AMH_CResponseHandler::_desc_interface_name ()
{
  return "AMH_CResponseHandler";
}

::CORBA::Boolean
mC::AMH_CResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_mC_AMH_CResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:mC/AMH_CResponseHandler:1.0",
    "AMH_CResponseHandler");
  

namespace mC
{
  ::CORBA::TypeCode_ptr const _tc_AMH_CResponseHandler =
    &_tao_tc_mC_AMH_CResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for mC::AMI_CHandler.

mC::AMI_CHandler_ptr
TAO::Objref_Traits<mC::AMI_CHandler>::duplicate (mC::AMI_CHandler_ptr p)
{
  return mC::AMI_CHandler::_duplicate (p);
}

void
TAO::Objref_Traits<mC::AMI_CHandler>::release (mC::AMI_CHandler_ptr p)
{
  ::CORBA::release (p);
}

mC::AMI_CHandler_ptr
TAO::Objref_Traits<mC::AMI_CHandler>::nil ()
{
  return mC::AMI_CHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<mC::AMI_CHandler>::marshal (const mC::AMI_CHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



mC::AMI_CHandler::AMI_CHandler ()
{
}
void
mC::AMI_CHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_CHandler *_tao_tmp_pointer =
    static_cast<AMI_CHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

mC::AMI_CHandler_ptr
mC::AMI_CHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_CHandler>::narrow (_tao_objref, "IDL:mC/AMI_CHandler:1.0");
}

mC::AMI_CHandler_ptr
mC::AMI_CHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_CHandler>::unchecked_narrow (_tao_objref);
}

mC::AMI_CHandler_ptr
mC::AMI_CHandler::_nil ()
{
  return nullptr;
}

mC::AMI_CHandler_ptr
mC::AMI_CHandler::_duplicate (AMI_CHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
mC::AMI_CHandler::_tao_release (AMI_CHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
mC::AMI_CHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:mA/AMI_AHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:mB/AMI_BHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:mC/AMI_CHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* mC::AMI_CHandler::_interface_repository_id () const
{
  return "IDL:mC/AMI_CHandler:1.0";
}

const char* mC::AMI_CHandler::_desc_repository_id ()
{
  return "IDL:mC/AMI_CHandler:1.0";
}

const char* mC::AMI_CHandler::_desc_interface_name ()
{
  return "AMI_CHandler";
}

::CORBA::Boolean
mC::AMI_CHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_mC_AMI_CHandler (
    ::CORBA::tk_objref,
    "IDL:mC/AMI_CHandler:1.0",
    "AMI_CHandler");
  

namespace mC
{
  ::CORBA::TypeCode_ptr const _tc_AMI_CHandler =
    &_tao_tc_mC_AMI_CHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Schmoik::foo.

Schmoik::foo_ptr
TAO::Objref_Traits<Schmoik::foo>::duplicate (Schmoik::foo_ptr p)
{
  return Schmoik::foo::_duplicate (p);
}

void
TAO::Objref_Traits<Schmoik::foo>::release (Schmoik::foo_ptr p)
{
  ::CORBA::release (p);
}

Schmoik::foo_ptr
TAO::Objref_Traits<Schmoik::foo>::nil ()
{
  return Schmoik::foo::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Schmoik::foo>::marshal (const Schmoik::foo_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Schmoik_foo_foo_type (
    ::CORBA::tk_alias,
    "IDL:Schmoik/foo/foo_type:1.0",
    "foo_type",
    &CORBA::_tc_string);
  
::CORBA::TypeCode_ptr const Schmoik::foo::_tc_foo_type =
  &_tao_tc_Schmoik_foo_foo_type;

Schmoik::foo::foo ()
{
}
void
Schmoik::foo::_tao_any_destructor (void *_tao_void_pointer)
{
  foo *_tao_tmp_pointer =
    static_cast<foo *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Schmoik::foo_ptr
Schmoik::foo::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<foo>::narrow (_tao_objref, "IDL:Schmoik/foo:1.0");
}

Schmoik::foo_ptr
Schmoik::foo::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<foo>::unchecked_narrow (_tao_objref);
}

Schmoik::foo_ptr
Schmoik::foo::_nil ()
{
  return nullptr;
}

Schmoik::foo_ptr
Schmoik::foo::_duplicate (foo_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Schmoik::foo::_tao_release (foo_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Schmoik::foo::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Schmoik/foo:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Schmoik::foo::_interface_repository_id () const
{
  return "IDL:Schmoik/foo:1.0";
}

const char* Schmoik::foo::_desc_repository_id ()
{
  return "IDL:Schmoik/foo:1.0";
}

const char* Schmoik::foo::_desc_interface_name ()
{
  return "foo";
}

::CORBA::Boolean
Schmoik::foo::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Schmoik_foo (
    ::CORBA::tk_objref,
    "IDL:Schmoik/foo:1.0",
    "foo");
  

namespace Schmoik
{
  ::CORBA::TypeCode_ptr const _tc_foo =
    &_tao_tc_Schmoik_foo;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_Schmoik_AMH_fooExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_Schmoik_AMH_fooExceptionHolder (
    ::CORBA::tk_value,
    "IDL:Schmoik/AMH_fooExceptionHolder:1.0",
    "AMH_fooExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Schmoik_AMH_fooExceptionHolder,
    0);
  

namespace Schmoik
{
  ::CORBA::TypeCode_ptr const _tc_AMH_fooExceptionHolder =
    &_tao_tc_Schmoik_AMH_fooExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<Schmoik::AMH_fooExceptionHolder>::add_ref (Schmoik::AMH_fooExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Schmoik::AMH_fooExceptionHolder>::remove_ref (Schmoik::AMH_fooExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Schmoik::AMH_fooExceptionHolder>::release (Schmoik::AMH_fooExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Schmoik::AMH_fooExceptionHolder *
Schmoik::AMH_fooExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::Schmoik::AMH_fooExceptionHolder *> (v);
}

const char *
Schmoik::AMH_fooExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
Schmoik::AMH_fooExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Schmoik::AMH_fooExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_fooExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_fooExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Schmoik::AMH_fooExceptionHolder::_tao_type () const
{
  return ::Schmoik::_tc_AMH_fooExceptionHolder;
}

Schmoik::AMH_fooExceptionHolder::~AMH_fooExceptionHolder ()
{}

::CORBA::ValueBase *
Schmoik::AMH_fooExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_fooExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
Schmoik::AMH_fooExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
Schmoik::AMH_fooExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
Schmoik::AMH_fooExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
Schmoik::AMH_fooExceptionHolder::_tao_marshal__Schmoik_AMH_fooExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
Schmoik::AMH_fooExceptionHolder::_tao_unmarshal__Schmoik_AMH_fooExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
Schmoik::AMH_fooExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_fooExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_fooExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_fooExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



Schmoik::AMH_fooExceptionHolder_init::AMH_fooExceptionHolder_init ()
{
}

Schmoik::AMH_fooExceptionHolder_init::~AMH_fooExceptionHolder_init ()
{
}

Schmoik::AMH_fooExceptionHolder_init *
Schmoik::AMH_fooExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::Schmoik::AMH_fooExceptionHolder_init *> (v);
}

const char*
Schmoik::AMH_fooExceptionHolder_init::tao_repository_id ()
{
  return ::Schmoik::AMH_fooExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
Schmoik::AMH_fooExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_Schmoik::AMH_fooExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Schmoik::AMH_fooResponseHandler.

Schmoik::AMH_fooResponseHandler_ptr
TAO::Objref_Traits<Schmoik::AMH_fooResponseHandler>::duplicate (Schmoik::AMH_fooResponseHandler_ptr p)
{
  return Schmoik::AMH_fooResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Schmoik::AMH_fooResponseHandler>::release (Schmoik::AMH_fooResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

Schmoik::AMH_fooResponseHandler_ptr
TAO::Objref_Traits<Schmoik::AMH_fooResponseHandler>::nil ()
{
  return Schmoik::AMH_fooResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Schmoik::AMH_fooResponseHandler>::marshal (const Schmoik::AMH_fooResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Schmoik::AMH_fooResponseHandler::AMH_fooResponseHandler ()
{}void
Schmoik::AMH_fooResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_fooResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_fooResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Schmoik::AMH_fooResponseHandler_ptr
Schmoik::AMH_fooResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_fooResponseHandler::_duplicate (
      dynamic_cast<AMH_fooResponseHandler_ptr> (_tao_objref));
}

Schmoik::AMH_fooResponseHandler_ptr
Schmoik::AMH_fooResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_fooResponseHandler::_duplicate (
      dynamic_cast<AMH_fooResponseHandler_ptr> (_tao_objref));
}

Schmoik::AMH_fooResponseHandler_ptr
Schmoik::AMH_fooResponseHandler::_nil ()
{
  return nullptr;
}

Schmoik::AMH_fooResponseHandler_ptr
Schmoik::AMH_fooResponseHandler::_duplicate (AMH_fooResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Schmoik::AMH_fooResponseHandler::_tao_release (AMH_fooResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Schmoik::AMH_fooResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Schmoik/AMH_fooResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* Schmoik::AMH_fooResponseHandler::_interface_repository_id () const
{
  return "IDL:Schmoik/AMH_fooResponseHandler:1.0";
}

const char* Schmoik::AMH_fooResponseHandler::_desc_repository_id ()
{
  return "IDL:Schmoik/AMH_fooResponseHandler:1.0";
}

const char* Schmoik::AMH_fooResponseHandler::_desc_interface_name ()
{
  return "AMH_fooResponseHandler";
}

::CORBA::Boolean
Schmoik::AMH_fooResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Schmoik_AMH_fooResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:Schmoik/AMH_fooResponseHandler:1.0",
    "AMH_fooResponseHandler");
  

namespace Schmoik
{
  ::CORBA::TypeCode_ptr const _tc_AMH_fooResponseHandler =
    &_tao_tc_Schmoik_AMH_fooResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Schmoik::AMI_fooHandler.

Schmoik::AMI_fooHandler_ptr
TAO::Objref_Traits<Schmoik::AMI_fooHandler>::duplicate (Schmoik::AMI_fooHandler_ptr p)
{
  return Schmoik::AMI_fooHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Schmoik::AMI_fooHandler>::release (Schmoik::AMI_fooHandler_ptr p)
{
  ::CORBA::release (p);
}

Schmoik::AMI_fooHandler_ptr
TAO::Objref_Traits<Schmoik::AMI_fooHandler>::nil ()
{
  return Schmoik::AMI_fooHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Schmoik::AMI_fooHandler>::marshal (const Schmoik::AMI_fooHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Schmoik::AMI_fooHandler::AMI_fooHandler ()
{
}
void
Schmoik::AMI_fooHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_fooHandler *_tao_tmp_pointer =
    static_cast<AMI_fooHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Schmoik::AMI_fooHandler_ptr
Schmoik::AMI_fooHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_fooHandler>::narrow (_tao_objref, "IDL:Schmoik/AMI_fooHandler:1.0");
}

Schmoik::AMI_fooHandler_ptr
Schmoik::AMI_fooHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_fooHandler>::unchecked_narrow (_tao_objref);
}

Schmoik::AMI_fooHandler_ptr
Schmoik::AMI_fooHandler::_nil ()
{
  return nullptr;
}

Schmoik::AMI_fooHandler_ptr
Schmoik::AMI_fooHandler::_duplicate (AMI_fooHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Schmoik::AMI_fooHandler::_tao_release (AMI_fooHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Schmoik::AMI_fooHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:Schmoik/AMI_fooHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Schmoik::AMI_fooHandler::_interface_repository_id () const
{
  return "IDL:Schmoik/AMI_fooHandler:1.0";
}

const char* Schmoik::AMI_fooHandler::_desc_repository_id ()
{
  return "IDL:Schmoik/AMI_fooHandler:1.0";
}

const char* Schmoik::AMI_fooHandler::_desc_interface_name ()
{
  return "AMI_fooHandler";
}

::CORBA::Boolean
Schmoik::AMI_fooHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Schmoik_AMI_fooHandler (
    ::CORBA::tk_objref,
    "IDL:Schmoik/AMI_fooHandler:1.0",
    "AMI_fooHandler");
  

namespace Schmoik
{
  ::CORBA::TypeCode_ptr const _tc_AMI_fooHandler =
    &_tao_tc_Schmoik_AMI_fooHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Schmoik_bar[] =
      {
        { "member", &Schmoik::foo::_tc_foo_type }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Schmoik_bar (
  ::CORBA::tk_struct,
  "IDL:Schmoik/bar:1.0",
  "bar",
  _tao_fields_Schmoik_bar,
  1);


namespace Schmoik
{
  ::CORBA::TypeCode_ptr const _tc_bar =
    &_tao_tc_Schmoik_bar;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/structure_cs.cpp:55

void
Schmoik::bar::_tao_any_destructor (
    void *_tao_void_pointer)
{
  bar *_tao_tmp_pointer =
    static_cast<bar *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/sequence_cs.cpp:104



#if !defined (_THWOIK_UB_TESTTYPESEQ_CS_)
#define _THWOIK_UB_TESTTYPESEQ_CS_

Thwoik::ub_TestTypeSeq::ub_TestTypeSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        TestType,
        TestType_var
      > (max)
{}

Thwoik::ub_TestTypeSeq::ub_TestTypeSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Thwoik::TestType_ptr * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_object_reference_sequence<
        TestType,
        TestType_var
      >
    (max, length, buffer, release)
{}

void Thwoik::ub_TestTypeSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  ub_TestTypeSeq * _tao_tmp_pointer =
    static_cast<ub_TestTypeSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:457


namespace Thwoik
{
  extern ::CORBA::TypeCode_ptr const _tc_TestType;
}

#ifndef _TAO_TYPECODE_Thwoik_ub_TestTypeSeq_GUARD
#define _TAO_TYPECODE_Thwoik_ub_TestTypeSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Thwoik_ub_TestTypeSeq_0 (
          ::CORBA::tk_sequence,
          &Thwoik::_tc_TestType,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Thwoik_ub_TestTypeSeq_0 =
        &Thwoik_ub_TestTypeSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Thwoik_ub_TestTypeSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Thwoik_ub_TestTypeSeq (
    ::CORBA::tk_alias,
    "IDL:Thwoik/ub_TestTypeSeq:1.0",
    "ub_TestTypeSeq",
    &TAO::TypeCode::tc_Thwoik_ub_TestTypeSeq_0);
  

namespace Thwoik
{
  ::CORBA::TypeCode_ptr const _tc_ub_TestTypeSeq =
    &_tao_tc_Thwoik_ub_TestTypeSeq;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/sequence_cs.cpp:104



#if !defined (_THWOIK_BD_TESTTYPESEQ_CS_)
#define _THWOIK_BD_TESTTYPESEQ_CS_

Thwoik::bd_TestTypeSeq::bd_TestTypeSeq (
    ::CORBA::ULong length,
    Thwoik::TestType_ptr * buffer,
    ::CORBA::Boolean release)
  : ::TAO::bounded_object_reference_sequence<
        TestType,
        TestType_var,
        3
      >
    (length, buffer, release)
{}

void Thwoik::bd_TestTypeSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  bd_TestTypeSeq * _tao_tmp_pointer =
    static_cast<bd_TestTypeSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:457


namespace Thwoik
{
  extern ::CORBA::TypeCode_ptr const _tc_TestType;
}

#ifndef _TAO_TYPECODE_Thwoik_bd_TestTypeSeq_GUARD
#define _TAO_TYPECODE_Thwoik_bd_TestTypeSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Thwoik_bd_TestTypeSeq_3 (
          ::CORBA::tk_sequence,
          &Thwoik::_tc_TestType,
          3U);
        
      ::CORBA::TypeCode_ptr const tc_Thwoik_bd_TestTypeSeq_3 =
        &Thwoik_bd_TestTypeSeq_3;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Thwoik_bd_TestTypeSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Thwoik_bd_TestTypeSeq (
    ::CORBA::tk_alias,
    "IDL:Thwoik/bd_TestTypeSeq:1.0",
    "bd_TestTypeSeq",
    &TAO::TypeCode::tc_Thwoik_bd_TestTypeSeq_3);
  

namespace Thwoik
{
  ::CORBA::TypeCode_ptr const _tc_bd_TestTypeSeq =
    &_tao_tc_Thwoik_bd_TestTypeSeq;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Thwoik::TestType.

Thwoik::TestType_ptr
TAO::Objref_Traits<Thwoik::TestType>::duplicate (Thwoik::TestType_ptr p)
{
  return Thwoik::TestType::_duplicate (p);
}

void
TAO::Objref_Traits<Thwoik::TestType>::release (Thwoik::TestType_ptr p)
{
  ::CORBA::release (p);
}

Thwoik::TestType_ptr
TAO::Objref_Traits<Thwoik::TestType>::nil ()
{
  return Thwoik::TestType::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Thwoik::TestType>::marshal (const Thwoik::TestType_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Thwoik::TestType::TestType ()
{
}
void
Thwoik::TestType::_tao_any_destructor (void *_tao_void_pointer)
{
  TestType *_tao_tmp_pointer =
    static_cast<TestType *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Thwoik::TestType_ptr
Thwoik::TestType::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<TestType>::narrow (_tao_objref, "IDL:Thwoik/TestType:1.0");
}

Thwoik::TestType_ptr
Thwoik::TestType::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<TestType>::unchecked_narrow (_tao_objref);
}

Thwoik::TestType_ptr
Thwoik::TestType::_nil ()
{
  return nullptr;
}

Thwoik::TestType_ptr
Thwoik::TestType::_duplicate (TestType_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Thwoik::TestType::_tao_release (TestType_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Thwoik::TestType::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Thwoik/TestType:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Thwoik::TestType::_interface_repository_id () const
{
  return "IDL:Thwoik/TestType:1.0";
}

const char* Thwoik::TestType::_desc_repository_id ()
{
  return "IDL:Thwoik/TestType:1.0";
}

const char* Thwoik::TestType::_desc_interface_name ()
{
  return "TestType";
}

::CORBA::Boolean
Thwoik::TestType::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Thwoik_TestType (
    ::CORBA::tk_objref,
    "IDL:Thwoik/TestType:1.0",
    "TestType");
  

namespace Thwoik
{
  ::CORBA::TypeCode_ptr const _tc_TestType =
    &_tao_tc_Thwoik_TestType;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_Thwoik_AMH_TestTypeExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_Thwoik_AMH_TestTypeExceptionHolder (
    ::CORBA::tk_value,
    "IDL:Thwoik/AMH_TestTypeExceptionHolder:1.0",
    "AMH_TestTypeExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Thwoik_AMH_TestTypeExceptionHolder,
    0);
  

namespace Thwoik
{
  ::CORBA::TypeCode_ptr const _tc_AMH_TestTypeExceptionHolder =
    &_tao_tc_Thwoik_AMH_TestTypeExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<Thwoik::AMH_TestTypeExceptionHolder>::add_ref (Thwoik::AMH_TestTypeExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Thwoik::AMH_TestTypeExceptionHolder>::remove_ref (Thwoik::AMH_TestTypeExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Thwoik::AMH_TestTypeExceptionHolder>::release (Thwoik::AMH_TestTypeExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Thwoik::AMH_TestTypeExceptionHolder *
Thwoik::AMH_TestTypeExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::Thwoik::AMH_TestTypeExceptionHolder *> (v);
}

const char *
Thwoik::AMH_TestTypeExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
Thwoik::AMH_TestTypeExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Thwoik::AMH_TestTypeExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_TestTypeExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_TestTypeExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Thwoik::AMH_TestTypeExceptionHolder::_tao_type () const
{
  return ::Thwoik::_tc_AMH_TestTypeExceptionHolder;
}

Thwoik::AMH_TestTypeExceptionHolder::~AMH_TestTypeExceptionHolder ()
{}

::CORBA::ValueBase *
Thwoik::AMH_TestTypeExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_TestTypeExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
Thwoik::AMH_TestTypeExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
Thwoik::AMH_TestTypeExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
Thwoik::AMH_TestTypeExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
Thwoik::AMH_TestTypeExceptionHolder::_tao_marshal__Thwoik_AMH_TestTypeExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
Thwoik::AMH_TestTypeExceptionHolder::_tao_unmarshal__Thwoik_AMH_TestTypeExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
Thwoik::AMH_TestTypeExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_TestTypeExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_TestTypeExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_TestTypeExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



Thwoik::AMH_TestTypeExceptionHolder_init::AMH_TestTypeExceptionHolder_init ()
{
}

Thwoik::AMH_TestTypeExceptionHolder_init::~AMH_TestTypeExceptionHolder_init ()
{
}

Thwoik::AMH_TestTypeExceptionHolder_init *
Thwoik::AMH_TestTypeExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::Thwoik::AMH_TestTypeExceptionHolder_init *> (v);
}

const char*
Thwoik::AMH_TestTypeExceptionHolder_init::tao_repository_id ()
{
  return ::Thwoik::AMH_TestTypeExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
Thwoik::AMH_TestTypeExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_Thwoik::AMH_TestTypeExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Thwoik::AMH_TestTypeResponseHandler.

Thwoik::AMH_TestTypeResponseHandler_ptr
TAO::Objref_Traits<Thwoik::AMH_TestTypeResponseHandler>::duplicate (Thwoik::AMH_TestTypeResponseHandler_ptr p)
{
  return Thwoik::AMH_TestTypeResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Thwoik::AMH_TestTypeResponseHandler>::release (Thwoik::AMH_TestTypeResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

Thwoik::AMH_TestTypeResponseHandler_ptr
TAO::Objref_Traits<Thwoik::AMH_TestTypeResponseHandler>::nil ()
{
  return Thwoik::AMH_TestTypeResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Thwoik::AMH_TestTypeResponseHandler>::marshal (const Thwoik::AMH_TestTypeResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Thwoik::AMH_TestTypeResponseHandler::AMH_TestTypeResponseHandler ()
{}void
Thwoik::AMH_TestTypeResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_TestTypeResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_TestTypeResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Thwoik::AMH_TestTypeResponseHandler_ptr
Thwoik::AMH_TestTypeResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_TestTypeResponseHandler::_duplicate (
      dynamic_cast<AMH_TestTypeResponseHandler_ptr> (_tao_objref));
}

Thwoik::AMH_TestTypeResponseHandler_ptr
Thwoik::AMH_TestTypeResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_TestTypeResponseHandler::_duplicate (
      dynamic_cast<AMH_TestTypeResponseHandler_ptr> (_tao_objref));
}

Thwoik::AMH_TestTypeResponseHandler_ptr
Thwoik::AMH_TestTypeResponseHandler::_nil ()
{
  return nullptr;
}

Thwoik::AMH_TestTypeResponseHandler_ptr
Thwoik::AMH_TestTypeResponseHandler::_duplicate (AMH_TestTypeResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Thwoik::AMH_TestTypeResponseHandler::_tao_release (AMH_TestTypeResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Thwoik::AMH_TestTypeResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:Thwoik/AMH_TestTypeResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* Thwoik::AMH_TestTypeResponseHandler::_interface_repository_id () const
{
  return "IDL:Thwoik/AMH_TestTypeResponseHandler:1.0";
}

const char* Thwoik::AMH_TestTypeResponseHandler::_desc_repository_id ()
{
  return "IDL:Thwoik/AMH_TestTypeResponseHandler:1.0";
}

const char* Thwoik::AMH_TestTypeResponseHandler::_desc_interface_name ()
{
  return "AMH_TestTypeResponseHandler";
}

::CORBA::Boolean
Thwoik::AMH_TestTypeResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Thwoik_AMH_TestTypeResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:Thwoik/AMH_TestTypeResponseHandler:1.0",
    "AMH_TestTypeResponseHandler");
  

namespace Thwoik
{
  ::CORBA::TypeCode_ptr const _tc_AMH_TestTypeResponseHandler =
    &_tao_tc_Thwoik_AMH_TestTypeResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for Thwoik::AMI_TestTypeHandler.

Thwoik::AMI_TestTypeHandler_ptr
TAO::Objref_Traits<Thwoik::AMI_TestTypeHandler>::duplicate (Thwoik::AMI_TestTypeHandler_ptr p)
{
  return Thwoik::AMI_TestTypeHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Thwoik::AMI_TestTypeHandler>::release (Thwoik::AMI_TestTypeHandler_ptr p)
{
  ::CORBA::release (p);
}

Thwoik::AMI_TestTypeHandler_ptr
TAO::Objref_Traits<Thwoik::AMI_TestTypeHandler>::nil ()
{
  return Thwoik::AMI_TestTypeHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Thwoik::AMI_TestTypeHandler>::marshal (const Thwoik::AMI_TestTypeHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



Thwoik::AMI_TestTypeHandler::AMI_TestTypeHandler ()
{
}
void
Thwoik::AMI_TestTypeHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_TestTypeHandler *_tao_tmp_pointer =
    static_cast<AMI_TestTypeHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Thwoik::AMI_TestTypeHandler_ptr
Thwoik::AMI_TestTypeHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_TestTypeHandler>::narrow (_tao_objref, "IDL:Thwoik/AMI_TestTypeHandler:1.0");
}

Thwoik::AMI_TestTypeHandler_ptr
Thwoik::AMI_TestTypeHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_TestTypeHandler>::unchecked_narrow (_tao_objref);
}

Thwoik::AMI_TestTypeHandler_ptr
Thwoik::AMI_TestTypeHandler::_nil ()
{
  return nullptr;
}

Thwoik::AMI_TestTypeHandler_ptr
Thwoik::AMI_TestTypeHandler::_duplicate (AMI_TestTypeHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Thwoik::AMI_TestTypeHandler::_tao_release (AMI_TestTypeHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Thwoik::AMI_TestTypeHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:Thwoik/AMI_TestTypeHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Thwoik::AMI_TestTypeHandler::_interface_repository_id () const
{
  return "IDL:Thwoik/AMI_TestTypeHandler:1.0";
}

const char* Thwoik::AMI_TestTypeHandler::_desc_repository_id ()
{
  return "IDL:Thwoik/AMI_TestTypeHandler:1.0";
}

const char* Thwoik::AMI_TestTypeHandler::_desc_interface_name ()
{
  return "AMI_TestTypeHandler";
}

::CORBA::Boolean
Thwoik::AMI_TestTypeHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Thwoik_AMI_TestTypeHandler (
    ::CORBA::tk_objref,
    "IDL:Thwoik/AMI_TestTypeHandler:1.0",
    "AMI_TestTypeHandler");
  

namespace Thwoik
{
  ::CORBA::TypeCode_ptr const _tc_AMI_TestTypeHandler =
    &_tao_tc_Thwoik_AMI_TestTypeHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for A_mod::Foo.

A_mod::Foo_ptr
TAO::Objref_Traits<A_mod::Foo>::duplicate (A_mod::Foo_ptr p)
{
  return A_mod::Foo::_duplicate (p);
}

void
TAO::Objref_Traits<A_mod::Foo>::release (A_mod::Foo_ptr p)
{
  ::CORBA::release (p);
}

A_mod::Foo_ptr
TAO::Objref_Traits<A_mod::Foo>::nil ()
{
  return A_mod::Foo::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<A_mod::Foo>::marshal (const A_mod::Foo_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



A_mod::Foo::Foo ()
{
}
void
A_mod::Foo::_tao_any_destructor (void *_tao_void_pointer)
{
  Foo *_tao_tmp_pointer =
    static_cast<Foo *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

A_mod::Foo_ptr
A_mod::Foo::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Foo>::narrow (_tao_objref, "IDL:A_mod/Foo:1.0");
}

A_mod::Foo_ptr
A_mod::Foo::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Foo>::unchecked_narrow (_tao_objref);
}

A_mod::Foo_ptr
A_mod::Foo::_nil ()
{
  return nullptr;
}

A_mod::Foo_ptr
A_mod::Foo::_duplicate (Foo_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
A_mod::Foo::_tao_release (Foo_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
A_mod::Foo::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:A_mod/Foo:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* A_mod::Foo::_interface_repository_id () const
{
  return "IDL:A_mod/Foo:1.0";
}

const char* A_mod::Foo::_desc_repository_id ()
{
  return "IDL:A_mod/Foo:1.0";
}

const char* A_mod::Foo::_desc_interface_name ()
{
  return "Foo";
}

::CORBA::Boolean
A_mod::Foo::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_A_mod_Foo (
    ::CORBA::tk_objref,
    "IDL:A_mod/Foo:1.0",
    "Foo");
  

namespace A_mod
{
  ::CORBA::TypeCode_ptr const _tc_Foo =
    &_tao_tc_A_mod_Foo;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_A_mod_AMH_FooExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_A_mod_AMH_FooExceptionHolder (
    ::CORBA::tk_value,
    "IDL:A_mod/AMH_FooExceptionHolder:1.0",
    "AMH_FooExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_A_mod_AMH_FooExceptionHolder,
    0);
  

namespace A_mod
{
  ::CORBA::TypeCode_ptr const _tc_AMH_FooExceptionHolder =
    &_tao_tc_A_mod_AMH_FooExceptionHolder;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<A_mod::AMH_FooExceptionHolder>::add_ref (A_mod::AMH_FooExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<A_mod::AMH_FooExceptionHolder>::remove_ref (A_mod::AMH_FooExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<A_mod::AMH_FooExceptionHolder>::release (A_mod::AMH_FooExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



A_mod::AMH_FooExceptionHolder *
A_mod::AMH_FooExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::A_mod::AMH_FooExceptionHolder *> (v);
}

const char *
A_mod::AMH_FooExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
A_mod::AMH_FooExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
A_mod::AMH_FooExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_FooExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_FooExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr A_mod::AMH_FooExceptionHolder::_tao_type () const
{
  return ::A_mod::_tc_AMH_FooExceptionHolder;
}

A_mod::AMH_FooExceptionHolder::~AMH_FooExceptionHolder ()
{}

::CORBA::ValueBase *
A_mod::AMH_FooExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_FooExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
A_mod::AMH_FooExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
A_mod::AMH_FooExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
A_mod::AMH_FooExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
A_mod::AMH_FooExceptionHolder::_tao_marshal__A_mod_AMH_FooExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
A_mod::AMH_FooExceptionHolder::_tao_unmarshal__A_mod_AMH_FooExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
A_mod::AMH_FooExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_FooExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_FooExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_FooExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



A_mod::AMH_FooExceptionHolder_init::AMH_FooExceptionHolder_init ()
{
}

A_mod::AMH_FooExceptionHolder_init::~AMH_FooExceptionHolder_init ()
{
}

A_mod::AMH_FooExceptionHolder_init *
A_mod::AMH_FooExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::A_mod::AMH_FooExceptionHolder_init *> (v);
}

const char*
A_mod::AMH_FooExceptionHolder_init::tao_repository_id ()
{
  return ::A_mod::AMH_FooExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
A_mod::AMH_FooExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_A_mod::AMH_FooExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for A_mod::AMH_FooResponseHandler.

A_mod::AMH_FooResponseHandler_ptr
TAO::Objref_Traits<A_mod::AMH_FooResponseHandler>::duplicate (A_mod::AMH_FooResponseHandler_ptr p)
{
  return A_mod::AMH_FooResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<A_mod::AMH_FooResponseHandler>::release (A_mod::AMH_FooResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

A_mod::AMH_FooResponseHandler_ptr
TAO::Objref_Traits<A_mod::AMH_FooResponseHandler>::nil ()
{
  return A_mod::AMH_FooResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<A_mod::AMH_FooResponseHandler>::marshal (const A_mod::AMH_FooResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



A_mod::AMH_FooResponseHandler::AMH_FooResponseHandler ()
{}void
A_mod::AMH_FooResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_FooResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_FooResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

A_mod::AMH_FooResponseHandler_ptr
A_mod::AMH_FooResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_FooResponseHandler::_duplicate (
      dynamic_cast<AMH_FooResponseHandler_ptr> (_tao_objref));
}

A_mod::AMH_FooResponseHandler_ptr
A_mod::AMH_FooResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_FooResponseHandler::_duplicate (
      dynamic_cast<AMH_FooResponseHandler_ptr> (_tao_objref));
}

A_mod::AMH_FooResponseHandler_ptr
A_mod::AMH_FooResponseHandler::_nil ()
{
  return nullptr;
}

A_mod::AMH_FooResponseHandler_ptr
A_mod::AMH_FooResponseHandler::_duplicate (AMH_FooResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
A_mod::AMH_FooResponseHandler::_tao_release (AMH_FooResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
A_mod::AMH_FooResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:A_mod/AMH_FooResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* A_mod::AMH_FooResponseHandler::_interface_repository_id () const
{
  return "IDL:A_mod/AMH_FooResponseHandler:1.0";
}

const char* A_mod::AMH_FooResponseHandler::_desc_repository_id ()
{
  return "IDL:A_mod/AMH_FooResponseHandler:1.0";
}

const char* A_mod::AMH_FooResponseHandler::_desc_interface_name ()
{
  return "AMH_FooResponseHandler";
}

::CORBA::Boolean
A_mod::AMH_FooResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_A_mod_AMH_FooResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:A_mod/AMH_FooResponseHandler:1.0",
    "AMH_FooResponseHandler");
  

namespace A_mod
{
  ::CORBA::TypeCode_ptr const _tc_AMH_FooResponseHandler =
    &_tao_tc_A_mod_AMH_FooResponseHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for A_mod::AMI_FooHandler.

A_mod::AMI_FooHandler_ptr
TAO::Objref_Traits<A_mod::AMI_FooHandler>::duplicate (A_mod::AMI_FooHandler_ptr p)
{
  return A_mod::AMI_FooHandler::_duplicate (p);
}

void
TAO::Objref_Traits<A_mod::AMI_FooHandler>::release (A_mod::AMI_FooHandler_ptr p)
{
  ::CORBA::release (p);
}

A_mod::AMI_FooHandler_ptr
TAO::Objref_Traits<A_mod::AMI_FooHandler>::nil ()
{
  return A_mod::AMI_FooHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<A_mod::AMI_FooHandler>::marshal (const A_mod::AMI_FooHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



A_mod::AMI_FooHandler::AMI_FooHandler ()
{
}
void
A_mod::AMI_FooHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_FooHandler *_tao_tmp_pointer =
    static_cast<AMI_FooHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

A_mod::AMI_FooHandler_ptr
A_mod::AMI_FooHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_FooHandler>::narrow (_tao_objref, "IDL:A_mod/AMI_FooHandler:1.0");
}

A_mod::AMI_FooHandler_ptr
A_mod::AMI_FooHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_FooHandler>::unchecked_narrow (_tao_objref);
}

A_mod::AMI_FooHandler_ptr
A_mod::AMI_FooHandler::_nil ()
{
  return nullptr;
}

A_mod::AMI_FooHandler_ptr
A_mod::AMI_FooHandler::_duplicate (AMI_FooHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
A_mod::AMI_FooHandler::_tao_release (AMI_FooHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
A_mod::AMI_FooHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:A_mod/AMI_FooHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* A_mod::AMI_FooHandler::_interface_repository_id () const
{
  return "IDL:A_mod/AMI_FooHandler:1.0";
}

const char* A_mod::AMI_FooHandler::_desc_repository_id ()
{
  return "IDL:A_mod/AMI_FooHandler:1.0";
}

const char* A_mod::AMI_FooHandler::_desc_interface_name ()
{
  return "AMI_FooHandler";
}

::CORBA::Boolean
A_mod::AMI_FooHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_A_mod_AMI_FooHandler (
    ::CORBA::tk_objref,
    "IDL:A_mod/AMI_FooHandler:1.0",
    "AMI_FooHandler");
  

namespace A_mod
{
  ::CORBA::TypeCode_ptr const _tc_AMI_FooHandler =
    &_tao_tc_A_mod_AMI_FooHandler;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for A_mod::B_mod::Foo.

A_mod::B_mod::Foo_ptr
TAO::Objref_Traits<A_mod::B_mod::Foo>::duplicate (A_mod::B_mod::Foo_ptr p)
{
  return A_mod::B_mod::Foo::_duplicate (p);
}

void
TAO::Objref_Traits<A_mod::B_mod::Foo>::release (A_mod::B_mod::Foo_ptr p)
{
  ::CORBA::release (p);
}

A_mod::B_mod::Foo_ptr
TAO::Objref_Traits<A_mod::B_mod::Foo>::nil ()
{
  return A_mod::B_mod::Foo::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<A_mod::B_mod::Foo>::marshal (const A_mod::B_mod::Foo_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



A_mod::B_mod::Foo::Foo ()
{
}
void
A_mod::B_mod::Foo::_tao_any_destructor (void *_tao_void_pointer)
{
  Foo *_tao_tmp_pointer =
    static_cast<Foo *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

A_mod::B_mod::Foo_ptr
A_mod::B_mod::Foo::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Foo>::narrow (_tao_objref, "IDL:A_mod/B_mod/Foo:1.0");
}

A_mod::B_mod::Foo_ptr
A_mod::B_mod::Foo::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<Foo>::unchecked_narrow (_tao_objref);
}

A_mod::B_mod::Foo_ptr
A_mod::B_mod::Foo::_nil ()
{
  return nullptr;
}

A_mod::B_mod::Foo_ptr
A_mod::B_mod::Foo::_duplicate (Foo_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
A_mod::B_mod::Foo::_tao_release (Foo_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
A_mod::B_mod::Foo::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:A_mod/Foo:1.0") == 0 ||
      std::strcmp (value, "IDL:A_mod/B_mod/Foo:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* A_mod::B_mod::Foo::_interface_repository_id () const
{
  return "IDL:A_mod/B_mod/Foo:1.0";
}

const char* A_mod::B_mod::Foo::_desc_repository_id ()
{
  return "IDL:A_mod/B_mod/Foo:1.0";
}

const char* A_mod::B_mod::Foo::_desc_interface_name ()
{
  return "Foo";
}

::CORBA::Boolean
A_mod::B_mod::Foo::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_A_mod_B_mod_Foo (
    ::CORBA::tk_objref,
    "IDL:A_mod/B_mod/Foo:1.0",
    "Foo");
  

namespace A_mod
{
  
  namespace B_mod
  {
    ::CORBA::TypeCode_ptr const _tc_Foo =
      &_tao_tc_A_mod_B_mod_Foo;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/value_typecode.cpp:63

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_A_mod_B_mod_AMH_FooExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_A_mod_B_mod_AMH_FooExceptionHolder (
    ::CORBA::tk_value,
    "IDL:A_mod/B_mod/AMH_FooExceptionHolder:1.0",
    "AMH_FooExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_A_mod_B_mod_AMH_FooExceptionHolder,
    0);
  

namespace A_mod
{
  
  namespace B_mod
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_FooExceptionHolder =
      &_tao_tc_A_mod_B_mod_AMH_FooExceptionHolder;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_cs.cpp:52



TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void
TAO::Value_Traits<A_mod::B_mod::AMH_FooExceptionHolder>::add_ref (A_mod::B_mod::AMH_FooExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<A_mod::B_mod::AMH_FooExceptionHolder>::remove_ref (A_mod::B_mod::AMH_FooExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<A_mod::B_mod::AMH_FooExceptionHolder>::release (A_mod::B_mod::AMH_FooExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

TAO_END_VERSIONED_NAMESPACE_DECL



A_mod::B_mod::AMH_FooExceptionHolder *
A_mod::B_mod::AMH_FooExceptionHolder::_downcast (::CORBA::ValueBase *v)
{
  return dynamic_cast<::A_mod::B_mod::AMH_FooExceptionHolder *> (v);
}

const char *
A_mod::B_mod::AMH_FooExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void
A_mod::B_mod::AMH_FooExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
A_mod::B_mod::AMH_FooExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_FooExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_FooExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr A_mod::B_mod::AMH_FooExceptionHolder::_tao_type () const
{
  return ::A_mod::B_mod::_tc_AMH_FooExceptionHolder;
}

A_mod::B_mod::AMH_FooExceptionHolder::~AMH_FooExceptionHolder ()
{}

::CORBA::ValueBase *
A_mod::B_mod::AMH_FooExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_FooExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
A_mod::B_mod::AMH_FooExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
A_mod::B_mod::AMH_FooExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
A_mod::B_mod::AMH_FooExceptionHolder::_tao_match_formal_type (ptrdiff_t) const
{
  return false;
}

::CORBA::Boolean
A_mod::B_mod::AMH_FooExceptionHolder::_tao_marshal__A_mod_B_mod_AMH_FooExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
A_mod::B_mod::AMH_FooExceptionHolder::_tao_unmarshal__A_mod_B_mod_AMH_FooExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
A_mod::B_mod::AMH_FooExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_FooExceptionHolder *&new_object)
{
  ::CORBA::ValueBase *base {};
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_FooExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );
  
  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;
  
  if (is_null_object)
    return true;
  
  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;
  
  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_FooExceptionHolder::_downcast (base);
  if (nullptr == new_object)
    return false;
  
  if (is_indirected)
    new_object->_add_ref ();
  
  owner._retn ();
  return true;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_init_cs.cpp:72



A_mod::B_mod::AMH_FooExceptionHolder_init::AMH_FooExceptionHolder_init ()
{
}

A_mod::B_mod::AMH_FooExceptionHolder_init::~AMH_FooExceptionHolder_init ()
{
}

A_mod::B_mod::AMH_FooExceptionHolder_init *
A_mod::B_mod::AMH_FooExceptionHolder_init::_downcast (::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast<::A_mod::B_mod::AMH_FooExceptionHolder_init *> (v);
}

const char*
A_mod::B_mod::AMH_FooExceptionHolder_init::tao_repository_id ()
{
  return ::A_mod::B_mod::AMH_FooExceptionHolder::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
A_mod::B_mod::AMH_FooExceptionHolder_init::create_for_unmarshal ()
{
  ::CORBA::ValueBase *ret_val = nullptr;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_A_mod::B_mod::AMH_FooExceptionHolder,
      ::CORBA::NO_MEMORY ());
  return ret_val;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for A_mod::B_mod::AMH_FooResponseHandler.

A_mod::B_mod::AMH_FooResponseHandler_ptr
TAO::Objref_Traits<A_mod::B_mod::AMH_FooResponseHandler>::duplicate (A_mod::B_mod::AMH_FooResponseHandler_ptr p)
{
  return A_mod::B_mod::AMH_FooResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<A_mod::B_mod::AMH_FooResponseHandler>::release (A_mod::B_mod::AMH_FooResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

A_mod::B_mod::AMH_FooResponseHandler_ptr
TAO::Objref_Traits<A_mod::B_mod::AMH_FooResponseHandler>::nil ()
{
  return A_mod::B_mod::AMH_FooResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<A_mod::B_mod::AMH_FooResponseHandler>::marshal (const A_mod::B_mod::AMH_FooResponseHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



A_mod::B_mod::AMH_FooResponseHandler::AMH_FooResponseHandler ()
{}void
A_mod::B_mod::AMH_FooResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_FooResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_FooResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

A_mod::B_mod::AMH_FooResponseHandler_ptr
A_mod::B_mod::AMH_FooResponseHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_FooResponseHandler::_duplicate (
      dynamic_cast<AMH_FooResponseHandler_ptr> (_tao_objref));
}

A_mod::B_mod::AMH_FooResponseHandler_ptr
A_mod::B_mod::AMH_FooResponseHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return AMH_FooResponseHandler::_duplicate (
      dynamic_cast<AMH_FooResponseHandler_ptr> (_tao_objref));
}

A_mod::B_mod::AMH_FooResponseHandler_ptr
A_mod::B_mod::AMH_FooResponseHandler::_nil ()
{
  return nullptr;
}

A_mod::B_mod::AMH_FooResponseHandler_ptr
A_mod::B_mod::AMH_FooResponseHandler::_duplicate (AMH_FooResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
A_mod::B_mod::AMH_FooResponseHandler::_tao_release (AMH_FooResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
A_mod::B_mod::AMH_FooResponseHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:A_mod/B_mod/AMH_FooResponseHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/LocalObject:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* A_mod::B_mod::AMH_FooResponseHandler::_interface_repository_id () const
{
  return "IDL:A_mod/B_mod/AMH_FooResponseHandler:1.0";
}

const char* A_mod::B_mod::AMH_FooResponseHandler::_desc_repository_id ()
{
  return "IDL:A_mod/B_mod/AMH_FooResponseHandler:1.0";
}

const char* A_mod::B_mod::AMH_FooResponseHandler::_desc_interface_name ()
{
  return "AMH_FooResponseHandler";
}

::CORBA::Boolean
A_mod::B_mod::AMH_FooResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_A_mod_B_mod_AMH_FooResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:A_mod/B_mod/AMH_FooResponseHandler:1.0",
    "AMH_FooResponseHandler");
  

namespace A_mod
{
  
  namespace B_mod
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_FooResponseHandler =
      &_tao_tc_A_mod_B_mod_AMH_FooResponseHandler;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/interface_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations for A_mod::B_mod::AMI_FooHandler.

A_mod::B_mod::AMI_FooHandler_ptr
TAO::Objref_Traits<A_mod::B_mod::AMI_FooHandler>::duplicate (A_mod::B_mod::AMI_FooHandler_ptr p)
{
  return A_mod::B_mod::AMI_FooHandler::_duplicate (p);
}

void
TAO::Objref_Traits<A_mod::B_mod::AMI_FooHandler>::release (A_mod::B_mod::AMI_FooHandler_ptr p)
{
  ::CORBA::release (p);
}

A_mod::B_mod::AMI_FooHandler_ptr
TAO::Objref_Traits<A_mod::B_mod::AMI_FooHandler>::nil ()
{
  return A_mod::B_mod::AMI_FooHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<A_mod::B_mod::AMI_FooHandler>::marshal (const A_mod::B_mod::AMI_FooHandler_ptr p,TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

TAO_END_VERSIONED_NAMESPACE_DECL



A_mod::B_mod::AMI_FooHandler::AMI_FooHandler ()
{
}
void
A_mod::B_mod::AMI_FooHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMI_FooHandler *_tao_tmp_pointer =
    static_cast<AMI_FooHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

A_mod::B_mod::AMI_FooHandler_ptr
A_mod::B_mod::AMI_FooHandler::_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_FooHandler>::narrow (_tao_objref, "IDL:A_mod/B_mod/AMI_FooHandler:1.0");
}

A_mod::B_mod::AMI_FooHandler_ptr
A_mod::B_mod::AMI_FooHandler::_unchecked_narrow (::CORBA::Object_ptr _tao_objref)
{
  return TAO::Narrow_Utils<AMI_FooHandler>::unchecked_narrow (_tao_objref);
}

A_mod::B_mod::AMI_FooHandler_ptr
A_mod::B_mod::AMI_FooHandler::_nil ()
{
  return nullptr;
}

A_mod::B_mod::AMI_FooHandler_ptr
A_mod::B_mod::AMI_FooHandler::_duplicate (AMI_FooHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
A_mod::B_mod::AMI_FooHandler::_tao_release (AMI_FooHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
A_mod::B_mod::AMI_FooHandler::_is_a (const char *value)
{
  if (
      std::strcmp (value, "IDL:omg.org/Messaging/ReplyHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:A_mod/AMI_FooHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:A_mod/B_mod/AMI_FooHandler:1.0") == 0 ||
      std::strcmp (value, "IDL:omg.org/CORBA/Object:1.0") == 0
      )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* A_mod::B_mod::AMI_FooHandler::_interface_repository_id () const
{
  return "IDL:A_mod/B_mod/AMI_FooHandler:1.0";
}

const char* A_mod::B_mod::AMI_FooHandler::_desc_repository_id ()
{
  return "IDL:A_mod/B_mod/AMI_FooHandler:1.0";
}

const char* A_mod::B_mod::AMI_FooHandler::_desc_interface_name ()
{
  return "AMI_FooHandler";
}

::CORBA::Boolean
A_mod::B_mod::AMI_FooHandler::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/objref_typecode.cpp:68

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_A_mod_B_mod_AMI_FooHandler (
    ::CORBA::tk_objref,
    "IDL:A_mod/B_mod/AMI_FooHandler:1.0",
    "AMI_FooHandler");
  

namespace A_mod
{
  
  namespace B_mod
  {
    ::CORBA::TypeCode_ptr const _tc_AMI_FooHandler =
      &_tao_tc_A_mod_B_mod_AMI_FooHandler;
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:550


#ifndef _TAO_TYPECODE_CORBA_STRING_240_GUARD
#define _TAO_TYPECODE_CORBA_STRING_240_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::String<TAO::Null_RefCount_Policy>
        CORBA_STRING_240 (
          ::CORBA::tk_string,
          240U);
        
      ::CORBA::TypeCode_ptr const tc_CORBA_STRING_240 =
        &CORBA_STRING_240;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CORBA_STRING_240_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_m1_m2_m3b_StringJIM (
    ::CORBA::tk_alias,
    "IDL:m1/m2/m3b/StringJIM:1.0",
    "StringJIM",
    &TAO::TypeCode::tc_CORBA_STRING_240);
  

namespace m1
{
  
  namespace m2
  {
    
    namespace m3b
    {
      ::CORBA::TypeCode_ptr const _tc_StringJIM =
        &_tao_tc_m1_m2_m3b_StringJIM;
    }
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:550


#ifndef _TAO_TYPECODE_CORBA_STRING_240_GUARD
#define _TAO_TYPECODE_CORBA_STRING_240_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::String<TAO::Null_RefCount_Policy>
        CORBA_STRING_240 (
          ::CORBA::tk_string,
          240U);
        
      ::CORBA::TypeCode_ptr const tc_CORBA_STRING_240 =
        &CORBA_STRING_240;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CORBA_STRING_240_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_m1_m2_m3b_StringJIM_0 (
    ::CORBA::tk_alias,
    "IDL:m1/m2/m3b/StringJIM_0:1.0",
    "StringJIM_0",
    &TAO::TypeCode::tc_CORBA_STRING_240);
  

namespace m1
{
  
  namespace m2
  {
    
    namespace m3b
    {
      ::CORBA::TypeCode_ptr const _tc_StringJIM_0 =
        &_tao_tc_m1_m2_m3b_StringJIM_0;
    }
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:550


#ifndef _TAO_TYPECODE_CORBA_STRING_240_GUARD
#define _TAO_TYPECODE_CORBA_STRING_240_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::String<TAO::Null_RefCount_Policy>
        CORBA_STRING_240 (
          ::CORBA::tk_string,
          240U);
        
      ::CORBA::TypeCode_ptr const tc_CORBA_STRING_240 =
        &CORBA_STRING_240;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CORBA_STRING_240_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_m1_m2_m3b_StringJIM_1 (
    ::CORBA::tk_alias,
    "IDL:m1/m2/m3b/StringJIM_1:1.0",
    "StringJIM_1",
    &TAO::TypeCode::tc_CORBA_STRING_240);
  

namespace m1
{
  
  namespace m2
  {
    
    namespace m3b
    {
      ::CORBA::TypeCode_ptr const _tc_StringJIM_1 =
        &_tao_tc_m1_m2_m3b_StringJIM_1;
    }
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/alias_typecode.cpp:46


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_typecode/typecode_defn.cpp:550


#ifndef _TAO_TYPECODE_CORBA_STRING_240_GUARD
#define _TAO_TYPECODE_CORBA_STRING_240_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::String<TAO::Null_RefCount_Policy>
        CORBA_STRING_240 (
          ::CORBA::tk_string,
          240U);
        
      ::CORBA::TypeCode_ptr const tc_CORBA_STRING_240 =
        &CORBA_STRING_240;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CORBA_STRING_240_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_m1_m2_m3b_StringJIM_2 (
    ::CORBA::tk_alias,
    "IDL:m1/m2/m3b/StringJIM_2:1.0",
    "StringJIM_2",
    &TAO::TypeCode::tc_CORBA_STRING_240);
  

namespace m1
{
  
  namespace m2
  {
    
    namespace m3b
    {
      ::CORBA::TypeCode_ptr const _tc_StringJIM_2 =
        &_tao_tc_m1_m2_m3b_StringJIM_2;
    }
  }
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AA::BB::AMH_x1ExceptionHolder::~AMH_x1ExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_AA::BB::AMH_x1ExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_x1ExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_AA::BB::AMH_x1ExceptionHolder::_tao_marshal__AA_BB_AMH_x1ExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AA::BB::AMH_x1ExceptionHolder::_tao_unmarshal__AA_BB_AMH_x1ExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AA::BB::CC::AMH_x2ExceptionHolder::~AMH_x2ExceptionHolder ()
{}

::CORBA::Boolean
OBV_AA::BB::CC::AMH_x2ExceptionHolder::_tao_marshal__AA_BB_CC_AMH_x2ExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AA::BB::CC::AMH_x2ExceptionHolder::_tao_unmarshal__AA_BB_CC_AMH_x2ExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_dot::AMH_PersonExceptionHolder::~AMH_PersonExceptionHolder ()
{}

::CORBA::Boolean
OBV_dot::AMH_PersonExceptionHolder::_tao_marshal__dot_AMH_PersonExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_dot::AMH_PersonExceptionHolder::_tao_unmarshal__dot_AMH_PersonExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_dot::AMH_PartyExceptionHolder::~AMH_PartyExceptionHolder ()
{}

::CORBA::Boolean
OBV_dot::AMH_PartyExceptionHolder::_tao_marshal__dot_AMH_PartyExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_dot::AMH_PartyExceptionHolder::_tao_unmarshal__dot_AMH_PartyExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_OpHolderExceptionHolder::~OBV_AMH_OpHolderExceptionHolder ()
{}

::CORBA::Boolean
OBV_AMH_OpHolderExceptionHolder::_tao_marshal__AMH_OpHolderExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_OpHolderExceptionHolder::_tao_unmarshal__AMH_OpHolderExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_com::AMH_IFaceExceptionHolder::~AMH_IFaceExceptionHolder ()
{}

::CORBA::Boolean
OBV_com::AMH_IFaceExceptionHolder::_tao_marshal__com_AMH_IFaceExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_com::AMH_IFaceExceptionHolder::_tao_unmarshal__com_AMH_IFaceExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_Y::AMH_ZExceptionHolder::~AMH_ZExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_Y::AMH_ZExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_ZExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_Y::AMH_ZExceptionHolder::_tao_marshal__Y_AMH_ZExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Y::AMH_ZExceptionHolder::_tao_unmarshal__Y_AMH_ZExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_X::AMH_BIExceptionHolder::~AMH_BIExceptionHolder ()
{}

::CORBA::Boolean
OBV_X::AMH_BIExceptionHolder::_tao_marshal__X_AMH_BIExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_X::AMH_BIExceptionHolder::_tao_unmarshal__X_AMH_BIExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_XX::AMH_blah_intfcExceptionHolder::~AMH_blah_intfcExceptionHolder ()
{}

::CORBA::Boolean
OBV_XX::AMH_blah_intfcExceptionHolder::_tao_marshal__XX_AMH_blah_intfcExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_XX::AMH_blah_intfcExceptionHolder::_tao_unmarshal__XX_AMH_blah_intfcExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_XX::AMH_blah0ExceptionHolder::~AMH_blah0ExceptionHolder ()
{}

::CORBA::Boolean
OBV_XX::AMH_blah0ExceptionHolder::_tao_marshal__XX_AMH_blah0ExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_XX::AMH_blah0ExceptionHolder::_tao_unmarshal__XX_AMH_blah0ExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_frag::AMH_frag_ifaceExceptionHolder::~AMH_frag_ifaceExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_frag::AMH_frag_ifaceExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_frag_ifaceExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_frag::AMH_frag_ifaceExceptionHolder::_tao_marshal__frag_AMH_frag_ifaceExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_frag::AMH_frag_ifaceExceptionHolder::_tao_unmarshal__frag_AMH_frag_ifaceExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_AMH_gatherExceptionHolder::~OBV_AMH_gatherExceptionHolder ()
{}

::CORBA::Boolean
OBV_AMH_gatherExceptionHolder::_tao_marshal__AMH_gatherExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_AMH_gatherExceptionHolder::_tao_unmarshal__AMH_gatherExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_foo::AMH_objExceptionHolder::~AMH_objExceptionHolder ()
{}

::CORBA::Boolean
OBV_foo::AMH_objExceptionHolder::_tao_marshal__foo_AMH_objExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_foo::AMH_objExceptionHolder::_tao_unmarshal__foo_AMH_objExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_A::B::AMH_X3ExceptionHolder::~AMH_X3ExceptionHolder ()
{}

::CORBA::Boolean
OBV_A::B::AMH_X3ExceptionHolder::_tao_marshal__A_B_AMH_X3ExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_A::B::AMH_X3ExceptionHolder::_tao_unmarshal__A_B_AMH_X3ExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_mA::AMH_AExceptionHolder::~AMH_AExceptionHolder ()
{}

::CORBA::Boolean
OBV_mA::AMH_AExceptionHolder::_tao_marshal__mA_AMH_AExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_mA::AMH_AExceptionHolder::_tao_unmarshal__mA_AMH_AExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_mB::AMH_BExceptionHolder::~AMH_BExceptionHolder ()
{}

::CORBA::Boolean
OBV_mB::AMH_BExceptionHolder::_tao_marshal__mB_AMH_BExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_mB::AMH_BExceptionHolder::_tao_unmarshal__mB_AMH_BExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_mC::AMH_CExceptionHolder::~AMH_CExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_mC::AMH_CExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_CExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_mC::AMH_CExceptionHolder::_tao_marshal__mC_AMH_CExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_mC::AMH_CExceptionHolder::_tao_unmarshal__mC_AMH_CExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_Schmoik::AMH_fooExceptionHolder::~AMH_fooExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_Schmoik::AMH_fooExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_fooExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_Schmoik::AMH_fooExceptionHolder::_tao_marshal__Schmoik_AMH_fooExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Schmoik::AMH_fooExceptionHolder::_tao_unmarshal__Schmoik_AMH_fooExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_Thwoik::AMH_TestTypeExceptionHolder::~AMH_TestTypeExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_Thwoik::AMH_TestTypeExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_TestTypeExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_Thwoik::AMH_TestTypeExceptionHolder::_tao_marshal__Thwoik_AMH_TestTypeExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Thwoik::AMH_TestTypeExceptionHolder::_tao_unmarshal__Thwoik_AMH_TestTypeExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_A_mod::AMH_FooExceptionHolder::~AMH_FooExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_A_mod::AMH_FooExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_FooExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_A_mod::AMH_FooExceptionHolder::_tao_marshal__A_mod_AMH_FooExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_A_mod::AMH_FooExceptionHolder::_tao_unmarshal__A_mod_AMH_FooExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/valuetype_obv_cs.cpp:43

OBV_A_mod::B_mod::AMH_FooExceptionHolder::~AMH_FooExceptionHolder ()
{}

::CORBA::ValueBase *
OBV_A_mod::B_mod::AMH_FooExceptionHolder::_copy_value ()
{
  ::CORBA::ValueBase *ret_val {};
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_FooExceptionHolder (),
    ::CORBA::NO_MEMORY ());
  return ret_val;
}

::CORBA::Boolean
OBV_A_mod::B_mod::AMH_FooExceptionHolder::_tao_marshal__A_mod_B_mod_AMH_FooExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_A_mod::B_mod::AMH_FooExceptionHolder::_tao_unmarshal__A_mod_B_mod_AMH_FooExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::x1>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::x1_ptr _tao_elem)
{
  AA::BB::x1_ptr _tao_objptr =
    AA::BB::x1::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::x1_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AA::BB::x1>::insert (
    _tao_any,
    AA::BB::x1::_tao_any_destructor,
    AA::BB::_tc_x1,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AA::BB::x1_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AA::BB::x1>::extract (
        _tao_any,
        AA::BB::x1::_tao_any_destructor,
        AA::BB::_tc_x1,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::AMH_x1ExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::AMH_x1ExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AA::BB::AMH_x1ExceptionHolder *_tao_copy =
      _tao_elem ?
        AA::BB::AMH_x1ExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::AMH_x1ExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AA::BB::AMH_x1ExceptionHolder>::insert (
    _tao_any,
    AA::BB::AMH_x1ExceptionHolder::_tao_any_destructor,
    AA::BB::_tc_AMH_x1ExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AA::BB::AMH_x1ExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AA::BB::AMH_x1ExceptionHolder>::extract (
        _tao_any,
        AA::BB::AMH_x1ExceptionHolder::_tao_any_destructor,
        AA::BB::_tc_AMH_x1ExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::AMH_x1ResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::AMH_x1ResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::AMH_x1ResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::AMH_x1ResponseHandler_ptr _tao_elem)
{
  AA::BB::AMH_x1ResponseHandler_ptr _tao_objptr =
    AA::BB::AMH_x1ResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::AMH_x1ResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AA::BB::AMH_x1ResponseHandler>::insert (
    _tao_any,
    AA::BB::AMH_x1ResponseHandler::_tao_any_destructor,
    AA::BB::_tc_AMH_x1ResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AA::BB::AMH_x1ResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AA::BB::AMH_x1ResponseHandler>::extract (
        _tao_any,
        AA::BB::AMH_x1ResponseHandler::_tao_any_destructor,
        AA::BB::_tc_AMH_x1ResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::AMI_x1Handler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::AMI_x1Handler_ptr _tao_elem)
{
  AA::BB::AMI_x1Handler_ptr _tao_objptr =
    AA::BB::AMI_x1Handler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::AMI_x1Handler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AA::BB::AMI_x1Handler>::insert (
    _tao_any,
    AA::BB::AMI_x1Handler::_tao_any_destructor,
    AA::BB::_tc_AMI_x1Handler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AA::BB::AMI_x1Handler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AA::BB::AMI_x1Handler>::extract (
        _tao_any,
        AA::BB::AMI_x1Handler::_tao_any_destructor,
        AA::BB::_tc_AMI_x1Handler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::CC::x2>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::CC::x2_ptr _tao_elem)
{
  AA::BB::CC::x2_ptr _tao_objptr =
    AA::BB::CC::x2::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::CC::x2_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AA::BB::CC::x2>::insert (
    _tao_any,
    AA::BB::CC::x2::_tao_any_destructor,
    AA::BB::CC::_tc_x2,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AA::BB::CC::x2_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AA::BB::CC::x2>::extract (
        _tao_any,
        AA::BB::CC::x2::_tao_any_destructor,
        AA::BB::CC::_tc_x2,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::CC::AMH_x2ExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::CC::AMH_x2ExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AA::BB::CC::AMH_x2ExceptionHolder *_tao_copy =
      _tao_elem ?
        AA::BB::CC::AMH_x2ExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::CC::AMH_x2ExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AA::BB::CC::AMH_x2ExceptionHolder>::insert (
    _tao_any,
    AA::BB::CC::AMH_x2ExceptionHolder::_tao_any_destructor,
    AA::BB::CC::_tc_AMH_x2ExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AA::BB::CC::AMH_x2ExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AA::BB::CC::AMH_x2ExceptionHolder>::extract (
        _tao_any,
        AA::BB::CC::AMH_x2ExceptionHolder::_tao_any_destructor,
        AA::BB::CC::_tc_AMH_x2ExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::CC::AMH_x2ResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::CC::AMH_x2ResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::CC::AMH_x2ResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::CC::AMH_x2ResponseHandler_ptr _tao_elem)
{
  AA::BB::CC::AMH_x2ResponseHandler_ptr _tao_objptr =
    AA::BB::CC::AMH_x2ResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::CC::AMH_x2ResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AA::BB::CC::AMH_x2ResponseHandler>::insert (
    _tao_any,
    AA::BB::CC::AMH_x2ResponseHandler::_tao_any_destructor,
    AA::BB::CC::_tc_AMH_x2ResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AA::BB::CC::AMH_x2ResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AA::BB::CC::AMH_x2ResponseHandler>::extract (
        _tao_any,
        AA::BB::CC::AMH_x2ResponseHandler::_tao_any_destructor,
        AA::BB::CC::_tc_AMH_x2ResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AA::BB::CC::AMI_x2Handler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::CC::AMI_x2Handler_ptr _tao_elem)
{
  AA::BB::CC::AMI_x2Handler_ptr _tao_objptr =
    AA::BB::CC::AMI_x2Handler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AA::BB::CC::AMI_x2Handler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AA::BB::CC::AMI_x2Handler>::insert (
    _tao_any,
    AA::BB::CC::AMI_x2Handler::_tao_any_destructor,
    AA::BB::CC::_tc_AMI_x2Handler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AA::BB::CC::AMI_x2Handler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AA::BB::CC::AMI_x2Handler>::extract (
        _tao_any,
        AA::BB::CC::AMI_x2Handler::_tao_any_destructor,
        AA::BB::CC::_tc_AMI_x2Handler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::Person>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::Person_ptr _tao_elem)
{
  dot::Person_ptr _tao_objptr =
    dot::Person::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::Person_ptr *_tao_elem)
{
  TAO::Any_Impl_T<dot::Person>::insert (
    _tao_any,
    dot::Person::_tao_any_destructor,
    dot::_tc_Person,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    dot::Person_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<dot::Person>::extract (
        _tao_any,
        dot::Person::_tao_any_destructor,
        dot::_tc_Person,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::AMH_PersonExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMH_PersonExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    dot::AMH_PersonExceptionHolder *_tao_copy =
      _tao_elem ?
        dot::AMH_PersonExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMH_PersonExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<dot::AMH_PersonExceptionHolder>::insert (
    _tao_any,
    dot::AMH_PersonExceptionHolder::_tao_any_destructor,
    dot::_tc_AMH_PersonExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    dot::AMH_PersonExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<dot::AMH_PersonExceptionHolder>::extract (
        _tao_any,
        dot::AMH_PersonExceptionHolder::_tao_any_destructor,
        dot::_tc_AMH_PersonExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::AMH_PersonResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::AMH_PersonResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::AMH_PersonResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMH_PersonResponseHandler_ptr _tao_elem)
{
  dot::AMH_PersonResponseHandler_ptr _tao_objptr =
    dot::AMH_PersonResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMH_PersonResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<dot::AMH_PersonResponseHandler>::insert (
    _tao_any,
    dot::AMH_PersonResponseHandler::_tao_any_destructor,
    dot::_tc_AMH_PersonResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    dot::AMH_PersonResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<dot::AMH_PersonResponseHandler>::extract (
        _tao_any,
        dot::AMH_PersonResponseHandler::_tao_any_destructor,
        dot::_tc_AMH_PersonResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::AMI_PersonHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMI_PersonHandler_ptr _tao_elem)
{
  dot::AMI_PersonHandler_ptr _tao_objptr =
    dot::AMI_PersonHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMI_PersonHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<dot::AMI_PersonHandler>::insert (
    _tao_any,
    dot::AMI_PersonHandler::_tao_any_destructor,
    dot::_tc_AMI_PersonHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    dot::AMI_PersonHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<dot::AMI_PersonHandler>::extract (
        _tao_any,
        dot::AMI_PersonHandler::_tao_any_destructor,
        dot::_tc_AMI_PersonHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::Party>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::Party_ptr _tao_elem)
{
  dot::Party_ptr _tao_objptr =
    dot::Party::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::Party_ptr *_tao_elem)
{
  TAO::Any_Impl_T<dot::Party>::insert (
    _tao_any,
    dot::Party::_tao_any_destructor,
    dot::_tc_Party,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    dot::Party_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<dot::Party>::extract (
        _tao_any,
        dot::Party::_tao_any_destructor,
        dot::_tc_Party,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::AMH_PartyExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMH_PartyExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    dot::AMH_PartyExceptionHolder *_tao_copy =
      _tao_elem ?
        dot::AMH_PartyExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMH_PartyExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<dot::AMH_PartyExceptionHolder>::insert (
    _tao_any,
    dot::AMH_PartyExceptionHolder::_tao_any_destructor,
    dot::_tc_AMH_PartyExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    dot::AMH_PartyExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<dot::AMH_PartyExceptionHolder>::extract (
        _tao_any,
        dot::AMH_PartyExceptionHolder::_tao_any_destructor,
        dot::_tc_AMH_PartyExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::AMH_PartyResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::AMH_PartyResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::AMH_PartyResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMH_PartyResponseHandler_ptr _tao_elem)
{
  dot::AMH_PartyResponseHandler_ptr _tao_objptr =
    dot::AMH_PartyResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMH_PartyResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<dot::AMH_PartyResponseHandler>::insert (
    _tao_any,
    dot::AMH_PartyResponseHandler::_tao_any_destructor,
    dot::_tc_AMH_PartyResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    dot::AMH_PartyResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<dot::AMH_PartyResponseHandler>::extract (
        _tao_any,
        dot::AMH_PartyResponseHandler::_tao_any_destructor,
        dot::_tc_AMH_PartyResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<dot::AMI_PartyHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMI_PartyHandler_ptr _tao_elem)
{
  dot::AMI_PartyHandler_ptr _tao_objptr =
    dot::AMI_PartyHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  dot::AMI_PartyHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<dot::AMI_PartyHandler>::insert (
    _tao_any,
    dot::AMI_PartyHandler::_tao_any_destructor,
    dot::_tc_AMI_PartyHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    dot::AMI_PartyHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<dot::AMI_PartyHandler>::extract (
        _tao_any,
        dot::AMI_PartyHandler::_tao_any_destructor,
        dot::_tc_AMI_PartyHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<OpHolder>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  OpHolder_ptr _tao_elem)
{
  OpHolder_ptr _tao_objptr =
    OpHolder::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  OpHolder_ptr *_tao_elem)
{
  TAO::Any_Impl_T<OpHolder>::insert (
    _tao_any,
    OpHolder::_tao_any_destructor,
    _tc_OpHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    OpHolder_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<OpHolder>::extract (
        _tao_any,
        OpHolder::_tao_any_destructor,
        _tc_OpHolder,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_OpHolderExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_OpHolderExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_OpHolderExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_OpHolderExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_OpHolderExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_OpHolderExceptionHolder>::insert (
    _tao_any,
    AMH_OpHolderExceptionHolder::_tao_any_destructor,
    _tc_AMH_OpHolderExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_OpHolderExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_OpHolderExceptionHolder>::extract (
        _tao_any,
        AMH_OpHolderExceptionHolder::_tao_any_destructor,
        _tc_AMH_OpHolderExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_OpHolderResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_OpHolderResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_OpHolderResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_OpHolderResponseHandler_ptr _tao_elem)
{
  AMH_OpHolderResponseHandler_ptr _tao_objptr =
    AMH_OpHolderResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_OpHolderResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_OpHolderResponseHandler>::insert (
    _tao_any,
    AMH_OpHolderResponseHandler::_tao_any_destructor,
    _tc_AMH_OpHolderResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_OpHolderResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_OpHolderResponseHandler>::extract (
        _tao_any,
        AMH_OpHolderResponseHandler::_tao_any_destructor,
        _tc_AMH_OpHolderResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_OpHolderHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_OpHolderHandler_ptr _tao_elem)
{
  AMI_OpHolderHandler_ptr _tao_objptr =
    AMI_OpHolderHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_OpHolderHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_OpHolderHandler>::insert (
    _tao_any,
    AMI_OpHolderHandler::_tao_any_destructor,
    _tc_AMI_OpHolderHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_OpHolderHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_OpHolderHandler>::extract (
        _tao_any,
        AMI_OpHolderHandler::_tao_any_destructor,
        _tc_AMI_OpHolderHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<com::IFace>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  com::IFace_ptr _tao_elem)
{
  com::IFace_ptr _tao_objptr =
    com::IFace::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  com::IFace_ptr *_tao_elem)
{
  TAO::Any_Impl_T<com::IFace>::insert (
    _tao_any,
    com::IFace::_tao_any_destructor,
    com::_tc_IFace,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    com::IFace_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<com::IFace>::extract (
        _tao_any,
        com::IFace::_tao_any_destructor,
        com::_tc_IFace,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<com::AMH_IFaceExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  com::AMH_IFaceExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    com::AMH_IFaceExceptionHolder *_tao_copy =
      _tao_elem ?
        com::AMH_IFaceExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  com::AMH_IFaceExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<com::AMH_IFaceExceptionHolder>::insert (
    _tao_any,
    com::AMH_IFaceExceptionHolder::_tao_any_destructor,
    com::_tc_AMH_IFaceExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    com::AMH_IFaceExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<com::AMH_IFaceExceptionHolder>::extract (
        _tao_any,
        com::AMH_IFaceExceptionHolder::_tao_any_destructor,
        com::_tc_AMH_IFaceExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<com::AMH_IFaceResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<com::AMH_IFaceResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<com::AMH_IFaceResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  com::AMH_IFaceResponseHandler_ptr _tao_elem)
{
  com::AMH_IFaceResponseHandler_ptr _tao_objptr =
    com::AMH_IFaceResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  com::AMH_IFaceResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<com::AMH_IFaceResponseHandler>::insert (
    _tao_any,
    com::AMH_IFaceResponseHandler::_tao_any_destructor,
    com::_tc_AMH_IFaceResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    com::AMH_IFaceResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<com::AMH_IFaceResponseHandler>::extract (
        _tao_any,
        com::AMH_IFaceResponseHandler::_tao_any_destructor,
        com::_tc_AMH_IFaceResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<com::AMI_IFaceHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  com::AMI_IFaceHandler_ptr _tao_elem)
{
  com::AMI_IFaceHandler_ptr _tao_objptr =
    com::AMI_IFaceHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  com::AMI_IFaceHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<com::AMI_IFaceHandler>::insert (
    _tao_any,
    com::AMI_IFaceHandler::_tao_any_destructor,
    com::_tc_AMI_IFaceHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    com::AMI_IFaceHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<com::AMI_IFaceHandler>::extract (
        _tao_any,
        com::AMI_IFaceHandler::_tao_any_destructor,
        com::_tc_AMI_IFaceHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Y::Z>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Y::Z_ptr _tao_elem)
{
  Y::Z_ptr _tao_objptr =
    Y::Z::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Y::Z_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Y::Z>::insert (
    _tao_any,
    Y::Z::_tao_any_destructor,
    Y::_tc_Z,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Y::Z_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Y::Z>::extract (
        _tao_any,
        Y::Z::_tao_any_destructor,
        Y::_tc_Z,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Y::AMH_ZExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Y::AMH_ZExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Y::AMH_ZExceptionHolder *_tao_copy =
      _tao_elem ?
        Y::AMH_ZExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Y::AMH_ZExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<Y::AMH_ZExceptionHolder>::insert (
    _tao_any,
    Y::AMH_ZExceptionHolder::_tao_any_destructor,
    Y::_tc_AMH_ZExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Y::AMH_ZExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<Y::AMH_ZExceptionHolder>::extract (
        _tao_any,
        Y::AMH_ZExceptionHolder::_tao_any_destructor,
        Y::_tc_AMH_ZExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Y::AMH_ZResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Y::AMH_ZResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<Y::AMH_ZResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Y::AMH_ZResponseHandler_ptr _tao_elem)
{
  Y::AMH_ZResponseHandler_ptr _tao_objptr =
    Y::AMH_ZResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Y::AMH_ZResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Y::AMH_ZResponseHandler>::insert (
    _tao_any,
    Y::AMH_ZResponseHandler::_tao_any_destructor,
    Y::_tc_AMH_ZResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Y::AMH_ZResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Y::AMH_ZResponseHandler>::extract (
        _tao_any,
        Y::AMH_ZResponseHandler::_tao_any_destructor,
        Y::_tc_AMH_ZResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Y::AMI_ZHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Y::AMI_ZHandler_ptr _tao_elem)
{
  Y::AMI_ZHandler_ptr _tao_objptr =
    Y::AMI_ZHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Y::AMI_ZHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Y::AMI_ZHandler>::insert (
    _tao_any,
    Y::AMI_ZHandler::_tao_any_destructor,
    Y::_tc_AMI_ZHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Y::AMI_ZHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Y::AMI_ZHandler>::extract (
        _tao_any,
        Y::AMI_ZHandler::_tao_any_destructor,
        Y::_tc_AMI_ZHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/any_op_cs.cpp:36


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<X::Ex>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const X::Ex &_tao_elem)
{
  TAO::Any_Dual_Impl_T<X::Ex>::insert_copy (
    _tao_any,
    X::Ex::_tao_any_destructor,
    X::_tc_Ex,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  X::Ex *_tao_elem)
{
  TAO::Any_Dual_Impl_T<X::Ex>::insert (
    _tao_any,
    X::Ex::_tao_any_destructor,
    X::_tc_Ex,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const X::Ex *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T<X::Ex>::extract (
    _tao_any,
    X::Ex::_tao_any_destructor,
    X::_tc_Ex,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<X::BI>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::BI_ptr _tao_elem)
{
  X::BI_ptr _tao_objptr =
    X::BI::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::BI_ptr *_tao_elem)
{
  TAO::Any_Impl_T<X::BI>::insert (
    _tao_any,
    X::BI::_tao_any_destructor,
    X::_tc_BI,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    X::BI_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<X::BI>::extract (
        _tao_any,
        X::BI::_tao_any_destructor,
        X::_tc_BI,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<X::AMH_BIExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::AMH_BIExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    X::AMH_BIExceptionHolder *_tao_copy =
      _tao_elem ?
        X::AMH_BIExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::AMH_BIExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<X::AMH_BIExceptionHolder>::insert (
    _tao_any,
    X::AMH_BIExceptionHolder::_tao_any_destructor,
    X::_tc_AMH_BIExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    X::AMH_BIExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<X::AMH_BIExceptionHolder>::extract (
        _tao_any,
        X::AMH_BIExceptionHolder::_tao_any_destructor,
        X::_tc_AMH_BIExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<X::AMH_BIResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<X::AMH_BIResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<X::AMH_BIResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::AMH_BIResponseHandler_ptr _tao_elem)
{
  X::AMH_BIResponseHandler_ptr _tao_objptr =
    X::AMH_BIResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::AMH_BIResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<X::AMH_BIResponseHandler>::insert (
    _tao_any,
    X::AMH_BIResponseHandler::_tao_any_destructor,
    X::_tc_AMH_BIResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    X::AMH_BIResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<X::AMH_BIResponseHandler>::extract (
        _tao_any,
        X::AMH_BIResponseHandler::_tao_any_destructor,
        X::_tc_AMH_BIResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<X::AMI_BIHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::AMI_BIHandler_ptr _tao_elem)
{
  X::AMI_BIHandler_ptr _tao_objptr =
    X::AMI_BIHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  X::AMI_BIHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<X::AMI_BIHandler>::insert (
    _tao_any,
    X::AMI_BIHandler::_tao_any_destructor,
    X::_tc_AMI_BIHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    X::AMI_BIHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<X::AMI_BIHandler>::extract (
        _tao_any,
        X::AMI_BIHandler::_tao_any_destructor,
        X::_tc_AMI_BIHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::blah_intfc>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::blah_intfc_ptr _tao_elem)
{
  XX::blah_intfc_ptr _tao_objptr =
    XX::blah_intfc::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::blah_intfc_ptr *_tao_elem)
{
  TAO::Any_Impl_T<XX::blah_intfc>::insert (
    _tao_any,
    XX::blah_intfc::_tao_any_destructor,
    XX::_tc_blah_intfc,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    XX::blah_intfc_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<XX::blah_intfc>::extract (
        _tao_any,
        XX::blah_intfc::_tao_any_destructor,
        XX::_tc_blah_intfc,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::AMH_blah_intfcExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMH_blah_intfcExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    XX::AMH_blah_intfcExceptionHolder *_tao_copy =
      _tao_elem ?
        XX::AMH_blah_intfcExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMH_blah_intfcExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<XX::AMH_blah_intfcExceptionHolder>::insert (
    _tao_any,
    XX::AMH_blah_intfcExceptionHolder::_tao_any_destructor,
    XX::_tc_AMH_blah_intfcExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    XX::AMH_blah_intfcExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<XX::AMH_blah_intfcExceptionHolder>::extract (
        _tao_any,
        XX::AMH_blah_intfcExceptionHolder::_tao_any_destructor,
        XX::_tc_AMH_blah_intfcExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::AMH_blah_intfcResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::AMH_blah_intfcResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::AMH_blah_intfcResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMH_blah_intfcResponseHandler_ptr _tao_elem)
{
  XX::AMH_blah_intfcResponseHandler_ptr _tao_objptr =
    XX::AMH_blah_intfcResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMH_blah_intfcResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<XX::AMH_blah_intfcResponseHandler>::insert (
    _tao_any,
    XX::AMH_blah_intfcResponseHandler::_tao_any_destructor,
    XX::_tc_AMH_blah_intfcResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    XX::AMH_blah_intfcResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<XX::AMH_blah_intfcResponseHandler>::extract (
        _tao_any,
        XX::AMH_blah_intfcResponseHandler::_tao_any_destructor,
        XX::_tc_AMH_blah_intfcResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::AMI_blah_intfcHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMI_blah_intfcHandler_ptr _tao_elem)
{
  XX::AMI_blah_intfcHandler_ptr _tao_objptr =
    XX::AMI_blah_intfcHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMI_blah_intfcHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<XX::AMI_blah_intfcHandler>::insert (
    _tao_any,
    XX::AMI_blah_intfcHandler::_tao_any_destructor,
    XX::_tc_AMI_blah_intfcHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    XX::AMI_blah_intfcHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<XX::AMI_blah_intfcHandler>::extract (
        _tao_any,
        XX::AMI_blah_intfcHandler::_tao_any_destructor,
        XX::_tc_AMI_blah_intfcHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::blah0>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::blah0_ptr _tao_elem)
{
  XX::blah0_ptr _tao_objptr =
    XX::blah0::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::blah0_ptr *_tao_elem)
{
  TAO::Any_Impl_T<XX::blah0>::insert (
    _tao_any,
    XX::blah0::_tao_any_destructor,
    XX::_tc_blah0,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    XX::blah0_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<XX::blah0>::extract (
        _tao_any,
        XX::blah0::_tao_any_destructor,
        XX::_tc_blah0,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::AMH_blah0ExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMH_blah0ExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    XX::AMH_blah0ExceptionHolder *_tao_copy =
      _tao_elem ?
        XX::AMH_blah0ExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMH_blah0ExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<XX::AMH_blah0ExceptionHolder>::insert (
    _tao_any,
    XX::AMH_blah0ExceptionHolder::_tao_any_destructor,
    XX::_tc_AMH_blah0ExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    XX::AMH_blah0ExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<XX::AMH_blah0ExceptionHolder>::extract (
        _tao_any,
        XX::AMH_blah0ExceptionHolder::_tao_any_destructor,
        XX::_tc_AMH_blah0ExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::AMH_blah0ResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::AMH_blah0ResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::AMH_blah0ResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMH_blah0ResponseHandler_ptr _tao_elem)
{
  XX::AMH_blah0ResponseHandler_ptr _tao_objptr =
    XX::AMH_blah0ResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMH_blah0ResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<XX::AMH_blah0ResponseHandler>::insert (
    _tao_any,
    XX::AMH_blah0ResponseHandler::_tao_any_destructor,
    XX::_tc_AMH_blah0ResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    XX::AMH_blah0ResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<XX::AMH_blah0ResponseHandler>::extract (
        _tao_any,
        XX::AMH_blah0ResponseHandler::_tao_any_destructor,
        XX::_tc_AMH_blah0ResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<XX::AMI_blah0Handler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMI_blah0Handler_ptr _tao_elem)
{
  XX::AMI_blah0Handler_ptr _tao_objptr =
    XX::AMI_blah0Handler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  XX::AMI_blah0Handler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<XX::AMI_blah0Handler>::insert (
    _tao_any,
    XX::AMI_blah0Handler::_tao_any_destructor,
    XX::_tc_AMI_blah0Handler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    XX::AMI_blah0Handler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<XX::AMI_blah0Handler>::extract (
        _tao_any,
        XX::AMI_blah0Handler::_tao_any_destructor,
        XX::_tc_AMI_blah0Handler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<frag::frag_iface>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  frag::frag_iface_ptr _tao_elem)
{
  frag::frag_iface_ptr _tao_objptr =
    frag::frag_iface::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  frag::frag_iface_ptr *_tao_elem)
{
  TAO::Any_Impl_T<frag::frag_iface>::insert (
    _tao_any,
    frag::frag_iface::_tao_any_destructor,
    frag::_tc_frag_iface,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    frag::frag_iface_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<frag::frag_iface>::extract (
        _tao_any,
        frag::frag_iface::_tao_any_destructor,
        frag::_tc_frag_iface,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<frag::AMH_frag_ifaceExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  frag::AMH_frag_ifaceExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    frag::AMH_frag_ifaceExceptionHolder *_tao_copy =
      _tao_elem ?
        frag::AMH_frag_ifaceExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  frag::AMH_frag_ifaceExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<frag::AMH_frag_ifaceExceptionHolder>::insert (
    _tao_any,
    frag::AMH_frag_ifaceExceptionHolder::_tao_any_destructor,
    frag::_tc_AMH_frag_ifaceExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    frag::AMH_frag_ifaceExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<frag::AMH_frag_ifaceExceptionHolder>::extract (
        _tao_any,
        frag::AMH_frag_ifaceExceptionHolder::_tao_any_destructor,
        frag::_tc_AMH_frag_ifaceExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<frag::AMH_frag_ifaceResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<frag::AMH_frag_ifaceResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<frag::AMH_frag_ifaceResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  frag::AMH_frag_ifaceResponseHandler_ptr _tao_elem)
{
  frag::AMH_frag_ifaceResponseHandler_ptr _tao_objptr =
    frag::AMH_frag_ifaceResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  frag::AMH_frag_ifaceResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<frag::AMH_frag_ifaceResponseHandler>::insert (
    _tao_any,
    frag::AMH_frag_ifaceResponseHandler::_tao_any_destructor,
    frag::_tc_AMH_frag_ifaceResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    frag::AMH_frag_ifaceResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<frag::AMH_frag_ifaceResponseHandler>::extract (
        _tao_any,
        frag::AMH_frag_ifaceResponseHandler::_tao_any_destructor,
        frag::_tc_AMH_frag_ifaceResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<frag::AMI_frag_ifaceHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  frag::AMI_frag_ifaceHandler_ptr _tao_elem)
{
  frag::AMI_frag_ifaceHandler_ptr _tao_objptr =
    frag::AMI_frag_ifaceHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  frag::AMI_frag_ifaceHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<frag::AMI_frag_ifaceHandler>::insert (
    _tao_any,
    frag::AMI_frag_ifaceHandler::_tao_any_destructor,
    frag::_tc_AMI_frag_ifaceHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    frag::AMI_frag_ifaceHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<frag::AMI_frag_ifaceHandler>::extract (
        _tao_any,
        frag::AMI_frag_ifaceHandler::_tao_any_destructor,
        frag::_tc_AMI_frag_ifaceHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<gather>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  gather_ptr _tao_elem)
{
  gather_ptr _tao_objptr =
    gather::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  gather_ptr *_tao_elem)
{
  TAO::Any_Impl_T<gather>::insert (
    _tao_any,
    gather::_tao_any_destructor,
    _tc_gather,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    gather_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<gather>::extract (
        _tao_any,
        gather::_tao_any_destructor,
        _tc_gather,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_gatherExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_gatherExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    AMH_gatherExceptionHolder *_tao_copy =
      _tao_elem ?
        AMH_gatherExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_gatherExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<AMH_gatherExceptionHolder>::insert (
    _tao_any,
    AMH_gatherExceptionHolder::_tao_any_destructor,
    _tc_AMH_gatherExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_gatherExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_gatherExceptionHolder>::extract (
        _tao_any,
        AMH_gatherExceptionHolder::_tao_any_destructor,
        _tc_AMH_gatherExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_gatherResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_gatherResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMH_gatherResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_gatherResponseHandler_ptr _tao_elem)
{
  AMH_gatherResponseHandler_ptr _tao_objptr =
    AMH_gatherResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMH_gatherResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMH_gatherResponseHandler>::insert (
    _tao_any,
    AMH_gatherResponseHandler::_tao_any_destructor,
    _tc_AMH_gatherResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMH_gatherResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMH_gatherResponseHandler>::extract (
        _tao_any,
        AMH_gatherResponseHandler::_tao_any_destructor,
        _tc_AMH_gatherResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<AMI_gatherHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_gatherHandler_ptr _tao_elem)
{
  AMI_gatherHandler_ptr _tao_objptr =
    AMI_gatherHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  AMI_gatherHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<AMI_gatherHandler>::insert (
    _tao_any,
    AMI_gatherHandler::_tao_any_destructor,
    _tc_AMI_gatherHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    AMI_gatherHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<AMI_gatherHandler>::extract (
        _tao_any,
        AMI_gatherHandler::_tao_any_destructor,
        _tc_AMI_gatherHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::bar &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::bar>::insert_copy (
    _tao_any,
    ::bar::_tao_any_destructor,
    _tc_bar,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::bar *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::bar>::insert (
    _tao_any,
    ::bar::_tao_any_destructor,
    _tc_bar,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::bar *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::bar>::extract (
    _tao_any,
    ::bar::_tao_any_destructor,
    _tc_bar,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::foo::foo_struct &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::foo::foo_struct>::insert_copy (
    _tao_any,
    ::foo::foo_struct::_tao_any_destructor,
    foo::_tc_foo_struct,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::foo::foo_struct *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::foo::foo_struct>::insert (
    _tao_any,
    ::foo::foo_struct::_tao_any_destructor,
    foo::_tc_foo_struct,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::foo::foo_struct *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::foo::foo_struct>::extract (
    _tao_any,
    ::foo::foo_struct::_tao_any_destructor,
    foo::_tc_foo_struct,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<foo::obj>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  foo::obj_ptr _tao_elem)
{
  foo::obj_ptr _tao_objptr =
    foo::obj::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  foo::obj_ptr *_tao_elem)
{
  TAO::Any_Impl_T<foo::obj>::insert (
    _tao_any,
    foo::obj::_tao_any_destructor,
    foo::_tc_obj,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    foo::obj_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<foo::obj>::extract (
        _tao_any,
        foo::obj::_tao_any_destructor,
        foo::_tc_obj,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<foo::AMH_objExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  foo::AMH_objExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    foo::AMH_objExceptionHolder *_tao_copy =
      _tao_elem ?
        foo::AMH_objExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  foo::AMH_objExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<foo::AMH_objExceptionHolder>::insert (
    _tao_any,
    foo::AMH_objExceptionHolder::_tao_any_destructor,
    foo::_tc_AMH_objExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    foo::AMH_objExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<foo::AMH_objExceptionHolder>::extract (
        _tao_any,
        foo::AMH_objExceptionHolder::_tao_any_destructor,
        foo::_tc_AMH_objExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<foo::AMH_objResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<foo::AMH_objResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<foo::AMH_objResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  foo::AMH_objResponseHandler_ptr _tao_elem)
{
  foo::AMH_objResponseHandler_ptr _tao_objptr =
    foo::AMH_objResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  foo::AMH_objResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<foo::AMH_objResponseHandler>::insert (
    _tao_any,
    foo::AMH_objResponseHandler::_tao_any_destructor,
    foo::_tc_AMH_objResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    foo::AMH_objResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<foo::AMH_objResponseHandler>::extract (
        _tao_any,
        foo::AMH_objResponseHandler::_tao_any_destructor,
        foo::_tc_AMH_objResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<foo::AMI_objHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  foo::AMI_objHandler_ptr _tao_elem)
{
  foo::AMI_objHandler_ptr _tao_objptr =
    foo::AMI_objHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  foo::AMI_objHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<foo::AMI_objHandler>::insert (
    _tao_any,
    foo::AMI_objHandler::_tao_any_destructor,
    foo::_tc_AMI_objHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    foo::AMI_objHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<foo::AMI_objHandler>::extract (
        _tao_any,
        foo::AMI_objHandler::_tao_any_destructor,
        foo::_tc_AMI_objHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/any_op_cs.cpp:43


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {


/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::A::B::X2Seq &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::A::B::X2Seq>::insert_copy (
    _tao_any,
    ::A::B::X2Seq::_tao_any_destructor,
    ::A::B::_tc_X2Seq,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::A::B::X2Seq *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::A::B::X2Seq>::insert (
    _tao_any,
    ::A::B::X2Seq::_tao_any_destructor,
    ::A::B::_tc_X2Seq,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::A::B::X2Seq *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::A::B::X2Seq>::extract (
    _tao_any,
    ::A::B::X2Seq::_tao_any_destructor,
    ::A::B::_tc_X2Seq,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A::B::X3>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A::B::X3_ptr _tao_elem)
{
  A::B::X3_ptr _tao_objptr =
    A::B::X3::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A::B::X3_ptr *_tao_elem)
{
  TAO::Any_Impl_T<A::B::X3>::insert (
    _tao_any,
    A::B::X3::_tao_any_destructor,
    A::B::_tc_X3,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A::B::X3_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<A::B::X3>::extract (
        _tao_any,
        A::B::X3::_tao_any_destructor,
        A::B::_tc_X3,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A::B::AMH_X3ExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A::B::AMH_X3ExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    A::B::AMH_X3ExceptionHolder *_tao_copy =
      _tao_elem ?
        A::B::AMH_X3ExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A::B::AMH_X3ExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<A::B::AMH_X3ExceptionHolder>::insert (
    _tao_any,
    A::B::AMH_X3ExceptionHolder::_tao_any_destructor,
    A::B::_tc_AMH_X3ExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A::B::AMH_X3ExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<A::B::AMH_X3ExceptionHolder>::extract (
        _tao_any,
        A::B::AMH_X3ExceptionHolder::_tao_any_destructor,
        A::B::_tc_AMH_X3ExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A::B::AMH_X3ResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A::B::AMH_X3ResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<A::B::AMH_X3ResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A::B::AMH_X3ResponseHandler_ptr _tao_elem)
{
  A::B::AMH_X3ResponseHandler_ptr _tao_objptr =
    A::B::AMH_X3ResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A::B::AMH_X3ResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<A::B::AMH_X3ResponseHandler>::insert (
    _tao_any,
    A::B::AMH_X3ResponseHandler::_tao_any_destructor,
    A::B::_tc_AMH_X3ResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A::B::AMH_X3ResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<A::B::AMH_X3ResponseHandler>::extract (
        _tao_any,
        A::B::AMH_X3ResponseHandler::_tao_any_destructor,
        A::B::_tc_AMH_X3ResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A::B::AMI_X3Handler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A::B::AMI_X3Handler_ptr _tao_elem)
{
  A::B::AMI_X3Handler_ptr _tao_objptr =
    A::B::AMI_X3Handler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A::B::AMI_X3Handler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<A::B::AMI_X3Handler>::insert (
    _tao_any,
    A::B::AMI_X3Handler::_tao_any_destructor,
    A::B::_tc_AMI_X3Handler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A::B::AMI_X3Handler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<A::B::AMI_X3Handler>::extract (
        _tao_any,
        A::B::AMI_X3Handler::_tao_any_destructor,
        A::B::_tc_AMI_X3Handler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mA::A>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mA::A_ptr _tao_elem)
{
  mA::A_ptr _tao_objptr =
    mA::A::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mA::A_ptr *_tao_elem)
{
  TAO::Any_Impl_T<mA::A>::insert (
    _tao_any,
    mA::A::_tao_any_destructor,
    mA::_tc_A,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mA::A_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<mA::A>::extract (
        _tao_any,
        mA::A::_tao_any_destructor,
        mA::_tc_A,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mA::AMH_AExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mA::AMH_AExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    mA::AMH_AExceptionHolder *_tao_copy =
      _tao_elem ?
        mA::AMH_AExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mA::AMH_AExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<mA::AMH_AExceptionHolder>::insert (
    _tao_any,
    mA::AMH_AExceptionHolder::_tao_any_destructor,
    mA::_tc_AMH_AExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mA::AMH_AExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<mA::AMH_AExceptionHolder>::extract (
        _tao_any,
        mA::AMH_AExceptionHolder::_tao_any_destructor,
        mA::_tc_AMH_AExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mA::AMH_AResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mA::AMH_AResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<mA::AMH_AResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mA::AMH_AResponseHandler_ptr _tao_elem)
{
  mA::AMH_AResponseHandler_ptr _tao_objptr =
    mA::AMH_AResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mA::AMH_AResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<mA::AMH_AResponseHandler>::insert (
    _tao_any,
    mA::AMH_AResponseHandler::_tao_any_destructor,
    mA::_tc_AMH_AResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mA::AMH_AResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<mA::AMH_AResponseHandler>::extract (
        _tao_any,
        mA::AMH_AResponseHandler::_tao_any_destructor,
        mA::_tc_AMH_AResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mA::AMI_AHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mA::AMI_AHandler_ptr _tao_elem)
{
  mA::AMI_AHandler_ptr _tao_objptr =
    mA::AMI_AHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mA::AMI_AHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<mA::AMI_AHandler>::insert (
    _tao_any,
    mA::AMI_AHandler::_tao_any_destructor,
    mA::_tc_AMI_AHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mA::AMI_AHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<mA::AMI_AHandler>::extract (
        _tao_any,
        mA::AMI_AHandler::_tao_any_destructor,
        mA::_tc_AMI_AHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mB::B>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mB::B_ptr _tao_elem)
{
  mB::B_ptr _tao_objptr =
    mB::B::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mB::B_ptr *_tao_elem)
{
  TAO::Any_Impl_T<mB::B>::insert (
    _tao_any,
    mB::B::_tao_any_destructor,
    mB::_tc_B,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mB::B_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<mB::B>::extract (
        _tao_any,
        mB::B::_tao_any_destructor,
        mB::_tc_B,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mB::AMH_BExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mB::AMH_BExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    mB::AMH_BExceptionHolder *_tao_copy =
      _tao_elem ?
        mB::AMH_BExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mB::AMH_BExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<mB::AMH_BExceptionHolder>::insert (
    _tao_any,
    mB::AMH_BExceptionHolder::_tao_any_destructor,
    mB::_tc_AMH_BExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mB::AMH_BExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<mB::AMH_BExceptionHolder>::extract (
        _tao_any,
        mB::AMH_BExceptionHolder::_tao_any_destructor,
        mB::_tc_AMH_BExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mB::AMH_BResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mB::AMH_BResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<mB::AMH_BResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mB::AMH_BResponseHandler_ptr _tao_elem)
{
  mB::AMH_BResponseHandler_ptr _tao_objptr =
    mB::AMH_BResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mB::AMH_BResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<mB::AMH_BResponseHandler>::insert (
    _tao_any,
    mB::AMH_BResponseHandler::_tao_any_destructor,
    mB::_tc_AMH_BResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mB::AMH_BResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<mB::AMH_BResponseHandler>::extract (
        _tao_any,
        mB::AMH_BResponseHandler::_tao_any_destructor,
        mB::_tc_AMH_BResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mB::AMI_BHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mB::AMI_BHandler_ptr _tao_elem)
{
  mB::AMI_BHandler_ptr _tao_objptr =
    mB::AMI_BHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mB::AMI_BHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<mB::AMI_BHandler>::insert (
    _tao_any,
    mB::AMI_BHandler::_tao_any_destructor,
    mB::_tc_AMI_BHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mB::AMI_BHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<mB::AMI_BHandler>::extract (
        _tao_any,
        mB::AMI_BHandler::_tao_any_destructor,
        mB::_tc_AMI_BHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mC::C>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mC::C_ptr _tao_elem)
{
  mC::C_ptr _tao_objptr =
    mC::C::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mC::C_ptr *_tao_elem)
{
  TAO::Any_Impl_T<mC::C>::insert (
    _tao_any,
    mC::C::_tao_any_destructor,
    mC::_tc_C,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mC::C_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<mC::C>::extract (
        _tao_any,
        mC::C::_tao_any_destructor,
        mC::_tc_C,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mC::AMH_CExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mC::AMH_CExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    mC::AMH_CExceptionHolder *_tao_copy =
      _tao_elem ?
        mC::AMH_CExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mC::AMH_CExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<mC::AMH_CExceptionHolder>::insert (
    _tao_any,
    mC::AMH_CExceptionHolder::_tao_any_destructor,
    mC::_tc_AMH_CExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mC::AMH_CExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<mC::AMH_CExceptionHolder>::extract (
        _tao_any,
        mC::AMH_CExceptionHolder::_tao_any_destructor,
        mC::_tc_AMH_CExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mC::AMH_CResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mC::AMH_CResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<mC::AMH_CResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mC::AMH_CResponseHandler_ptr _tao_elem)
{
  mC::AMH_CResponseHandler_ptr _tao_objptr =
    mC::AMH_CResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mC::AMH_CResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<mC::AMH_CResponseHandler>::insert (
    _tao_any,
    mC::AMH_CResponseHandler::_tao_any_destructor,
    mC::_tc_AMH_CResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mC::AMH_CResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<mC::AMH_CResponseHandler>::extract (
        _tao_any,
        mC::AMH_CResponseHandler::_tao_any_destructor,
        mC::_tc_AMH_CResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<mC::AMI_CHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mC::AMI_CHandler_ptr _tao_elem)
{
  mC::AMI_CHandler_ptr _tao_objptr =
    mC::AMI_CHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  mC::AMI_CHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<mC::AMI_CHandler>::insert (
    _tao_any,
    mC::AMI_CHandler::_tao_any_destructor,
    mC::_tc_AMI_CHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    mC::AMI_CHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<mC::AMI_CHandler>::extract (
        _tao_any,
        mC::AMI_CHandler::_tao_any_destructor,
        mC::_tc_AMI_CHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Schmoik::foo>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Schmoik::foo_ptr _tao_elem)
{
  Schmoik::foo_ptr _tao_objptr =
    Schmoik::foo::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Schmoik::foo_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Schmoik::foo>::insert (
    _tao_any,
    Schmoik::foo::_tao_any_destructor,
    Schmoik::_tc_foo,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Schmoik::foo_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Schmoik::foo>::extract (
        _tao_any,
        Schmoik::foo::_tao_any_destructor,
        Schmoik::_tc_foo,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Schmoik::AMH_fooExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Schmoik::AMH_fooExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Schmoik::AMH_fooExceptionHolder *_tao_copy =
      _tao_elem ?
        Schmoik::AMH_fooExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Schmoik::AMH_fooExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<Schmoik::AMH_fooExceptionHolder>::insert (
    _tao_any,
    Schmoik::AMH_fooExceptionHolder::_tao_any_destructor,
    Schmoik::_tc_AMH_fooExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Schmoik::AMH_fooExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<Schmoik::AMH_fooExceptionHolder>::extract (
        _tao_any,
        Schmoik::AMH_fooExceptionHolder::_tao_any_destructor,
        Schmoik::_tc_AMH_fooExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Schmoik::AMH_fooResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Schmoik::AMH_fooResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<Schmoik::AMH_fooResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Schmoik::AMH_fooResponseHandler_ptr _tao_elem)
{
  Schmoik::AMH_fooResponseHandler_ptr _tao_objptr =
    Schmoik::AMH_fooResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Schmoik::AMH_fooResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Schmoik::AMH_fooResponseHandler>::insert (
    _tao_any,
    Schmoik::AMH_fooResponseHandler::_tao_any_destructor,
    Schmoik::_tc_AMH_fooResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Schmoik::AMH_fooResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Schmoik::AMH_fooResponseHandler>::extract (
        _tao_any,
        Schmoik::AMH_fooResponseHandler::_tao_any_destructor,
        Schmoik::_tc_AMH_fooResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Schmoik::AMI_fooHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Schmoik::AMI_fooHandler_ptr _tao_elem)
{
  Schmoik::AMI_fooHandler_ptr _tao_objptr =
    Schmoik::AMI_fooHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Schmoik::AMI_fooHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Schmoik::AMI_fooHandler>::insert (
    _tao_any,
    Schmoik::AMI_fooHandler::_tao_any_destructor,
    Schmoik::_tc_AMI_fooHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Schmoik::AMI_fooHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Schmoik::AMI_fooHandler>::extract (
        _tao_any,
        Schmoik::AMI_fooHandler::_tao_any_destructor,
        Schmoik::_tc_AMI_fooHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::Schmoik::bar &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Schmoik::bar>::insert_copy (
    _tao_any,
    ::Schmoik::bar::_tao_any_destructor,
    Schmoik::_tc_bar,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::Schmoik::bar *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Schmoik::bar>::insert (
    _tao_any,
    ::Schmoik::bar::_tao_any_destructor,
    Schmoik::_tc_bar,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::Schmoik::bar *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::Schmoik::bar>::extract (
    _tao_any,
    ::Schmoik::bar::_tao_any_destructor,
    Schmoik::_tc_bar,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/any_op_cs.cpp:43


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {


/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::Thwoik::ub_TestTypeSeq &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Thwoik::ub_TestTypeSeq>::insert_copy (
    _tao_any,
    ::Thwoik::ub_TestTypeSeq::_tao_any_destructor,
    ::Thwoik::_tc_ub_TestTypeSeq,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::Thwoik::ub_TestTypeSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Thwoik::ub_TestTypeSeq>::insert (
    _tao_any,
    ::Thwoik::ub_TestTypeSeq::_tao_any_destructor,
    ::Thwoik::_tc_ub_TestTypeSeq,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::Thwoik::ub_TestTypeSeq *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::Thwoik::ub_TestTypeSeq>::extract (
    _tao_any,
    ::Thwoik::ub_TestTypeSeq::_tao_any_destructor,
    ::Thwoik::_tc_ub_TestTypeSeq,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/any_op_cs.cpp:43


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {


/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const ::Thwoik::bd_TestTypeSeq &_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Thwoik::bd_TestTypeSeq>::insert_copy (
    _tao_any,
    ::Thwoik::bd_TestTypeSeq::_tao_any_destructor,
    ::Thwoik::_tc_bd_TestTypeSeq,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  ::Thwoik::bd_TestTypeSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Thwoik::bd_TestTypeSeq>::insert (
    _tao_any,
    ::Thwoik::bd_TestTypeSeq::_tao_any_destructor,
    ::Thwoik::_tc_bd_TestTypeSeq,
    _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const ::Thwoik::bd_TestTypeSeq *&_tao_elem)
{
  return TAO::Any_Dual_Impl_T< ::Thwoik::bd_TestTypeSeq>::extract (
    _tao_any,
    ::Thwoik::bd_TestTypeSeq::_tao_any_destructor,
    ::Thwoik::_tc_bd_TestTypeSeq,
    _tao_elem);
}
}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Thwoik::TestType>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Thwoik::TestType_ptr _tao_elem)
{
  Thwoik::TestType_ptr _tao_objptr =
    Thwoik::TestType::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Thwoik::TestType_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Thwoik::TestType>::insert (
    _tao_any,
    Thwoik::TestType::_tao_any_destructor,
    Thwoik::_tc_TestType,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Thwoik::TestType_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Thwoik::TestType>::extract (
        _tao_any,
        Thwoik::TestType::_tao_any_destructor,
        Thwoik::_tc_TestType,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Thwoik::AMH_TestTypeExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Thwoik::AMH_TestTypeExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Thwoik::AMH_TestTypeExceptionHolder *_tao_copy =
      _tao_elem ?
        Thwoik::AMH_TestTypeExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Thwoik::AMH_TestTypeExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<Thwoik::AMH_TestTypeExceptionHolder>::insert (
    _tao_any,
    Thwoik::AMH_TestTypeExceptionHolder::_tao_any_destructor,
    Thwoik::_tc_AMH_TestTypeExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Thwoik::AMH_TestTypeExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<Thwoik::AMH_TestTypeExceptionHolder>::extract (
        _tao_any,
        Thwoik::AMH_TestTypeExceptionHolder::_tao_any_destructor,
        Thwoik::_tc_AMH_TestTypeExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Thwoik::AMH_TestTypeResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Thwoik::AMH_TestTypeResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<Thwoik::AMH_TestTypeResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Thwoik::AMH_TestTypeResponseHandler_ptr _tao_elem)
{
  Thwoik::AMH_TestTypeResponseHandler_ptr _tao_objptr =
    Thwoik::AMH_TestTypeResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Thwoik::AMH_TestTypeResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Thwoik::AMH_TestTypeResponseHandler>::insert (
    _tao_any,
    Thwoik::AMH_TestTypeResponseHandler::_tao_any_destructor,
    Thwoik::_tc_AMH_TestTypeResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Thwoik::AMH_TestTypeResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Thwoik::AMH_TestTypeResponseHandler>::extract (
        _tao_any,
        Thwoik::AMH_TestTypeResponseHandler::_tao_any_destructor,
        Thwoik::_tc_AMH_TestTypeResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Thwoik::AMI_TestTypeHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Thwoik::AMI_TestTypeHandler_ptr _tao_elem)
{
  Thwoik::AMI_TestTypeHandler_ptr _tao_objptr =
    Thwoik::AMI_TestTypeHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  Thwoik::AMI_TestTypeHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Thwoik::AMI_TestTypeHandler>::insert (
    _tao_any,
    Thwoik::AMI_TestTypeHandler::_tao_any_destructor,
    Thwoik::_tc_AMI_TestTypeHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Thwoik::AMI_TestTypeHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Thwoik::AMI_TestTypeHandler>::extract (
        _tao_any,
        Thwoik::AMI_TestTypeHandler::_tao_any_destructor,
        Thwoik::_tc_AMI_TestTypeHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::Foo>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::Foo_ptr _tao_elem)
{
  A_mod::Foo_ptr _tao_objptr =
    A_mod::Foo::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::Foo_ptr *_tao_elem)
{
  TAO::Any_Impl_T<A_mod::Foo>::insert (
    _tao_any,
    A_mod::Foo::_tao_any_destructor,
    A_mod::_tc_Foo,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A_mod::Foo_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<A_mod::Foo>::extract (
        _tao_any,
        A_mod::Foo::_tao_any_destructor,
        A_mod::_tc_Foo,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::AMH_FooExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::AMH_FooExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    A_mod::AMH_FooExceptionHolder *_tao_copy =
      _tao_elem ?
        A_mod::AMH_FooExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::AMH_FooExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<A_mod::AMH_FooExceptionHolder>::insert (
    _tao_any,
    A_mod::AMH_FooExceptionHolder::_tao_any_destructor,
    A_mod::_tc_AMH_FooExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A_mod::AMH_FooExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<A_mod::AMH_FooExceptionHolder>::extract (
        _tao_any,
        A_mod::AMH_FooExceptionHolder::_tao_any_destructor,
        A_mod::_tc_AMH_FooExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::AMH_FooResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::AMH_FooResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::AMH_FooResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::AMH_FooResponseHandler_ptr _tao_elem)
{
  A_mod::AMH_FooResponseHandler_ptr _tao_objptr =
    A_mod::AMH_FooResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::AMH_FooResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<A_mod::AMH_FooResponseHandler>::insert (
    _tao_any,
    A_mod::AMH_FooResponseHandler::_tao_any_destructor,
    A_mod::_tc_AMH_FooResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A_mod::AMH_FooResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<A_mod::AMH_FooResponseHandler>::extract (
        _tao_any,
        A_mod::AMH_FooResponseHandler::_tao_any_destructor,
        A_mod::_tc_AMH_FooResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::AMI_FooHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::AMI_FooHandler_ptr _tao_elem)
{
  A_mod::AMI_FooHandler_ptr _tao_objptr =
    A_mod::AMI_FooHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::AMI_FooHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<A_mod::AMI_FooHandler>::insert (
    _tao_any,
    A_mod::AMI_FooHandler::_tao_any_destructor,
    A_mod::_tc_AMI_FooHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A_mod::AMI_FooHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<A_mod::AMI_FooHandler>::extract (
        _tao_any,
        A_mod::AMI_FooHandler::_tao_any_destructor,
        A_mod::_tc_AMI_FooHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::B_mod::Foo>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::B_mod::Foo_ptr _tao_elem)
{
  A_mod::B_mod::Foo_ptr _tao_objptr =
    A_mod::B_mod::Foo::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::B_mod::Foo_ptr *_tao_elem)
{
  TAO::Any_Impl_T<A_mod::B_mod::Foo>::insert (
    _tao_any,
    A_mod::B_mod::Foo::_tao_any_destructor,
    A_mod::B_mod::_tc_Foo,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A_mod::B_mod::Foo_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<A_mod::B_mod::Foo>::extract (
        _tao_any,
        A_mod::B_mod::Foo::_tao_any_destructor,
        A_mod::B_mod::_tc_Foo,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/any_op_cs.cpp:44


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::B_mod::AMH_FooExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {

/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::B_mod::AMH_FooExceptionHolder *_tao_elem)
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    A_mod::B_mod::AMH_FooExceptionHolder *_tao_copy =
      _tao_elem ?
        A_mod::B_mod::AMH_FooExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : nullptr;
    _tao_any <<= std::addressof(_tao_copy);
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= std::addressof(_tao_elem);
  #endif
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::B_mod::AMH_FooExceptionHolder **_tao_elem)
{
  TAO::Any_Impl_T<A_mod::B_mod::AMH_FooExceptionHolder>::insert (
    _tao_any,
    A_mod::B_mod::AMH_FooExceptionHolder::_tao_any_destructor,
    A_mod::B_mod::_tc_AMH_FooExceptionHolder,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A_mod::B_mod::AMH_FooExceptionHolder *&_tao_elem)
{
  return
    TAO::Any_Impl_T<A_mod::B_mod::AMH_FooExceptionHolder>::extract (
        _tao_any,
        A_mod::B_mod::AMH_FooExceptionHolder::_tao_any_destructor,
        A_mod::B_mod::_tc_AMH_FooExceptionHolder,
        _tao_elem);
}


}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::B_mod::AMH_FooResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::B_mod::AMH_FooResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::B_mod::AMH_FooResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::B_mod::AMH_FooResponseHandler_ptr _tao_elem)
{
  A_mod::B_mod::AMH_FooResponseHandler_ptr _tao_objptr =
    A_mod::B_mod::AMH_FooResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::B_mod::AMH_FooResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<A_mod::B_mod::AMH_FooResponseHandler>::insert (
    _tao_any,
    A_mod::B_mod::AMH_FooResponseHandler::_tao_any_destructor,
    A_mod::B_mod::_tc_AMH_FooResponseHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A_mod::B_mod::AMH_FooResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<A_mod::B_mod::AMH_FooResponseHandler>::extract (
        _tao_any,
        A_mod::B_mod::AMH_FooResponseHandler::_tao_any_destructor,
        A_mod::B_mod::_tc_AMH_FooResponseHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<A_mod::B_mod::AMI_FooHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL
namespace CORBA {



/// Copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::B_mod::AMI_FooHandler_ptr _tao_elem)
{
  A_mod::B_mod::AMI_FooHandler_ptr _tao_objptr =
    A_mod::B_mod::AMI_FooHandler::_duplicate (_tao_elem);
  _tao_any <<= std::addressof(_tao_objptr);
}

/// Non-copying insertion.
void
operator<<= (
  ::CORBA::Any &_tao_any,
  A_mod::B_mod::AMI_FooHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<A_mod::B_mod::AMI_FooHandler>::insert (
    _tao_any,
    A_mod::B_mod::AMI_FooHandler::_tao_any_destructor,
    A_mod::B_mod::_tc_AMI_FooHandler,
    *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    A_mod::B_mod::AMI_FooHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<A_mod::B_mod::AMI_FooHandler>::extract (
        _tao_any,
        A_mod::B_mod::AMI_FooHandler::_tao_any_destructor,
        A_mod::B_mod::_tc_AMI_FooHandler,
        _tao_elem);
}

}
TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AA::BB::x1_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AA::BB::x1_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AA::BB::x1>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AA::BB::AMH_x1ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AA::BB::AMH_x1ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AA::BB::AMH_x1ExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AA::BB::AMH_x1ExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AA::BB::AMH_x1ExceptionHolder *&_tao_valuetype)
{
  return AA::BB::AMH_x1ExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AA::BB::AMH_x1ExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AA::BB::AMH_x1ExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AA::BB::AMH_x1ExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AA::BB::AMI_x1Handler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AA::BB::AMI_x1Handler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AA::BB::AMI_x1Handler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AA::BB::CC::x2_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AA::BB::CC::x2_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AA::BB::CC::x2>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AA::BB::CC::AMH_x2ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AA::BB::CC::AMH_x2ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AA::BB::CC::AMH_x2ExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AA::BB::CC::AMH_x2ExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AA::BB::CC::AMH_x2ExceptionHolder *&_tao_valuetype)
{
  return AA::BB::CC::AMH_x2ExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AA::BB::CC::AMH_x2ExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AA::BB::CC::AMH_x2ExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AA::BB::CC::AMH_x2ExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AA::BB::CC::AMI_x2Handler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AA::BB::CC::AMI_x2Handler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AA::BB::CC::AMI_x2Handler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const dot::Person_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    dot::Person_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::dot::Person>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (dot::AMH_PersonExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (dot::AMH_PersonExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const dot::AMH_PersonExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&dot::AMH_PersonExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    dot::AMH_PersonExceptionHolder *&_tao_valuetype)
{
  return dot::AMH_PersonExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_dot::AMH_PersonExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_dot::AMH_PersonExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_dot::AMH_PersonExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const dot::AMI_PersonHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    dot::AMI_PersonHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::dot::AMI_PersonHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const dot::Party_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    dot::Party_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::dot::Party>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (dot::AMH_PartyExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (dot::AMH_PartyExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const dot::AMH_PartyExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&dot::AMH_PartyExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    dot::AMH_PartyExceptionHolder *&_tao_valuetype)
{
  return dot::AMH_PartyExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_dot::AMH_PartyExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_dot::AMH_PartyExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_dot::AMH_PartyExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const dot::AMI_PartyHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    dot::AMI_PartyHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::dot::AMI_PartyHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const OpHolder_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    OpHolder_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::OpHolder>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_OpHolderExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_OpHolderExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_OpHolderExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_OpHolderExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_OpHolderExceptionHolder *&_tao_valuetype)
{
  return AMH_OpHolderExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_OpHolderExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_OpHolderExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_OpHolderExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_OpHolderHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_OpHolderHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_OpHolderHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const com::IFace_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    com::IFace_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::com::IFace>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (com::AMH_IFaceExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (com::AMH_IFaceExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const com::AMH_IFaceExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&com::AMH_IFaceExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    com::AMH_IFaceExceptionHolder *&_tao_valuetype)
{
  return com::AMH_IFaceExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_com::AMH_IFaceExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_com::AMH_IFaceExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_com::AMH_IFaceExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const com::AMI_IFaceHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    com::AMI_IFaceHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::com::AMI_IFaceHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Y::Z_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Y::Z_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Y::Z>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (Y::AMH_ZExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Y::AMH_ZExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Y::AMH_ZExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Y::AMH_ZExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Y::AMH_ZExceptionHolder *&_tao_valuetype)
{
  return Y::AMH_ZExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_Y::AMH_ZExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_Y::AMH_ZExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_Y::AMH_ZExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Y::AMI_ZHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Y::AMI_ZHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Y::AMI_ZHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_exception/cdr_op_cs.cpp:47


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const X::Ex &_tao_aggregate)
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    X::Ex&)
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const X::BI_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    X::BI_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::X::BI>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (X::AMH_BIExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (X::AMH_BIExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const X::AMH_BIExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&X::AMH_BIExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    X::AMH_BIExceptionHolder *&_tao_valuetype)
{
  return X::AMH_BIExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_X::AMH_BIExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_X::AMH_BIExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_X::AMH_BIExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const X::AMI_BIHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    X::AMI_BIHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::X::AMI_BIHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const XX::blah_intfc_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    XX::blah_intfc_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::XX::blah_intfc>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (XX::AMH_blah_intfcExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (XX::AMH_blah_intfcExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const XX::AMH_blah_intfcExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&XX::AMH_blah_intfcExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    XX::AMH_blah_intfcExceptionHolder *&_tao_valuetype)
{
  return XX::AMH_blah_intfcExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_XX::AMH_blah_intfcExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_XX::AMH_blah_intfcExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_XX::AMH_blah_intfcExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const XX::AMI_blah_intfcHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    XX::AMI_blah_intfcHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::XX::AMI_blah_intfcHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const XX::blah0_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    XX::blah0_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::XX::blah0>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (XX::AMH_blah0ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (XX::AMH_blah0ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const XX::AMH_blah0ExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&XX::AMH_blah0ExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    XX::AMH_blah0ExceptionHolder *&_tao_valuetype)
{
  return XX::AMH_blah0ExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_XX::AMH_blah0ExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_XX::AMH_blah0ExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_XX::AMH_blah0ExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const XX::AMI_blah0Handler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    XX::AMI_blah0Handler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::XX::AMI_blah0Handler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const frag::frag_iface_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    frag::frag_iface_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::frag::frag_iface>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (frag::AMH_frag_ifaceExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (frag::AMH_frag_ifaceExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const frag::AMH_frag_ifaceExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&frag::AMH_frag_ifaceExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    frag::AMH_frag_ifaceExceptionHolder *&_tao_valuetype)
{
  return frag::AMH_frag_ifaceExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_frag::AMH_frag_ifaceExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_frag::AMH_frag_ifaceExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_frag::AMH_frag_ifaceExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const frag::AMI_frag_ifaceHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    frag::AMI_frag_ifaceHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::frag::AMI_frag_ifaceHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const gather_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    gather_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::gather>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (AMH_gatherExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (AMH_gatherExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const AMH_gatherExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&AMH_gatherExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    AMH_gatherExceptionHolder *&_tao_valuetype)
{
  return AMH_gatherExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_AMH_gatherExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_AMH_gatherExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_AMH_gatherExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const AMI_gatherHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    AMI_gatherHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::AMI_gatherHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const bar &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.s) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    bar &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.s) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const foo::foo_struct &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.longval) &&
    (strm << _tao_aggregate.longval2) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    foo::foo_struct &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.longval) &&
    (strm >> _tao_aggregate.longval2) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const foo::obj_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    foo::obj_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::foo::obj>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (foo::AMH_objExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (foo::AMH_objExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const foo::AMH_objExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&foo::AMH_objExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    foo::AMH_objExceptionHolder *&_tao_valuetype)
{
  return foo::AMH_objExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_foo::AMH_objExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_foo::AMH_objExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_foo::AMH_objExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const foo::AMI_objHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    foo::AMI_objHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::foo::AMI_objHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/cdr_op_cs.cpp:92

#if !defined _TAO_CDR_OP_A_B_X2Seq_CPP_
#define _TAO_CDR_OP_A_B_X2Seq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const A::B::X2Seq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    A::B::X2Seq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_A_B_X2Seq_CPP_ */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const A::B::X3_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    A::B::X3_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::A::B::X3>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (A::B::AMH_X3ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (A::B::AMH_X3ExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const A::B::AMH_X3ExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&A::B::AMH_X3ExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    A::B::AMH_X3ExceptionHolder *&_tao_valuetype)
{
  return A::B::AMH_X3ExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_A::B::AMH_X3ExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_A::B::AMH_X3ExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_A::B::AMH_X3ExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const A::B::AMI_X3Handler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    A::B::AMI_X3Handler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::A::B::AMI_X3Handler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const mA::A_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    mA::A_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::mA::A>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (mA::AMH_AExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (mA::AMH_AExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const mA::AMH_AExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&mA::AMH_AExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    mA::AMH_AExceptionHolder *&_tao_valuetype)
{
  return mA::AMH_AExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_mA::AMH_AExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_mA::AMH_AExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_mA::AMH_AExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const mA::AMI_AHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    mA::AMI_AHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::mA::AMI_AHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const mB::B_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    mB::B_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::mB::B>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (mB::AMH_BExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (mB::AMH_BExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const mB::AMH_BExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&mB::AMH_BExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    mB::AMH_BExceptionHolder *&_tao_valuetype)
{
  return mB::AMH_BExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_mB::AMH_BExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_mB::AMH_BExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_mB::AMH_BExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const mB::AMI_BHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    mB::AMI_BHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::mB::AMI_BHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const mC::C_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    mC::C_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::mC::C>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (mC::AMH_CExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (mC::AMH_CExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const mC::AMH_CExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&mC::AMH_CExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    mC::AMH_CExceptionHolder *&_tao_valuetype)
{
  return mC::AMH_CExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_mC::AMH_CExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_mC::AMH_CExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_mC::AMH_CExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const mC::AMI_CHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    mC::AMI_CHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::mC::AMI_CHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Schmoik::foo_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Schmoik::foo_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Schmoik::foo>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (Schmoik::AMH_fooExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Schmoik::AMH_fooExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Schmoik::AMH_fooExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Schmoik::AMH_fooExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Schmoik::AMH_fooExceptionHolder *&_tao_valuetype)
{
  return Schmoik::AMH_fooExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_Schmoik::AMH_fooExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_Schmoik::AMH_fooExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_Schmoik::AMH_fooExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Schmoik::AMI_fooHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Schmoik::AMI_fooHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Schmoik::AMI_fooHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_structure/cdr_op_cs.cpp:48


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Schmoik::bar &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.member.in ()) &&
    true;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Schmoik::bar &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.member.out ()) &&
    true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/cdr_op_cs.cpp:92

#if !defined _TAO_CDR_OP_Thwoik_ub_TestTypeSeq_CPP_
#define _TAO_CDR_OP_Thwoik_ub_TestTypeSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Thwoik::ub_TestTypeSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Thwoik::ub_TestTypeSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Thwoik_ub_TestTypeSeq_CPP_ */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_sequence/cdr_op_cs.cpp:92

#if !defined _TAO_CDR_OP_Thwoik_bd_TestTypeSeq_CPP_
#define _TAO_CDR_OP_Thwoik_bd_TestTypeSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Thwoik::bd_TestTypeSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Thwoik::bd_TestTypeSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Thwoik_bd_TestTypeSeq_CPP_ */
// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Thwoik::TestType_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Thwoik::TestType_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Thwoik::TestType>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (Thwoik::AMH_TestTypeExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Thwoik::AMH_TestTypeExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Thwoik::AMH_TestTypeExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Thwoik::AMH_TestTypeExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Thwoik::AMH_TestTypeExceptionHolder *&_tao_valuetype)
{
  return Thwoik::AMH_TestTypeExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_Thwoik::AMH_TestTypeExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_Thwoik::AMH_TestTypeExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_Thwoik::AMH_TestTypeExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Thwoik::AMI_TestTypeHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Thwoik::AMI_TestTypeHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::Thwoik::AMI_TestTypeHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const A_mod::Foo_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    A_mod::Foo_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::A_mod::Foo>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (A_mod::AMH_FooExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (A_mod::AMH_FooExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const A_mod::AMH_FooExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&A_mod::AMH_FooExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    A_mod::AMH_FooExceptionHolder *&_tao_valuetype)
{
  return A_mod::AMH_FooExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_A_mod::AMH_FooExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_A_mod::AMH_FooExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_A_mod::AMH_FooExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const A_mod::AMI_FooHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    A_mod::AMI_FooHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::A_mod::AMI_FooHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const A_mod::B_mod::Foo_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    A_mod::B_mod::Foo_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::A_mod::B_mod::Foo>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_valuetype.cpp:506



TAO_BEGIN_VERSIONED_NAMESPACE_DECL
void
CORBA::add_ref (A_mod::B_mod::AMH_FooExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (A_mod::B_mod::AMH_FooExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/cdr_op_cs.cpp:59


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const A_mod::B_mod::AMH_FooExceptionHolder *_tao_valuetype)
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&A_mod::B_mod::AMH_FooExceptionHolder::_downcast));
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    A_mod::B_mod::AMH_FooExceptionHolder *&_tao_valuetype)
{
  return A_mod::B_mod::AMH_FooExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_valuetype/marshal_cs.cpp:189

::CORBA::Boolean
OBV_A_mod::B_mod::AMH_FooExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo &) const
{
  return true;
}

::CORBA::Boolean
OBV_A_mod::B_mod::AMH_FooExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo &)
{
  return true;
}

void
OBV_A_mod::B_mod::AMH_FooExceptionHolder::truncation_hook ()
{
  this->require_truncation_ = true;
}


// TAO_IDL - Generated from
// /home/johnny/ACE/trunk/TAO/TAO_IDL/be/be_visitor_interface/cdr_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const A_mod::B_mod::AMI_FooHandler_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    A_mod::B_mod::AMI_FooHandler_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  // Narrow to the right type.
  _tao_objref = TAO::Narrow_Utils< ::A_mod::B_mod::AMI_FooHandler>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



